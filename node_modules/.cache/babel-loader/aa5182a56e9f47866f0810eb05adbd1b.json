{"ast":null,"code":"/*!\r\n * Splide.js\r\n * Version  : 2.4.20\r\n * License  : MIT\r\n * Copyright: 2020 Naotoshi Fujita\r\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"Splide\"] = factory();else root[\"Splide\"] = factory();\n})(self, function () {\n  return (\n    /******/\n    function () {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        311:\n        /***/\n        function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n          // ESM COMPAT FLAG\n          __webpack_require__.r(__webpack_exports__); // EXPORTS\n\n\n          __webpack_require__.d(__webpack_exports__, {\n            \"default\": function _default() {\n              return (\n                /* binding */\n                module_Splide\n              );\n            }\n          }); // NAMESPACE OBJECT: ./src/js/constants/states.js\n\n\n          var states_namespaceObject = {};\n\n          __webpack_require__.r(states_namespaceObject);\n\n          __webpack_require__.d(states_namespaceObject, {\n            \"CREATED\": function CREATED() {\n              return _CREATED;\n            },\n            \"DESTROYED\": function DESTROYED() {\n              return _DESTROYED;\n            },\n            \"IDLE\": function IDLE() {\n              return _IDLE;\n            },\n            \"MOUNTED\": function MOUNTED() {\n              return _MOUNTED;\n            },\n            \"MOVING\": function MOVING() {\n              return _MOVING;\n            }\n          });\n\n          ; // CONCATENATED MODULE: ./src/js/core/event.js\n\n          /**\r\n           * The function for providing an Event object simply managing events.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The function for providing an Event object simply managing events.\r\n           */\n\n          /* harmony default export */\n\n          var core_event = function core_event() {\n            /**\r\n             * Store all event data.\r\n             *\r\n             * @type {Array}\r\n             */\n            var data = [];\n            var Event = {\n              /**\r\n               * Subscribe the given event(s).\r\n               *\r\n               * @param {string}   events  - An event name. Use space to separate multiple events.\r\n               *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n               * @param {function} handler - A callback function.\r\n               * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n               * @param {Object}   options - Optional. Options for addEventListener.\r\n               */\n              on: function on(events, handler, elm, options) {\n                if (elm === void 0) {\n                  elm = null;\n                }\n\n                if (options === void 0) {\n                  options = {};\n                }\n\n                events.split(' ').forEach(function (event) {\n                  if (elm) {\n                    elm.addEventListener(event, handler, options);\n                  }\n\n                  data.push({\n                    event: event,\n                    handler: handler,\n                    elm: elm,\n                    options: options\n                  });\n                });\n              },\n\n              /**\r\n               * Unsubscribe the given event(s).\r\n               *\r\n               * @param {string}  events - A event name or names split by space.\r\n               * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n               */\n              off: function off(events, elm) {\n                if (elm === void 0) {\n                  elm = null;\n                }\n\n                events.split(' ').forEach(function (event) {\n                  data = data.filter(function (item) {\n                    if (item && item.event === event && item.elm === elm) {\n                      unsubscribe(item);\n                      return false;\n                    }\n\n                    return true;\n                  });\n                });\n              },\n\n              /**\r\n               * Emit an event.\r\n               * This method is only for custom events.\r\n               *\r\n               * @param {string}  event - An event name.\r\n               * @param {*}       args  - Any number of arguments passed to handlers.\r\n               */\n              emit: function emit(event) {\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = arguments[_key];\n                }\n\n                data.forEach(function (item) {\n                  if (!item.elm && item.event.split('.')[0] === event) {\n                    item.handler.apply(item, args);\n                  }\n                });\n              },\n\n              /**\r\n               * Clear event data.\r\n               */\n              destroy: function destroy() {\n                data.forEach(unsubscribe);\n                data = [];\n              }\n            };\n            /**\r\n             * Remove the registered event listener.\r\n             *\r\n             * @param {Object} item - An object containing event data.\r\n             */\n\n            function unsubscribe(item) {\n              if (item.elm) {\n                item.elm.removeEventListener(item.event, item.handler, item.options);\n              }\n            }\n\n            return Event;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/core/state.js\n\n          /**\r\n           * The function providing a super simple state system.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The function providing a super simple state system.\r\n           *\r\n           * @param {string|number} initialState - Provide the initial state value.\r\n           */\n\n          /* harmony default export */\n\n          var state = function state(initialState) {\n            /**\r\n             * Store the current state.\r\n             *\r\n             * @type {string|number}\r\n             */\n            var curr = initialState;\n            return {\n              /**\r\n               * Change state.\r\n               *\r\n               * @param {string|number} state - A new state.\r\n               */\n              set: function set(state) {\n                curr = state;\n              },\n\n              /**\r\n               * Verify if the current state is given one or not.\r\n               *\r\n               * @param {string|number} state - A state name to be verified.\r\n               *\r\n               * @return {boolean} - True if the current state is the given one.\r\n               */\n              is: function is(state) {\n                return state === curr;\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/utils/object.js\n\n          function _extends() {\n            _extends = Object.assign || function (target) {\n              for (var i = 1; i < arguments.length; i++) {\n                var source = arguments[i];\n\n                for (var key in source) {\n                  if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                  }\n                }\n              }\n\n              return target;\n            };\n\n            return _extends.apply(this, arguments);\n          }\n          /**\r\n           * Some utility functions related with Object, supporting IE.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n\n          var keys = Object.keys;\n          /**\r\n           * Iterate an object like Array.forEach.\r\n           * IE doesn't support forEach of HTMLCollection.\r\n           *\r\n           * @param {Object}    obj       - An object.\r\n           * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n           */\n\n          function each(obj, callback) {\n            keys(obj).some(function (key, index) {\n              return callback(obj[key], key, index);\n            });\n          }\n          /**\r\n           * Return values of the given object as an array.\r\n           * IE doesn't support Object.values.\r\n           *\r\n           * @param {Object} obj - An object.\r\n           *\r\n           * @return {Array} - An array containing all values of the given object.\r\n           */\n\n\n          function values(obj) {\n            return keys(obj).map(function (key) {\n              return obj[key];\n            });\n          }\n          /**\r\n           * Check if the given subject is object or not.\r\n           *\r\n           * @param {*} subject - A subject to be verified.\r\n           *\r\n           * @return {boolean} - True if object, false otherwise.\r\n           */\n\n\n          function isObject(subject) {\n            return typeof subject === 'object';\n          }\n          /**\r\n           * Merge two objects deeply.\r\n           *\r\n           * @param {Object} to   - An object where \"from\" is merged.\r\n           * @param {Object} from - An object merged to \"to\".\r\n           *\r\n           * @return {Object} - A merged object.\r\n           */\n\n\n          function merge(_ref, from) {\n            var to = _extends({}, _ref);\n\n            each(from, function (value, key) {\n              if (isObject(value)) {\n                if (!isObject(to[key])) {\n                  to[key] = {};\n                }\n\n                to[key] = merge(to[key], value);\n              } else {\n                to[key] = value;\n              }\n            });\n            return to;\n          }\n          /**\r\n           * Assign all properties \"from\" to \"to\" object.\r\n           *\r\n           * @param {Object} to   - An object where properties are assigned.\r\n           * @param {Object} from - An object whose properties are assigned to \"to\".\r\n           *\r\n           * @return {Object} - An assigned object.\r\n           */\n\n\n          function object_assign(to, from) {\n            keys(from).forEach(function (key) {\n              if (!to[key]) {\n                Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n              }\n            });\n            return to;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/utils.js\n\n          /**\r\n           * A package of some miscellaneous utility functions.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Convert the given value to array.\r\n           *\r\n           * @param {*} value - Any value.\r\n           *\r\n           * @return {*[]} - Array containing the given value.\r\n           */\n\n          function toArray(value) {\n            return Array.isArray(value) ? value : [value];\n          }\n          /**\r\n           * Check if the given value is between min and max.\r\n           * Min will be returned when the value is less than min or max will do when greater than max.\r\n           *\r\n           * @param {number} value - A number to be checked.\r\n           * @param {number} m1    - Minimum or maximum number.\r\n           * @param {number} m2    - Maximum or minimum number.\r\n           *\r\n           * @return {number} - A value itself, min or max.\r\n           */\n\n\n          function between(value, m1, m2) {\n            return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n          }\n          /**\r\n           * The sprintf method with minimum functionality.\r\n           *\r\n           * @param {string}       format       - The string format.\r\n           * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n           *\r\n           * @returns {string} - Converted string.\r\n           */\n\n\n          function sprintf(format, replacements) {\n            var i = 0;\n            return format.replace(/%s/g, function () {\n              return toArray(replacements)[i++];\n            });\n          }\n          /**\r\n           * Append px unit to the given subject if necessary.\r\n           *\r\n           * @param {number|string} value - A value that may not include an unit.\r\n           *\r\n           * @return {string} - If the value is string, return itself.\r\n           *                    If number, do value + \"px\". An empty string, otherwise.\r\n           */\n\n\n          function unit(value) {\n            var type = typeof value;\n\n            if (type === 'number' && value > 0) {\n              return parseFloat(value) + 'px';\n            }\n\n            return type === 'string' ? value : '';\n          }\n          /**\r\n           * Pad start with 0.\r\n           *\r\n           * @param {number} number - A number to be filled with 0.\r\n           *\r\n           * @return {string|number} - Padded number.\r\n           */\n\n\n          function pad(number) {\n            return number < 10 ? '0' + number : number;\n          }\n          /**\r\n           * Convert the given value to pixel.\r\n           *\r\n           * @param {Element}       root  - Root element where a dummy div is appended.\r\n           * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n           *\r\n           * @return {number} - Pixel.\r\n           */\n\n\n          function toPixel(root, value) {\n            if (typeof value === 'string') {\n              var div = create('div', {});\n              applyStyle(div, {\n                position: 'absolute',\n                width: value\n              });\n              append(root, div);\n              value = div.clientWidth;\n              dom_remove(div);\n            }\n\n            return +value || 0;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/dom.js\n\n          /**\r\n           * Some utility functions related with DOM.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Find the first element matching the given selector.\r\n           * Be aware that all selectors after a space are ignored.\r\n           *\r\n           * @param {Element|Node}  elm       - An ancestor element.\r\n           * @param {string}        selector  - DOMString.\r\n           *\r\n           * @return {Element|null} - A found element or null.\r\n           */\n\n          function find(elm, selector) {\n            return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n          }\n          /**\r\n           * Find a first child having the given tag or class name.\r\n           *\r\n           * @param {Element} parent         - A parent element.\r\n           * @param {string}  tagOrClassName - A tag or class name.\r\n           *\r\n           * @return {Element|undefined} - A found element on success or undefined on failure.\r\n           */\n\n\n          function child(parent, tagOrClassName) {\n            return children(parent, tagOrClassName)[0];\n          }\n          /**\r\n           * Return chile elements that matches the provided tag or class name.\r\n           *\r\n           * @param {Element} parent         - A parent element.\r\n           * @param {string}  tagOrClassName - A tag or class name.\r\n           *\r\n           * @return {Element[]} - Found elements.\r\n           */\n\n\n          function children(parent, tagOrClassName) {\n            if (parent) {\n              return values(parent.children).filter(function (child) {\n                return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n              });\n            }\n\n            return [];\n          }\n          /**\r\n           * Create an element with some optional attributes.\r\n           *\r\n           * @param {string} tag   - A tag name.\r\n           * @param {Object} attrs - An object any attribute pairs of name and value.\r\n           *\r\n           * @return {Element} - A created element.\r\n           */\n\n\n          function create(tag, attrs) {\n            var elm = document.createElement(tag);\n            each(attrs, function (value, key) {\n              return setAttribute(elm, key, value);\n            });\n            return elm;\n          }\n          /**\r\n           * Convert HTML string to DOM node.\r\n           *\r\n           * @param {string} html - HTML string.\r\n           *\r\n           * @return {Node} - A created node.\r\n           */\n\n\n          function domify(html) {\n            var div = create('div', {});\n            div.innerHTML = html;\n            return div.firstChild;\n          }\n          /**\r\n           * Remove a given element from a DOM tree.\r\n           *\r\n           * @param {Element|Element[]} elms - Element(s) to be removed.\r\n           */\n\n\n          function dom_remove(elms) {\n            toArray(elms).forEach(function (elm) {\n              if (elm) {\n                var parent = elm.parentElement;\n                parent && parent.removeChild(elm);\n              }\n            });\n          }\n          /**\r\n           * Append a child to a given element.\r\n           *\r\n           * @param {Element} parent - A parent element.\r\n           * @param {Element} child  - An element to be appended.\r\n           */\n\n\n          function append(parent, child) {\n            if (parent) {\n              parent.appendChild(child);\n            }\n          }\n          /**\r\n           * Insert an element before the reference element.\r\n           *\r\n           * @param {Element|Node} ref - A reference element.\r\n           * @param {Element}      elm - An element to be inserted.\r\n           */\n\n\n          function before(elm, ref) {\n            if (elm && ref) {\n              var parent = ref.parentElement;\n              parent && parent.insertBefore(elm, ref);\n            }\n          }\n          /**\r\n           * Apply styles to the given element.\r\n           *\r\n           * @param {Element} elm     - An element where styles are applied.\r\n           * @param {Object}  styles  - Object containing styles.\r\n           */\n\n\n          function applyStyle(elm, styles) {\n            if (elm) {\n              each(styles, function (value, prop) {\n                if (value !== null) {\n                  elm.style[prop] = value;\n                }\n              });\n            }\n          }\n          /**\r\n           * Add or remove classes to/from the element.\r\n           * This function is for internal usage.\r\n           *\r\n           * @param {Element}         elm     - An element where classes are added.\r\n           * @param {string|string[]} classes - Class names being added.\r\n           * @param {boolean}         remove  - Whether to remove or add classes.\r\n           */\n\n\n          function addOrRemoveClasses(elm, classes, remove) {\n            if (elm) {\n              toArray(classes).forEach(function (name) {\n                if (name) {\n                  elm.classList[remove ? 'remove' : 'add'](name);\n                }\n              });\n            }\n          }\n          /**\r\n           * Add classes to the element.\r\n           *\r\n           * @param {Element}          elm     - An element where classes are added.\r\n           * @param {string|string[]}  classes - Class names being added.\r\n           */\n\n\n          function addClass(elm, classes) {\n            addOrRemoveClasses(elm, classes, false);\n          }\n          /**\r\n           * Remove a class from the element.\r\n           *\r\n           * @param {Element}         elm     - An element where classes are removed.\r\n           * @param {string|string[]} classes - A class name being removed.\r\n           */\n\n\n          function removeClass(elm, classes) {\n            addOrRemoveClasses(elm, classes, true);\n          }\n          /**\r\n           * Verify if the provided element has the class or not.\r\n           *\r\n           * @param {Element} elm       - An element.\r\n           * @param {string}  className - A class name.\r\n           *\r\n           * @return {boolean} - True if the element has the class or false if not.\r\n           */\n\n\n          function hasClass(elm, className) {\n            return !!elm && elm.classList.contains(className);\n          }\n          /**\r\n           * Set attribute to the given element.\r\n           *\r\n           * @param {Element}                 elm   - An element where an attribute is assigned.\r\n           * @param {string}                  name  - Attribute name.\r\n           * @param {string|number|boolean}   value - Attribute value.\r\n           */\n\n\n          function setAttribute(elm, name, value) {\n            if (elm) {\n              elm.setAttribute(name, value);\n            }\n          }\n          /**\r\n           * Get attribute from the given element.\r\n           *\r\n           * @param {Element} elm  - An element where an attribute is assigned.\r\n           * @param {string}  name - Attribute name.\r\n           *\r\n           * @return {string} - The value of the given attribute if available. An empty string if not.\r\n           */\n\n\n          function getAttribute(elm, name) {\n            return elm ? elm.getAttribute(name) : '';\n          }\n          /**\r\n           * Remove attribute from the given element.\r\n           *\r\n           * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n           * @param {string|string[]}      names - Attribute name.\r\n           */\n\n\n          function removeAttribute(elms, names) {\n            toArray(names).forEach(function (name) {\n              toArray(elms).forEach(function (elm) {\n                return elm && elm.removeAttribute(name);\n              });\n            });\n          }\n          /**\r\n           * Return the Rect object of the provided object.\r\n           *\r\n           * @param {Element} elm - An element.\r\n           *\r\n           * @return {ClientRect|DOMRect} - A rect object.\r\n           */\n\n\n          function getRect(elm) {\n            return elm.getBoundingClientRect();\n          }\n          /**\r\n           * Trigger the given callback after all images contained by the element are loaded.\r\n           *\r\n           * @param {Element}  elm      - Element that may contain images.\r\n           * @param {Function} callback - Callback function fired right after all images are loaded.\r\n           */\n\n\n          function loaded(elm, callback) {\n            var images = elm.querySelectorAll('img');\n            var length = images.length;\n\n            if (length) {\n              var count = 0;\n              each(images, function (img) {\n                img.onload = img.onerror = function () {\n                  if (++count === length) {\n                    callback();\n                  }\n                };\n              });\n            } else {\n              // Trigger the callback immediately if there is no image.\n              callback();\n            }\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/constants/types.js\n\n          /**\r\n           * Export slider types.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Normal slider.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SLIDE = 'slide';\n          /**\r\n           * Loop after the last slide and before the first one.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var LOOP = 'loop';\n          /**\r\n           * The track doesn't move.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var FADE = 'fade';\n          ; // CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n\n          /**\r\n           * The component for general slide effect transition.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for general slide effect transition.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var slide = function slide(Splide, Components) {\n            /**\r\n             * Hold the list element.\r\n             *\r\n             * @type {Element}\r\n             */\n            var list;\n            /**\r\n             * Hold the onEnd callback function.\r\n             *\r\n             * @type {function}\r\n             */\n\n            var endCallback;\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                list = Components.Elements.list;\n                Splide.on('transitionend', function (e) {\n                  if (e.target === list && endCallback) {\n                    endCallback();\n                  }\n                }, list);\n              },\n\n              /**\r\n               * Start transition.\r\n               *\r\n               * @param {number}   destIndex - Destination slide index that might be clone's.\r\n               * @param {number}   newIndex  - New index.\r\n               * @param {number}   prevIndex - Previous index.\r\n               * @param {Object}   coord     - Destination coordinates.\r\n               * @param {function} done      - Callback function must be invoked when transition is completed.\r\n               */\n              start: function start(destIndex, newIndex, prevIndex, coord, done) {\n                var options = Splide.options;\n                var edgeIndex = Components.Controller.edgeIndex;\n                var speed = options.speed;\n                endCallback = done;\n\n                if (Splide.is(SLIDE)) {\n                  if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n                    speed = options.rewindSpeed || speed;\n                  }\n                }\n\n                applyStyle(list, {\n                  transition: \"transform \" + speed + \"ms \" + options.easing,\n                  transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n                });\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n\n          /**\r\n           * The component for fade transition.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for fade transition.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var fade = function fade(Splide, Components) {\n            var Fade = {\n              /**\r\n               * Called when the component is mounted.\r\n               * Apply transition style to the first slide.\r\n               */\n              mount: function mount() {\n                apply(Splide.index);\n              },\n\n              /**\r\n               * Start transition.\r\n               *\r\n               * @param {number}    destIndex - Destination slide index that might be clone's.\r\n               * @param {number}    newIndex  - New index.\r\n               * @param {number}    prevIndex - Previous index.\r\n               * @param {Object}    coord     - Destination coordinates.\r\n               * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n               */\n              start: function start(destIndex, newIndex, prevIndex, coord, done) {\n                var track = Components.Elements.track;\n                applyStyle(track, {\n                  height: unit(track.clientHeight)\n                });\n                apply(newIndex);\n                setTimeout(function () {\n                  done();\n                  applyStyle(track, {\n                    height: ''\n                  });\n                });\n              }\n            };\n            /**\r\n             * Apply transition style to the slide specified by the given index.\r\n             *\r\n             * @param {number} index - A slide index.\r\n             */\n\n            function apply(index) {\n              var options = Splide.options;\n              applyStyle(Components.Elements.slides[index], {\n                transition: \"opacity \" + options.speed + \"ms \" + options.easing\n              });\n            }\n\n            return Fade;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/transitions/index.js\n\n          /**\r\n           * Export transition components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          ; // CONCATENATED MODULE: ./src/js/core/composer.js\n\n          /**\r\n           * Provide a function for composing components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Compose components.\r\n           *\r\n           * @param {Splide}   Splide     - Splide instance.\r\n           * @param {Object}   Components - Additional components.\r\n           * @param {function} Transition - Change component for transition.\r\n           *\r\n           * @return {Object} - An object containing all components.\r\n           */\n\n          function compose(Splide, Components, Transition) {\n            var components = {};\n            each(Components, function (Component, name) {\n              components[name] = Component(Splide, components, name.toLowerCase());\n            });\n\n            if (!Transition) {\n              Transition = Splide.is(FADE) ? fade : slide;\n            }\n\n            components.Transition = Transition(Splide, components);\n            return components;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/error.js\n\n          /**\r\n           * Utility functions for outputting logs.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Prefix of an error massage.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var MESSAGE_PREFIX = '[SPLIDE]';\n          /**\r\n           * Display an error message on the browser console.\r\n           *\r\n           * @param {string} message - An error message.\r\n           */\n\n          function error(message) {\n            console.error(MESSAGE_PREFIX + \" \" + message);\n          }\n          /**\r\n           * Check existence of the given object and throw an error if it doesn't.\r\n           *\r\n           * @throws {Error}\r\n           *\r\n           * @param {*}      subject - A subject to be confirmed.\r\n           * @param {string} message - An error message.\r\n           */\n\n\n          function exist(subject, message) {\n            if (!subject) {\n              throw new Error(message);\n            }\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/constants/classes.js\n\n          /**\r\n           * Export class names.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * A root class name.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ROOT = 'splide';\n          /**\r\n           * The definition table of all classes for elements.\r\n           * They might be modified by options.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var ELEMENT_CLASSES = {\n            root: ROOT,\n            slider: ROOT + \"__slider\",\n            track: ROOT + \"__track\",\n            list: ROOT + \"__list\",\n            slide: ROOT + \"__slide\",\n            container: ROOT + \"__slide__container\",\n            arrows: ROOT + \"__arrows\",\n            arrow: ROOT + \"__arrow\",\n            prev: ROOT + \"__arrow--prev\",\n            next: ROOT + \"__arrow--next\",\n            pagination: ROOT + \"__pagination\",\n            page: ROOT + \"__pagination__page\",\n            clone: ROOT + \"__slide--clone\",\n            progress: ROOT + \"__progress\",\n            bar: ROOT + \"__progress__bar\",\n            autoplay: ROOT + \"__autoplay\",\n            play: ROOT + \"__play\",\n            pause: ROOT + \"__pause\",\n            spinner: ROOT + \"__spinner\",\n            sr: ROOT + \"__sr\"\n          };\n          /**\r\n           * Definitions of status classes.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var STATUS_CLASSES = {\n            active: 'is-active',\n            visible: 'is-visible',\n            loading: 'is-loading'\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/i18n.js\n\n          /**\r\n           * Export i18n texts as object.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Texts for i18n.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var I18N = {\n            prev: 'Previous slide',\n            next: 'Next slide',\n            first: 'Go to first slide',\n            last: 'Go to last slide',\n            slideX: 'Go to slide %s',\n            pageX: 'Go to page %s',\n            play: 'Start autoplay',\n            pause: 'Pause autoplay'\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/defaults.js\n\n          /**\r\n           * Export default options.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var DEFAULTS = {\n            /**\r\n             * Determine a slider type.\r\n             * - 'slide': Regular slider.\r\n             * - 'loop' : Carousel slider.\r\n             * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n             *\r\n             * @type {string}\r\n             */\n            type: 'slide',\n\n            /**\r\n             * Whether to rewind a slider before the first slide or after the last one.\r\n             * In \"loop\" mode, this option is ignored.\r\n             *\r\n             * @type {boolean}\r\n             */\n            rewind: false,\n\n            /**\r\n             * Transition speed in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            speed: 400,\n\n            /**\r\n             * Transition speed on rewind in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            rewindSpeed: 0,\n\n            /**\r\n             * Whether to prevent any actions while a slider is transitioning.\r\n             * If false, navigation, drag and swipe work while the slider is running.\r\n             * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n             *\r\n             * @type {boolean}\r\n             */\n            waitForTransition: true,\n\n            /**\r\n             * Define slider max width.\r\n             *\r\n             * @type {number}\r\n             */\n            width: 0,\n\n            /**\r\n             * Define slider height.\r\n             *\r\n             * @type {number}\r\n             */\n            height: 0,\n\n            /**\r\n             * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n             * perPage number will be ignored when this option is falsy.\r\n             *\r\n             * @type {number|string}\r\n             */\n            fixedWidth: 0,\n\n            /**\r\n             * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n             * heightRatio option will be ignored when this option is falsy.\r\n             *\r\n             * @type {number|string}\r\n             */\n            fixedHeight: 0,\n\n            /**\r\n             * Determine height of slides by ratio to a slider width.\r\n             * This will be ignored when the fixedHeight is provided.\r\n             *\r\n             * @type {number}\r\n             */\n            heightRatio: 0,\n\n            /**\r\n             * If true, slide width will be determined by the element width itself.\r\n             * - perPage/perMove should be 1.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoWidth: false,\n\n            /**\r\n             * If true, slide height will be determined by the element width itself.\r\n             * - perPage/perMove should be 1.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoHeight: false,\n\n            /**\r\n             * Determine how many slides should be displayed per page.\r\n             *\r\n             * @type {number}\r\n             */\n            perPage: 1,\n\n            /**\r\n             * Determine how many slides should be moved when a slider goes to next or perv.\r\n             *\r\n             * @type {number}\r\n             */\n            perMove: 0,\n\n            /**\r\n             * Determine manually how many clones should be generated on the left and right side.\r\n             * The total number of clones will be twice of this number.\r\n             *\r\n             * @type {number}\r\n             */\n            clones: 0,\n\n            /**\r\n             * Start index.\r\n             *\r\n             * @type {number}\r\n             */\n            start: 0,\n\n            /**\r\n             * Determine which slide should be focused if there are multiple slides in a page.\r\n             * A string \"center\" is acceptable for centering slides.\r\n             *\r\n             * @type {boolean|number|string}\r\n             */\n            focus: false,\n\n            /**\r\n             * Gap between slides. CSS format is allowed such as 1em.\r\n             *\r\n             * @type {number|string}\r\n             */\n            gap: 0,\n\n            /**\r\n             * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n             * Give a single value to set a same size for both sides or\r\n             * do an object for different sizes.\r\n             * Also, CSS format is allowed such as 1em.\r\n             *\r\n             * @example\r\n             * - 10: Number\r\n             * - '1em': CSS format.\r\n             * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n             * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n             *\r\n             * @type {number|string|Object}\r\n             */\n            padding: 0,\n\n            /**\r\n             * Whether to append arrows.\r\n             *\r\n             * @type {boolean}\r\n             */\n            arrows: true,\n\n            /**\r\n             * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n             *\r\n             * @type {string}\r\n             */\n            arrowPath: '',\n\n            /**\r\n             * Whether to append pagination(indicator dots) or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pagination: true,\n\n            /**\r\n             * Activate autoplay.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoplay: false,\n\n            /**\r\n             * Autoplay interval in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            interval: 5000,\n\n            /**\r\n             * Whether to stop autoplay when a slider is hovered.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pauseOnHover: true,\n\n            /**\r\n             * Whether to stop autoplay when a slider elements are focused.\r\n             * True is recommended for accessibility.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pauseOnFocus: true,\n\n            /**\r\n             * Whether to reset progress of the autoplay timer when resumed.\r\n             *\r\n             * @type {boolean}\r\n             */\n            resetProgress: true,\n\n            /**\r\n             * Loading images lazily.\r\n             * Image src must be provided by a data-splide-lazy attribute.\r\n             *\r\n             * - false: Do nothing.\r\n             * - 'nearby': Only images around an active slide will be loaded.\r\n             * - 'sequential': All images will be sequentially loaded.\r\n             *\r\n             * @type {boolean|string}\r\n             */\n            lazyLoad: false,\n\n            /**\r\n             * This option works only when a lazyLoad option is \"nearby\".\r\n             * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n             *\r\n             * @type {number}\r\n             */\n            preloadPages: 1,\n\n            /**\r\n             * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n             *\r\n             * @type {string}\r\n             */\n            easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n            /**\r\n             * Whether to enable keyboard shortcuts\r\n             * - true or 'global': Listen to keydown event of the document.\r\n             * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n             * - false: Disable keyboard shortcuts.\r\n             *\r\n             * @type {boolean|string}\r\n             */\n            keyboard: 'global',\n\n            /**\r\n             * Whether to allow mouse drag and touch swipe.\r\n             *\r\n             * @type {boolean}\r\n             */\n            drag: true,\n\n            /**\r\n             * The angle threshold for drag.\r\n             * The slider starts moving only when the drag angle is less than this threshold.\r\n             *\r\n             * @type {number}\r\n             */\n            dragAngleThreshold: 30,\n\n            /**\r\n             * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n             * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n             *\r\n             * @type {number}\r\n             */\n            swipeDistanceThreshold: 150,\n\n            /**\r\n             * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n             * Around 0.5 is recommended.\r\n             *\r\n             * @type {number}\r\n             */\n            flickVelocityThreshold: .6,\n\n            /**\r\n             * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n             * Around 500 is recommended.\r\n             *\r\n             * @type {number}\r\n             */\n            flickPower: 600,\n\n            /**\r\n             * Limit a number of pages to move by flick.\r\n             *\r\n             * @type {number}\r\n             */\n            flickMaxPages: 1,\n\n            /**\r\n             * Slider direction.\r\n             * - 'ltr': Left to right.\r\n             * - 'rtl': Right to left.\r\n             * - 'ttb': Top to bottom.\r\n             *\r\n             * @type {string}\r\n             */\n            direction: 'ltr',\n\n            /**\r\n             * Set img src to background-image of its parent element.\r\n             * Images with various sizes can be displayed as same dimension without cropping work.\r\n             * fixedHeight or heightRatio is required.\r\n             *\r\n             * @type {boolean}\r\n             */\n            cover: false,\n\n            /**\r\n             * Whether to enable accessibility(aria and screen reader texts) or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            accessibility: true,\n\n            /**\r\n             * Whether to add tabindex=\"0\" to visible slides or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            slideFocus: true,\n\n            /**\r\n             * Determine if a slider is navigation for another.\r\n             * Use \"sync\" API to synchronize two sliders.\r\n             *\r\n             * @type {boolean}\r\n             */\n            isNavigation: false,\n\n            /**\r\n             * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n             *\r\n             * @type {boolean}\r\n             */\n            trimSpace: true,\n\n            /**\r\n             * The \"is-active\" class is added after transition as default.\r\n             * If true, it will be added before move.\r\n             *\r\n             * @type {boolean}\r\n             */\n            updateOnMove: false,\n\n            /**\r\n             * Throttle duration in milliseconds for the resize event.\r\n             *\r\n             * @type {number}\r\n             */\n            throttle: 100,\n\n            /**\r\n             * Whether to destroy a slider or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            destroy: false,\n\n            /**\r\n             * Options for specific breakpoints.\r\n             *\r\n             * @example\r\n             * {\r\n             *   1000: {\r\n             *     perPage: 3,\r\n             *     gap: 20\r\n             *   },\r\n             *   600: {\r\n             *     perPage: 1,\r\n             *     gap: 5,\r\n             *   }\r\n             * }\r\n             *\r\n             * @type {boolean|Object}\r\n             */\n            breakpoints: false,\n\n            /**\r\n             * Collection of class names.\r\n             *\r\n             * @see ./classes.js\r\n             *\r\n             * @type {Object}\r\n             */\n            classes: ELEMENT_CLASSES,\n\n            /**\r\n             * Collection of i18n texts.\r\n             *\r\n             * @see ./i18n.js\r\n             *\r\n             * @type {Object}\r\n             */\n            i18n: I18N\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/states.js\n\n          /**\r\n           * Export state constants.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Splide has been just created.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var _CREATED = 1;\n          /**\r\n           * All components have been mounted and initialized.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var _MOUNTED = 2;\n          /**\r\n           * Splide is ready for transition.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var _IDLE = 3;\n          /**\r\n           * Splide is moving.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var _MOVING = 4;\n          /**\r\n           * Splide is moving.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var _DESTROYED = 5;\n          ; // CONCATENATED MODULE: ./src/js/splide.js\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n          /**\r\n           * The main class for applying Splide to an element.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The main class for applying Splide to an element,\r\n           * providing some APIs to control the behavior.\r\n           */\n\n\n          var Splide = /*#__PURE__*/function () {\n            /**\r\n             * Splide constructor.\r\n             *\r\n             * @throws {Error} When the given root element or selector is invalid.\r\n             *\r\n             * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n             * @param {Object}          options    - Optional. Options to change default behaviour.\r\n             * @param {Object}          Components - Optional. Components.\r\n             */\n            function Splide(root, options, Components) {\n              if (options === void 0) {\n                options = {};\n              }\n\n              if (Components === void 0) {\n                Components = {};\n              }\n\n              this.root = root instanceof Element ? root : document.querySelector(root);\n              exist(this.root, 'An invalid element/selector was given.');\n              this.Components = null;\n              this.Event = core_event();\n              this.State = state(_CREATED);\n              this.STATES = states_namespaceObject;\n              this._o = merge(DEFAULTS, options);\n              this._i = 0;\n              this._c = Components;\n              this._e = {}; // Extensions\n\n              this._t = null; // Transition\n            }\n            /**\r\n             * Compose and mount components.\r\n             *\r\n             * @param {Object}   Extensions - Optional. Additional components.\r\n             * @param {function} Transition - Optional. Set a custom transition component.\r\n             *\r\n             * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n             */\n\n\n            var _proto = Splide.prototype;\n\n            _proto.mount = function mount(Extensions, Transition) {\n              var _this = this;\n\n              if (Extensions === void 0) {\n                Extensions = this._e;\n              }\n\n              if (Transition === void 0) {\n                Transition = this._t;\n              } // Reset the state.\n\n\n              this.State.set(_CREATED);\n              this._e = Extensions;\n              this._t = Transition;\n              this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n              try {\n                each(this.Components, function (component, key) {\n                  var required = component.required;\n\n                  if (required === undefined || required) {\n                    component.mount && component.mount();\n                  } else {\n                    delete _this.Components[key];\n                  }\n                });\n              } catch (e) {\n                error(e.message);\n                return;\n              }\n\n              var State = this.State;\n              State.set(_MOUNTED);\n              each(this.Components, function (component) {\n                component.mounted && component.mounted();\n              });\n              this.emit('mounted');\n              State.set(_IDLE);\n              this.emit('ready');\n              applyStyle(this.root, {\n                visibility: 'visible'\n              });\n              this.on('move drag', function () {\n                return State.set(_MOVING);\n              }).on('moved dragged', function () {\n                return State.set(_IDLE);\n              });\n              return this;\n            }\n            /**\r\n             * Set sync target.\r\n             *\r\n             * @param {Splide} splide - A Splide instance.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.sync = function sync(splide) {\n              this.sibling = splide;\n              return this;\n            }\n            /**\r\n             * Register callback fired on the given event(s).\r\n             *\r\n             * @param {string}   events  - An event name. Use space to separate multiple events.\r\n             *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n             * @param {function} handler - A callback function.\r\n             * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n             * @param {Object}   options - Optional. Options for addEventListener.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.on = function on(events, handler, elm, options) {\n              if (elm === void 0) {\n                elm = null;\n              }\n\n              if (options === void 0) {\n                options = {};\n              }\n\n              this.Event.on(events, handler, elm, options);\n              return this;\n            }\n            /**\r\n             * Unsubscribe the given event.\r\n             *\r\n             * @param {string}  events - A event name.\r\n             * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.off = function off(events, elm) {\n              if (elm === void 0) {\n                elm = null;\n              }\n\n              this.Event.off(events, elm);\n              return this;\n            }\n            /**\r\n             * Emit an event.\r\n             *\r\n             * @param {string} event - An event name.\r\n             * @param {*}      args  - Any number of arguments passed to handlers.\r\n             */\n            ;\n\n            _proto.emit = function emit(event) {\n              var _this$Event;\n\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n\n              (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n              return this;\n            }\n            /**\r\n             * Go to the slide specified by the given control.\r\n             *\r\n             * @param {string|number} control - A control pattern.\r\n             * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n             */\n            ;\n\n            _proto.go = function go(control, wait) {\n              if (wait === void 0) {\n                wait = this.options.waitForTransition;\n              }\n\n              if (this.State.is(_IDLE) || this.State.is(_MOVING) && !wait) {\n                this.Components.Controller.go(control, false);\n              }\n\n              return this;\n            }\n            /**\r\n             * Verify whether the slider type is the given one or not.\r\n             *\r\n             * @param {string} type - A slider type.\r\n             *\r\n             * @return {boolean} - True if the slider type is the provided type or false if not.\r\n             */\n            ;\n\n            _proto.is = function is(type) {\n              return type === this._o.type;\n            }\n            /**\r\n             * Insert a slide.\r\n             *\r\n             * @param {Element|string} slide - A slide element to be added.\r\n             * @param {number}         index - A slide will be added at the position.\r\n             */\n            ;\n\n            _proto.add = function add(slide, index) {\n              if (index === void 0) {\n                index = -1;\n              }\n\n              this.Components.Elements.add(slide, index, this.refresh.bind(this));\n              return this;\n            }\n            /**\r\n             * Remove the slide designated by the index.\r\n             *\r\n             * @param {number} index - A slide index.\r\n             */\n            ;\n\n            _proto.remove = function remove(index) {\n              this.Components.Elements.remove(index);\n              this.refresh();\n              return this;\n            }\n            /**\r\n             * Destroy all Slide objects and clones and recreate them again.\r\n             */\n            ;\n\n            _proto.refresh = function refresh() {\n              this.emit('refresh:before').emit('refresh').emit('resize');\n              return this;\n            }\n            /**\r\n             * Destroy the Splide.\r\n             * \"Completely\" boolean is mainly for breakpoints.\r\n             *\r\n             * @param {boolean} completely - Destroy completely.\r\n             */\n            ;\n\n            _proto.destroy = function destroy(completely) {\n              var _this2 = this;\n\n              if (completely === void 0) {\n                completely = true;\n              } // Postpone destroy because it should be done after mount.\n\n\n              if (this.State.is(_CREATED)) {\n                this.on('ready', function () {\n                  return _this2.destroy(completely);\n                });\n                return;\n              }\n\n              values(this.Components).reverse().forEach(function (component) {\n                component.destroy && component.destroy(completely);\n              });\n              this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n              this.Event.destroy();\n              this.State.set(_DESTROYED);\n              return this;\n            }\n            /**\r\n             * Return the current slide index.\r\n             *\r\n             * @return {number} - The current slide index.\r\n             // */\n            ;\n\n            _createClass(Splide, [{\n              key: \"index\",\n              get: function get() {\n                return this._i;\n              }\n              /**\r\n               * Set the current slide index.\r\n               *\r\n               * @param {number|string} index - A new index.\r\n               */\n              ,\n              set: function set(index) {\n                this._i = parseInt(index);\n              }\n              /**\r\n               * Return length of slides.\r\n               * This is an alias of Elements.length.\r\n               *\r\n               * @return {number} - A number of slides.\r\n               */\n\n            }, {\n              key: \"length\",\n              get: function get() {\n                return this.Components.Elements.length;\n              }\n              /**\r\n               * Return options.\r\n               *\r\n               * @return {Object} - Options object.\r\n               */\n\n            }, {\n              key: \"options\",\n              get: function get() {\n                return this._o;\n              }\n              /**\r\n               * Set options with merging the given object to the current one.\r\n               *\r\n               * @param {Object} options - New options.\r\n               */\n              ,\n              set: function set(options) {\n                var created = this.State.is(_CREATED);\n\n                if (!created) {\n                  this.emit('update');\n                }\n\n                this._o = merge(this._o, options);\n\n                if (!created) {\n                  this.emit('updated', this._o);\n                }\n              }\n              /**\r\n               * Return the class list.\r\n               * This is an alias of Splide.options.classList.\r\n               *\r\n               * @return {Object} - An object containing all class list.\r\n               */\n\n            }, {\n              key: \"classes\",\n              get: function get() {\n                return this._o.classes;\n              }\n              /**\r\n               * Return the i18n strings.\r\n               * This is an alias of Splide.options.i18n.\r\n               *\r\n               * @return {Object} - An object containing all i18n strings.\r\n               */\n\n            }, {\n              key: \"i18n\",\n              get: function get() {\n                return this._o.i18n;\n              }\n            }]);\n\n            return Splide;\n          }();\n\n          ; // CONCATENATED MODULE: ./src/js/components/options/index.js\n\n          /**\r\n           * The component for initializing options.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for initializing options.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var options = function options(Splide) {\n            /**\r\n             * Retrieve options from the data attribute.\r\n             * Note that IE10 doesn't support dataset property.\r\n             *\r\n             * @type {string}\r\n             */\n            var options = getAttribute(Splide.root, 'data-splide');\n\n            if (options) {\n              try {\n                Splide.options = JSON.parse(options);\n              } catch (e) {\n                error(e.message);\n              }\n            }\n\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                if (Splide.State.is(_CREATED)) {\n                  Splide.index = Splide.options.start;\n                }\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/constants/directions.js\n\n          /**\r\n           * Export layout modes.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Enumerate slides from left to right.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var LTR = 'ltr';\n          /**\r\n           * Enumerate slides from right to left.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var RTL = 'rtl';\n          /**\r\n           * Enumerate slides in a col.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var TTB = 'ttb';\n          ; // CONCATENATED MODULE: ./src/js/components/elements/slide.js\n\n          /**\r\n           * The sub component for handling each slide.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Events for restoring original styles.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var STYLE_RESTORE_EVENTS = 'update.slide';\n          /**\r\n           * The sub component for handling each slide.\r\n           *\r\n           * @param {Splide}  Splide    - A Splide instance.\r\n           * @param {number}  index     - An unique slide index.\r\n           * @param {number}  realIndex - Clones should pass a real slide index.\r\n           * @param {Element} slide     - A slide element.\r\n           *\r\n           * @return {Object} - The sub component object.\r\n           */\n\n          /* harmony default export */\n\n          var elements_slide = function elements_slide(Splide, index, realIndex, slide) {\n            /**\r\n             * Whether to update \"is-active\" class before or after transition.\r\n             *\r\n             * @type {boolean}\r\n             */\n            var updateOnMove = Splide.options.updateOnMove;\n            /**\r\n             * Events when the slide status is updated.\r\n             * Append a namespace to remove listeners later.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n            /**\r\n             * Slide sub component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Slide = {\n              /**\r\n               * Slide element.\r\n               *\r\n               * @type {Element}\r\n               */\n              slide: slide,\n\n              /**\r\n               * Slide index.\r\n               *\r\n               * @type {number}\r\n               */\n              index: index,\n\n              /**\r\n               * Real index for clones.\r\n               *\r\n               * @type {number}\r\n               */\n              realIndex: realIndex,\n\n              /**\r\n               * Container element if available.\r\n               *\r\n               * @type {Element|undefined}\r\n               */\n              container: child(slide, Splide.classes.container),\n\n              /**\r\n               * Whether this is a cloned slide or not.\r\n               *\r\n               * @type {boolean}\r\n               */\n              isClone: realIndex > -1,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                if (!this.isClone) {\n                  slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n                }\n\n                Splide.on(STATUS_UPDATE_EVENTS, function () {\n                  return _this.update();\n                }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n                  return Splide.emit('click', _this);\n                }, slide);\n                /*\r\n                 * Add \"is-active\" class to a clone element temporarily\r\n                 * and it will be removed on \"moved\" event.\r\n                 */\n\n                if (updateOnMove) {\n                  Splide.on('move.slide', function (newIndex) {\n                    if (newIndex === realIndex) {\n                      _update(true, false);\n                    }\n                  });\n                } // Make sure the slide is shown.\n\n\n                applyStyle(slide, {\n                  display: ''\n                }); // Hold the original styles.\n\n                this.styles = getAttribute(slide, 'style') || '';\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n                removeClass(slide, values(STATUS_CLASSES));\n                restoreStyles();\n                removeAttribute(this.container, 'style');\n              },\n\n              /**\r\n               * Update active and visible status.\r\n               */\n              update: function update() {\n                _update(this.isActive(), false);\n\n                _update(this.isVisible(), true);\n              },\n\n              /**\r\n               * Check whether this slide is active or not.\r\n               *\r\n               * @return {boolean} - True if the slide is active or false if not.\r\n               */\n              isActive: function isActive() {\n                return Splide.index === index;\n              },\n\n              /**\r\n               * Check whether this slide is visible in the viewport or not.\r\n               *\r\n               * @return {boolean} - True if the slide is visible or false if not.\r\n               */\n              isVisible: function isVisible() {\n                var active = this.isActive();\n\n                if (Splide.is(FADE) || active) {\n                  return active;\n                }\n\n                var ceil = Math.ceil;\n                var trackRect = getRect(Splide.Components.Elements.track);\n                var slideRect = getRect(slide);\n\n                if (Splide.options.direction === TTB) {\n                  return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n                }\n\n                return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n              },\n\n              /**\r\n               * Calculate how far this slide is from another slide and\r\n               * return true if the distance is within the given number.\r\n               *\r\n               * @param {number} from   - Index of a target slide.\r\n               * @param {number} within - True if the slide is within this number.\r\n               *\r\n               * @return {boolean} - True if the slide is within the number or false otherwise.\r\n               */\n              isWithin: function isWithin(from, within) {\n                var diff = Math.abs(from - index);\n\n                if (!Splide.is(SLIDE) && !this.isClone) {\n                  diff = Math.min(diff, Splide.length - diff);\n                }\n\n                return diff < within;\n              }\n            };\n            /**\r\n             * Update classes for activity or visibility.\r\n             *\r\n             * @param {boolean} active        - Is active/visible or not.\r\n             * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n             */\n\n            function _update(active, forVisibility) {\n              var type = forVisibility ? 'visible' : 'active';\n              var className = STATUS_CLASSES[type];\n\n              if (active) {\n                addClass(slide, className);\n                Splide.emit(\"\" + type, Slide);\n              } else {\n                if (hasClass(slide, className)) {\n                  removeClass(slide, className);\n                  Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n                }\n              }\n            }\n            /**\r\n             * Restore the original styles.\r\n             */\n\n\n            function restoreStyles() {\n              setAttribute(slide, 'style', Slide.styles);\n            }\n\n            return Slide;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/elements/index.js\n\n          /**\r\n           * The component for main elements.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The property name for UID stored in a window object.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var UID_NAME = 'uid';\n          /**\r\n           * The component for main elements.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var components_elements = function components_elements(Splide, Components) {\n            /**\r\n             * Hold the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n            var root = Splide.root;\n            /**\r\n             * Hold the class list.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var classes = Splide.classes;\n            /**\r\n             * Store Slide objects.\r\n             *\r\n             * @type {Array}\r\n             */\n\n            var Slides = [];\n            /*\r\n             * Assign unique ID to the root element if it doesn't have the one.\r\n             * Note that IE doesn't support padStart() to fill the uid by 0.\r\n             */\n\n            if (!root.id) {\n              window.splide = window.splide || {};\n              var uid = window.splide[UID_NAME] || 0;\n              window.splide[UID_NAME] = ++uid;\n              root.id = \"splide\" + pad(uid);\n            }\n            /**\r\n             * Elements component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n\n            var Elements = {\n              /**\r\n               * Called when the component is mounted.\r\n               * Collect main elements and store them as member properties.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                this.init();\n                Splide.on('refresh', function () {\n                  _this.destroy();\n\n                  _this.init();\n                }).on('updated', function () {\n                  removeClass(root, getClasses());\n                  addClass(root, getClasses());\n                });\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                Slides.forEach(function (Slide) {\n                  Slide.destroy();\n                });\n                Slides = [];\n                removeClass(root, getClasses());\n              },\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                var _this2 = this;\n\n                collect();\n                addClass(root, getClasses());\n                this.slides.forEach(function (slide, index) {\n                  _this2.register(slide, index, -1);\n                });\n              },\n\n              /**\r\n               * Register a slide to create a Slide object and handle its behavior.\r\n               *\r\n               * @param {Element} slide     - A slide element.\r\n               * @param {number}  index     - A unique index. This can be negative.\r\n               * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n               */\n              register: function register(slide, index, realIndex) {\n                var SlideObject = elements_slide(Splide, index, realIndex, slide);\n                SlideObject.mount();\n                Slides.push(SlideObject);\n              },\n\n              /**\r\n               * Return the Slide object designated by the index.\r\n               * Note that \"find\" is not supported by IE.\r\n               *\r\n               * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n               */\n              getSlide: function getSlide(index) {\n                return Slides.filter(function (Slide) {\n                  return Slide.index === index;\n                })[0];\n              },\n\n              /**\r\n               * Return all Slide objects.\r\n               *\r\n               * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n               *\r\n               * @return {Object[]} - Slide objects.\r\n               */\n              getSlides: function getSlides(includeClones) {\n                return includeClones ? Slides : Slides.filter(function (Slide) {\n                  return !Slide.isClone;\n                });\n              },\n\n              /**\r\n               * Return Slide objects belonging to the given page.\r\n               *\r\n               * @param {number} page - A page number.\r\n               *\r\n               * @return {Object[]} - An array containing Slide objects.\r\n               */\n              getSlidesByPage: function getSlidesByPage(page) {\n                var idx = Components.Controller.toIndex(page);\n                var options = Splide.options;\n                var max = options.focus !== false ? 1 : options.perPage;\n                return Slides.filter(function (_ref) {\n                  var index = _ref.index;\n                  return idx <= index && index < idx + max;\n                });\n              },\n\n              /**\r\n               * Insert a slide to a slider.\r\n               * Need to refresh Splide after adding a slide.\r\n               *\r\n               * @param {Node|string} slide    - A slide element to be added.\r\n               * @param {number}      index    - A slide will be added at the position.\r\n               * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n               */\n              add: function add(slide, index, callback) {\n                if (typeof slide === 'string') {\n                  slide = domify(slide);\n                }\n\n                if (slide instanceof Element) {\n                  var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n                  applyStyle(slide, {\n                    display: 'none'\n                  });\n\n                  if (ref) {\n                    before(slide, ref);\n                    this.slides.splice(index, 0, slide);\n                  } else {\n                    append(this.list, slide);\n                    this.slides.push(slide);\n                  }\n\n                  loaded(slide, function () {\n                    callback && callback(slide);\n                  });\n                }\n              },\n\n              /**\r\n               * Remove a slide from a slider.\r\n               * Need to refresh Splide after removing a slide.\r\n               *\r\n               * @param index - Slide index.\r\n               */\n              remove: function remove(index) {\n                dom_remove(this.slides.splice(index, 1)[0]);\n              },\n\n              /**\r\n               * Trigger the provided callback for each Slide object.\r\n               *\r\n               * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n               */\n              each: function each(callback) {\n                Slides.forEach(callback);\n              },\n\n              /**\r\n               * Return slides length without clones.\r\n               *\r\n               * @return {number} - Slide length.\r\n               */\n              get length() {\n                return this.slides.length;\n              },\n\n              /**\r\n               * Return \"SlideObjects\" length including clones.\r\n               *\r\n               * @return {number} - Slide length including clones.\r\n               */\n              get total() {\n                return Slides.length;\n              }\n\n            };\n            /**\r\n             * Collect elements.\r\n             */\n\n            function collect() {\n              Elements.slider = child(root, classes.slider);\n              Elements.track = find(root, \".\" + classes.track);\n              Elements.list = child(Elements.track, classes.list);\n              exist(Elements.track && Elements.list, 'Track or list was not found.');\n              Elements.slides = children(Elements.list, classes.slide);\n              var arrows = findParts(classes.arrows);\n              Elements.arrows = {\n                prev: find(arrows, \".\" + classes.prev),\n                next: find(arrows, \".\" + classes.next)\n              };\n              var autoplay = findParts(classes.autoplay);\n              Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n              Elements.play = find(autoplay, \".\" + classes.play);\n              Elements.pause = find(autoplay, \".\" + classes.pause);\n              Elements.track.id = Elements.track.id || root.id + \"-track\";\n              Elements.list.id = Elements.list.id || root.id + \"-list\";\n            }\n            /**\r\n             * Return class names for the root element.\r\n             */\n\n\n            function getClasses() {\n              var rootClass = classes.root;\n              var options = Splide.options;\n              return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n            }\n            /**\r\n             * Find parts only from children of the root or track.\r\n             *\r\n             * @return {Element} - A found element or undefined.\r\n             */\n\n\n            function findParts(className) {\n              return child(root, className) || child(Elements.slider, className);\n            }\n\n            return Elements;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/controller/index.js\n\n          /**\r\n           * The component for controlling the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var floor = Math.floor;\n          /**\r\n           * The component for controlling the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var controller = function controller(Splide, Components) {\n            /**\r\n             * Store current options.\r\n             *\r\n             * @type {Object}\r\n             */\n            var options;\n            /**\r\n             * True if the slide is LOOP mode.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isLoop;\n            /**\r\n             * Controller component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Controller = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                options = Splide.options;\n                isLoop = Splide.is(LOOP);\n                bind();\n              },\n\n              /**\r\n               * Make track run by the given control.\r\n               * - \"+{i}\" : Increment the slide index by i.\r\n               * - \"-{i}\" : Decrement the slide index by i.\r\n               * - \"{i}\"  : Go to the slide whose index is i.\r\n               * - \">\"    : Go to next page.\r\n               * - \"<\"    : Go to prev page.\r\n               * - \">{i}\" : Go to page i.\r\n               *\r\n               * @param {string|number} control  - A control pattern.\r\n               * @param {boolean}       silently - Go to the destination without event emission.\r\n               */\n              go: function go(control, silently) {\n                var destIndex = this.trim(this.parse(control));\n                Components.Track.go(destIndex, this.rewind(destIndex), silently);\n              },\n\n              /**\r\n               * Parse the given control and return the destination index for the track.\r\n               *\r\n               * @param {string} control - A control target pattern.\r\n               *\r\n               * @return {number} - A parsed target.\r\n               */\n              parse: function parse(control) {\n                var index = Splide.index;\n                var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n                var indicator = matches ? matches[1] : '';\n                var number = matches ? parseInt(matches[2]) : 0;\n\n                switch (indicator) {\n                  case '+':\n                    index += number || 1;\n                    break;\n\n                  case '-':\n                    index -= number || 1;\n                    break;\n\n                  case '>':\n                  case '<':\n                    index = parsePage(number, index, indicator === '<');\n                    break;\n\n                  default:\n                    index = parseInt(control);\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Compute index from the given page number.\r\n               *\r\n               * @param {number} page - Page number.\r\n               *\r\n               * @return {number} - A computed page number.\r\n               */\n              toIndex: function toIndex(page) {\n                if (hasFocus()) {\n                  return page;\n                }\n\n                var length = Splide.length;\n                var perPage = options.perPage;\n                var index = page * perPage;\n                index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n                if (length - perPage <= index && index < length) {\n                  index = length - perPage;\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Compute page number from the given slide index.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - A computed page number.\r\n               */\n              toPage: function toPage(index) {\n                if (hasFocus()) {\n                  return index;\n                }\n\n                var length = Splide.length;\n                var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n                if (length - perPage <= index && index < length) {\n                  return floor((length - 1) / perPage);\n                }\n\n                return floor(index / perPage);\n              },\n\n              /**\r\n               * Trim the given index according to the current mode.\r\n               * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n               *\r\n               * @param {number} index - An index being trimmed.\r\n               *\r\n               * @return {number} - A trimmed index.\r\n               */\n              trim: function trim(index) {\n                if (!isLoop) {\n                  index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Rewind the given index if it's out of range.\r\n               *\r\n               * @param {number} index - An index.\r\n               *\r\n               * @return {number} - A rewound index.\r\n               */\n              rewind: function rewind(index) {\n                var edge = this.edgeIndex;\n\n                if (isLoop) {\n                  while (index > edge) {\n                    index -= edge + 1;\n                  }\n\n                  while (index < 0) {\n                    index += edge + 1;\n                  }\n                } else {\n                  if (index > edge) {\n                    index = 0;\n                  } else if (index < 0) {\n                    index = edge;\n                  }\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Check if the direction is \"rtl\" or not.\r\n               *\r\n               * @return {boolean} - True if \"rtl\" or false if not.\r\n               */\n              isRtl: function isRtl() {\n                return options.direction === RTL;\n              },\n\n              /**\r\n               * Return the page length.\r\n               *\r\n               * @return {number} - Max page number.\r\n               */\n              get pageLength() {\n                var length = Splide.length;\n                return hasFocus() ? length : Math.ceil(length / options.perPage);\n              },\n\n              /**\r\n               * Return the edge index.\r\n               *\r\n               * @return {number} - Edge index.\r\n               */\n              get edgeIndex() {\n                var length = Splide.length;\n\n                if (!length) {\n                  return 0;\n                }\n\n                if (hasFocus() || options.isNavigation || isLoop) {\n                  return length - 1;\n                }\n\n                return length - options.perPage;\n              },\n\n              /**\r\n               * Return the index of the previous slide.\r\n               *\r\n               * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n               */\n              get prevIndex() {\n                var prev = Splide.index - 1;\n\n                if (isLoop || options.rewind) {\n                  prev = this.rewind(prev);\n                }\n\n                return prev > -1 ? prev : -1;\n              },\n\n              /**\r\n               * Return the index of the next slide.\r\n               *\r\n               * @return {number} - The index of the next slide if available. -1 otherwise.\r\n               */\n              get nextIndex() {\n                var next = Splide.index + 1;\n\n                if (isLoop || options.rewind) {\n                  next = this.rewind(next);\n                }\n\n                return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n              }\n\n            };\n            /**\r\n             * Listen to some events.\r\n             */\n\n            function bind() {\n              Splide.on('move', function (newIndex) {\n                Splide.index = newIndex;\n              }).on('updated refresh', function (newOptions) {\n                options = newOptions || options;\n                Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n              });\n            }\n            /**\r\n             * Verify if the focus option is available or not.\r\n             *\r\n             * @return {boolean} - True if a slider has the focus option.\r\n             */\n\n\n            function hasFocus() {\n              return options.focus !== false;\n            }\n            /**\r\n             * Return the next or previous page index computed by the page number and current index.\r\n             *\r\n             * @param {number}  number - Specify the page number.\r\n             * @param {number}  index  - Current index.\r\n             * @param {boolean} prev   - Prev or next.\r\n             *\r\n             * @return {number} - Slide index.\r\n             */\n\n\n            function parsePage(number, index, prev) {\n              if (number > -1) {\n                return Controller.toIndex(number);\n              }\n\n              var perMove = options.perMove;\n              var sign = prev ? -1 : 1;\n\n              if (perMove) {\n                return index + perMove * sign;\n              }\n\n              return Controller.toIndex(Controller.toPage(index) + sign);\n            }\n\n            return Controller;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/track/index.js\n\n          /**\r\n           * The component for moving list in the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var abs = Math.abs;\n          /**\r\n           * The component for moving list in the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var track = function track(Splide, Components) {\n            /**\r\n             * Hold the Layout component.\r\n             *\r\n             * @type {Object}\r\n             */\n            var Layout;\n            /**\r\n             * Hold the Layout component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements;\n            /**\r\n             * Store the list element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var list;\n            /**\r\n             * Whether the current direction is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Whether the slider type is FADE or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isFade = Splide.is(FADE);\n            /**\r\n             * Whether the slider direction is RTL or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isRTL = Splide.options.direction === RTL;\n            /**\r\n             * This will be true while transitioning from the last index to the first one.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isLoopPending = false;\n            /**\r\n             * Sign for the direction. Only RTL mode uses the positive sign.\r\n             *\r\n             * @type {number}\r\n             */\n\n            var sign = isRTL ? 1 : -1;\n            /**\r\n             * Track component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Track = {\n              /**\r\n               * Make public the sign defined locally.\r\n               *\r\n               * @type {number}\r\n               */\n              sign: sign,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Elements = Components.Elements;\n                Layout = Components.Layout;\n                list = Elements.list;\n              },\n\n              /**\r\n               * Called after the component is mounted.\r\n               * The resize event must be registered after the Layout's one is done.\r\n               */\n              mounted: function mounted() {\n                var _this = this;\n\n                if (!isFade) {\n                  this.jump(0);\n                  Splide.on('mounted resize updated', function () {\n                    _this.jump(Splide.index);\n                  });\n                }\n              },\n\n              /**\r\n               * Go to the given destination index.\r\n               * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n               *\r\n               * @param {number}  destIndex - A destination index.\r\n               *                              This can be negative or greater than slides length for reaching clones.\r\n               * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n               * @param {boolean} silently  - If true, suppress emitting events.\r\n               */\n              go: function go(destIndex, newIndex, silently) {\n                var newPosition = getTrimmedPosition(destIndex);\n                var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n                if (Splide.State.is(_MOVING) && isLoopPending) {\n                  return;\n                }\n\n                isLoopPending = destIndex !== newIndex;\n\n                if (!silently) {\n                  Splide.emit('move', newIndex, prevIndex, destIndex);\n                }\n\n                if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n                  Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n                  });\n                } else {\n                  if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n                    Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n                  } else {\n                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n                  }\n                }\n              },\n\n              /**\r\n               * Move the track to the specified index.\r\n               *\r\n               * @param {number} index - A destination index where the track jumps.\r\n               */\n              jump: function jump(index) {\n                this.translate(getTrimmedPosition(index));\n              },\n\n              /**\r\n               * Set the list position by CSS translate property.\r\n               *\r\n               * @param {number} position - A new position value.\r\n               */\n              translate: function translate(position) {\n                applyStyle(list, {\n                  transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n                });\n              },\n\n              /**\r\n               * Cancel the transition and set the list position.\r\n               * Also, loop the slider if necessary.\r\n               */\n              cancel: function cancel() {\n                if (Splide.is(LOOP)) {\n                  this.shift();\n                } else {\n                  // Ensure the current position.\n                  this.translate(this.position);\n                }\n\n                applyStyle(list, {\n                  transition: ''\n                });\n              },\n\n              /**\r\n               * Shift the slider if it exceeds borders on the edge.\r\n               */\n              shift: function shift() {\n                var position = abs(this.position);\n                var left = abs(this.toPosition(0));\n                var right = abs(this.toPosition(Splide.length));\n                var innerSize = right - left;\n\n                if (position < left) {\n                  position += innerSize;\n                } else if (position > right) {\n                  position -= innerSize;\n                }\n\n                this.translate(sign * position);\n              },\n\n              /**\r\n               * Trim redundant spaces on the left or right edge if necessary.\r\n               *\r\n               * @param {number} position - Position value to be trimmed.\r\n               *\r\n               * @return {number} - Trimmed position.\r\n               */\n              trim: function trim(position) {\n                if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n                  return position;\n                }\n\n                var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n                return between(position, edge, 0);\n              },\n\n              /**\r\n               * Calculate the closest slide index from the given position.\r\n               *\r\n               * @param {number} position - A position converted to an slide index.\r\n               *\r\n               * @return {number} - The closest slide index.\r\n               */\n              toIndex: function toIndex(position) {\n                var _this2 = this;\n\n                var index = 0;\n                var minDistance = Infinity;\n                Elements.getSlides(true).forEach(function (Slide) {\n                  var slideIndex = Slide.index;\n                  var distance = abs(_this2.toPosition(slideIndex) - position);\n\n                  if (distance < minDistance) {\n                    minDistance = distance;\n                    index = slideIndex;\n                  }\n                });\n                return index;\n              },\n\n              /**\r\n               * Return coordinates object by the given position.\r\n               *\r\n               * @param {number} position - A position value.\r\n               *\r\n               * @return {Object} - A coordinates object.\r\n               */\n              toCoord: function toCoord(position) {\n                return {\n                  x: isVertical ? 0 : position,\n                  y: isVertical ? position : 0\n                };\n              },\n\n              /**\r\n               * Calculate the track position by a slide index.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {Object} - Calculated position.\r\n               */\n              toPosition: function toPosition(index) {\n                var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n                return sign * (position + this.offset(index));\n              },\n\n              /**\r\n               * Return the current offset value, considering direction.\r\n               *\r\n               * @return {number} - Offset amount.\r\n               */\n              offset: function offset(index) {\n                var focus = Splide.options.focus;\n                var slideSize = Layout.slideSize(index);\n\n                if (focus === 'center') {\n                  return -(Layout.size - slideSize) / 2;\n                }\n\n                return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n              },\n\n              /**\r\n               * Return the current position.\r\n               * This returns the correct position even while transitioning by CSS.\r\n               *\r\n               * @return {number} - Current position.\r\n               */\n              get position() {\n                var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n                return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n              }\n\n            };\n            /**\r\n             * Called whenever slides arrive at a destination.\r\n             *\r\n             * @param {number}  destIndex - A destination index.\r\n             * @param {number}  newIndex  - A new index.\r\n             * @param {number}  prevIndex - A previous index.\r\n             * @param {boolean} silently  - If true, suppress emitting events.\r\n             */\n\n            function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n              applyStyle(list, {\n                transition: ''\n              });\n              isLoopPending = false;\n\n              if (!isFade) {\n                Track.jump(newIndex);\n              }\n\n              if (!silently) {\n                Splide.emit('moved', newIndex, prevIndex, destIndex);\n              }\n            }\n            /**\r\n             * Convert index to the trimmed position.\r\n             *\r\n             * @return {number} - Trimmed position.\r\n             */\n\n\n            function getTrimmedPosition(index) {\n              return Track.trim(Track.toPosition(index));\n            }\n\n            return Track;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/clones/index.js\n\n          /**\r\n           * The component for cloning some slides for \"loop\" mode of the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for cloning some slides for \"loop\" mode of the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var clones = function clones(Splide, Components) {\n            /**\r\n             * Store information of all clones.\r\n             *\r\n             * @type {Array}\r\n             */\n            var clones = [];\n            /**\r\n             * Store the current clone count on one side.\r\n             *\r\n             * @type {number}\r\n             */\n\n            var cloneCount = 0;\n            /**\r\n             * Keep Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Clones component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Clones = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                if (Splide.is(LOOP)) {\n                  init();\n                  Splide.on('refresh:before', function () {\n                    _this.destroy();\n                  }).on('refresh', init).on('resize', function () {\n                    if (cloneCount !== getCloneCount()) {\n                      // Destroy before refresh not to collect clones by the Elements component.\n                      _this.destroy();\n\n                      Splide.refresh();\n                    }\n                  });\n                }\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                dom_remove(clones);\n                clones = [];\n              },\n\n              /**\r\n               * Return all clones.\r\n               *\r\n               * @return {Element[]} - Cloned elements.\r\n               */\n              get clones() {\n                return clones;\n              },\n\n              /**\r\n               * Return clone length.\r\n               *\r\n               * @return {number} - A length of clones.\r\n               */\n              get length() {\n                return clones.length;\n              }\n\n            };\n            /**\r\n             * Initialization.\r\n             */\n\n            function init() {\n              Clones.destroy();\n              cloneCount = getCloneCount();\n              generateClones(cloneCount);\n            }\n            /**\r\n             * Generate and append/prepend clones.\r\n             *\r\n             * @param {number} count - The half number of clones.\r\n             */\n\n\n            function generateClones(count) {\n              var length = Elements.length,\n                  register = Elements.register;\n\n              if (length) {\n                var slides = Elements.slides;\n\n                while (slides.length < count) {\n                  slides = slides.concat(slides);\n                } // Clones after the last element.\n\n\n                slides.slice(0, count).forEach(function (elm, index) {\n                  var clone = cloneDeeply(elm);\n                  append(Elements.list, clone);\n                  clones.push(clone);\n                  register(clone, index + length, index % length);\n                }); // Clones before the first element.\n\n                slides.slice(-count).forEach(function (elm, index) {\n                  var clone = cloneDeeply(elm);\n                  before(clone, slides[0]);\n                  clones.push(clone);\n                  register(clone, index - count, (length + index - count % length) % length);\n                });\n              }\n            }\n            /**\r\n             * Return half count of clones to be generated.\r\n             * Clone count is determined by:\r\n             * - \"clones\" value in the options.\r\n             * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n             * - Max pages a flick action can move.\r\n             * - Whether the slide length is enough for perPage.\r\n             *\r\n             * @return {number} - Count for clones.\r\n             */\n\n\n            function getCloneCount() {\n              var options = Splide.options;\n\n              if (options.clones) {\n                return options.clones;\n              } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n              var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n              var dimension = options.direction === TTB ? 'Height' : 'Width';\n              var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n              if (fixedSize) {\n                // Roughly calculate the count. This needs not to be strict.\n                baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n              }\n\n              return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n            }\n            /**\r\n             * Clone deeply the given element.\r\n             *\r\n             * @param {Element} elm - An element being duplicated.\r\n             *\r\n             * @return {Node} - A cloned node(element).\r\n             */\n\n\n            function cloneDeeply(elm) {\n              var clone = elm.cloneNode(true);\n              addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n              removeAttribute(clone, 'id');\n              return clone;\n            }\n\n            return Clones;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n\n          /**\r\n           * The resolver component for horizontal layout.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The resolver component for horizontal layout.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The resolver object.\r\n           */\n\n          /* harmony default export */\n\n          var horizontal = function horizontal(Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Keep the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Keep the track element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var track;\n            /**\r\n             * Keep the latest options.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var options = Splide.options;\n            return {\n              /**\r\n               * Margin property name.\r\n               *\r\n               * @type {string}\r\n               */\n              margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n              /**\r\n               * Always 0 because the height will be determined by inner contents.\r\n               *\r\n               * @type {number}\r\n               */\n              height: 0,\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                this.resize();\n              },\n\n              /**\r\n               * Resize gap and padding.\r\n               * This must be called on init.\r\n               */\n              resize: function resize() {\n                options = Splide.options;\n                track = Elements.track;\n                this.gap = toPixel(root, options.gap);\n                var padding = options.padding;\n                var left = toPixel(root, padding.left || padding);\n                var right = toPixel(root, padding.right || padding);\n                this.padding = {\n                  left: left,\n                  right: right\n                };\n                applyStyle(track, {\n                  paddingLeft: unit(left),\n                  paddingRight: unit(right)\n                });\n              },\n\n              /**\r\n               * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n               *\r\n               * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n               *\r\n               * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n               */\n              totalWidth: function totalWidth(index) {\n                if (index === void 0) {\n                  index = Splide.length - 1;\n                }\n\n                var Slide = Elements.getSlide(index);\n                var width = 0;\n\n                if (Slide) {\n                  var slideRect = getRect(Slide.slide);\n                  var listRect = getRect(Elements.list);\n\n                  if (options.direction === RTL) {\n                    width = listRect.right - slideRect.left;\n                  } else {\n                    width = slideRect.right - listRect.left;\n                  }\n\n                  width += this.gap;\n                }\n\n                return width;\n              },\n\n              /**\r\n               * Return the slide width in px.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - The slide width.\r\n               */\n              slideWidth: function slideWidth(index) {\n                if (options.autoWidth) {\n                  var Slide = Elements.getSlide(index);\n                  return Slide ? Slide.slide.offsetWidth : 0;\n                }\n\n                var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n                return toPixel(root, width);\n              },\n\n              /**\r\n               * Return the slide height in px.\r\n               *\r\n               * @return {number} - The slide height.\r\n               */\n              slideHeight: function slideHeight() {\n                var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n                return toPixel(root, height);\n              },\n\n              /**\r\n               * Return slider width without padding.\r\n               *\r\n               * @return {number} - Current slider width.\r\n               */\n              get width() {\n                return track.clientWidth - this.padding.left - this.padding.right;\n              }\n\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n\n          /**\r\n           * The resolver component for vertical layout.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The resolver component for vertical layout.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The resolver object.\r\n           */\n\n          /* harmony default export */\n\n          var vertical = function vertical(Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Keep the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Keep the track element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var track;\n            /**\r\n             * Keep the latest options.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var options;\n            return {\n              /**\r\n               * Margin property name.\r\n               *\r\n               * @type {string}\r\n               */\n              margin: 'marginBottom',\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                this.resize();\n              },\n\n              /**\r\n               * Resize gap and padding.\r\n               * This must be called on init.\r\n               */\n              resize: function resize() {\n                options = Splide.options;\n                track = Elements.track;\n                this.gap = toPixel(root, options.gap);\n                var padding = options.padding;\n                var top = toPixel(root, padding.top || padding);\n                var bottom = toPixel(root, padding.bottom || padding);\n                this.padding = {\n                  top: top,\n                  bottom: bottom\n                };\n                applyStyle(track, {\n                  paddingTop: unit(top),\n                  paddingBottom: unit(bottom)\n                });\n              },\n\n              /**\r\n               * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n               *\r\n               * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n               *\r\n               * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n               */\n              totalHeight: function totalHeight(index) {\n                if (index === void 0) {\n                  index = Splide.length - 1;\n                }\n\n                var Slide = Elements.getSlide(index);\n\n                if (Slide) {\n                  return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n                }\n\n                return 0;\n              },\n\n              /**\r\n               * Return the slide width in px.\r\n               *\r\n               * @return {number} - The slide width.\r\n               */\n              slideWidth: function slideWidth() {\n                return toPixel(root, options.fixedWidth || this.width);\n              },\n\n              /**\r\n               * Return the slide height in px.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - The slide height.\r\n               */\n              slideHeight: function slideHeight(index) {\n                if (options.autoHeight) {\n                  var Slide = Elements.getSlide(index);\n                  return Slide ? Slide.slide.offsetHeight : 0;\n                }\n\n                var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n                return toPixel(root, height);\n              },\n\n              /**\r\n               * Return slider width without padding.\r\n               *\r\n               * @return {number} - Current slider width.\r\n               */\n              get width() {\n                return track.clientWidth;\n              },\n\n              /**\r\n               * Return slide height without padding.\r\n               *\r\n               * @return {number} - Slider height.\r\n               */\n              get height() {\n                var height = options.height || this.width * options.heightRatio;\n                exist(height, '\"height\" or \"heightRatio\" is missing.');\n                return toPixel(root, height) - this.padding.top - this.padding.bottom;\n              }\n\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/utils/time.js\n\n          /**\r\n           * A package of utility functions related with time.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Simple throttle function that controls how often the given function is executed.\r\n           *\r\n           * @param {function} func - A function to be throttled.\r\n           * @param {number}   wait - Time in millisecond for interval of execution.\r\n           *\r\n           * @return {Function} - A debounced function.\r\n           */\n\n          function throttle(func, wait) {\n            var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n            return function () {\n              if (!timeout) {\n                timeout = setTimeout(function () {\n                  func();\n                  timeout = null;\n                }, wait);\n              }\n            };\n          }\n          /**\r\n           * Custom setInterval function that provides progress rate as callback.\r\n           *\r\n           * @param {function} callback - A callback function fired every time the interval time passes.\r\n           * @param {number}   interval - Interval duration in milliseconds.\r\n           * @param {function} progress - A callback function fired whenever the progress goes.\r\n           *\r\n           * @return {Object} - An object containing play() and pause() functions.\r\n           */\n\n\n          function createInterval(callback, interval, progress) {\n            var _window = window,\n                requestAnimationFrame = _window.requestAnimationFrame;\n            var start,\n                elapse,\n                rate,\n                _pause = true;\n\n            var step = function step(timestamp) {\n              if (!_pause) {\n                if (!start) {\n                  start = timestamp;\n\n                  if (rate && rate < 1) {\n                    start -= rate * interval;\n                  }\n                }\n\n                elapse = timestamp - start;\n                rate = elapse / interval;\n\n                if (elapse >= interval) {\n                  start = 0;\n                  rate = 1;\n                  callback();\n                }\n\n                if (progress) {\n                  progress(rate);\n                }\n\n                requestAnimationFrame(step);\n              }\n            };\n\n            return {\n              pause: function pause() {\n                _pause = true;\n                start = 0;\n              },\n              play: function play(reset) {\n                start = 0;\n\n                if (reset) {\n                  rate = 0;\n                }\n\n                if (_pause) {\n                  _pause = false;\n                  requestAnimationFrame(step);\n                }\n              }\n            };\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/index.js\n\n          /**\r\n           * The component for handing slide layouts and their sizes.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for handing slide layouts and their sizes.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var layout = function layout(Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Whether the slider is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Layout component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Layout = object_assign({\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                bind();\n                init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n                this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n                this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n              },\n\n              /**\r\n               * Destroy the component.\r\n               */\n              destroy: function destroy() {\n                removeAttribute([Elements.list, Elements.track], 'style');\n              },\n\n              /**\r\n               * Return the slider height on the vertical mode or width on the horizontal mode.\r\n               *\r\n               * @return {number}\r\n               */\n              get size() {\n                return isVertical ? this.height : this.width;\n              }\n\n            }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n            /**\r\n             * Init slider styles according to options.\r\n             */\n\n            function init() {\n              Layout.init();\n              applyStyle(Splide.root, {\n                maxWidth: unit(Splide.options.width)\n              });\n              Elements.each(function (Slide) {\n                Slide.slide.style[Layout.margin] = unit(Layout.gap);\n              });\n              resize();\n            }\n            /**\r\n             * Listen the resize native event with throttle.\r\n             * Initialize when the component is mounted or options are updated.\r\n             */\n\n\n            function bind() {\n              Splide.on('resize load', throttle(function () {\n                Splide.emit('resize');\n              }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n            }\n            /**\r\n             * Resize the track and slide elements.\r\n             */\n\n\n            function resize() {\n              var options = Splide.options;\n              Layout.resize();\n              applyStyle(Elements.track, {\n                height: unit(Layout.height)\n              });\n              var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n              Elements.each(function (Slide) {\n                applyStyle(Slide.container, {\n                  height: slideHeight\n                });\n                applyStyle(Slide.slide, {\n                  width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n                  height: Slide.container ? null : slideHeight\n                });\n              });\n              Splide.emit('resized');\n            }\n\n            return Layout;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/drag/index.js\n\n          /**\r\n           * The component for supporting mouse drag and swipe.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var drag_abs = Math.abs;\n          /**\r\n           * If the absolute velocity is greater thant this value,\r\n           * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n           */\n\n          var MIN_VELOCITY = 0.1;\n          /**\r\n           * Adjust how much the track can be pulled on the first or last page.\r\n           * The larger number this is, the farther the track moves.\r\n           * This should be around 5 - 9.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var FRICTION_REDUCER = 7;\n          /**\r\n           * The component supporting mouse drag and swipe.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var drag = function drag(Splide, Components) {\n            /**\r\n             * Store the Move component.\r\n             *\r\n             * @type {Object}\r\n             */\n            var Track = Components.Track;\n            /**\r\n             * Store the Controller component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Controller = Components.Controller;\n            /**\r\n             * Coordinate of the track on starting drag.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var startCoord;\n            /**\r\n             * Analyzed info on starting drag.\r\n             *\r\n             * @type {Object|null}\r\n             */\n\n            var startInfo;\n            /**\r\n             * Analyzed info being updated while dragging/swiping.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var currentInfo;\n            /**\r\n             * Determine whether slides are being dragged or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isDragging;\n            /**\r\n             * Whether the slider direction is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Axis for the direction.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var axis = isVertical ? 'y' : 'x';\n            /**\r\n             * Drag component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Drag = {\n              /**\r\n               * Whether dragging is disabled or not.\r\n               *\r\n               * @type {boolean}\r\n               */\n              disabled: false,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                var Elements = Components.Elements;\n                var track = Elements.track;\n                Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n                  passive: false\n                }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n                  // Prevent dragging an image or anchor itself.\n                  each(Elements.list.querySelectorAll('img, a'), function (elm) {\n                    Splide.off('dragstart', elm).on('dragstart', function (e) {\n                      e.preventDefault();\n                    }, elm, {\n                      passive: false\n                    });\n                  });\n                }).on('mounted updated', function () {\n                  _this.disabled = !Splide.options.drag;\n                });\n              }\n            };\n            /**\r\n             * Called when the track starts to be dragged.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n            function start(e) {\n              if (!Drag.disabled && !isDragging) {\n                // These prams are used to evaluate whether the slider should start moving.\n                init(e);\n              }\n            }\n            /**\r\n             * Initialize parameters.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n\n            function init(e) {\n              startCoord = Track.toCoord(Track.position);\n              startInfo = analyze(e, {});\n              currentInfo = startInfo;\n            }\n            /**\r\n             * Called while the track being dragged.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n\n            function move(e) {\n              if (startInfo) {\n                currentInfo = analyze(e, startInfo);\n\n                if (isDragging) {\n                  if (e.cancelable) {\n                    e.preventDefault();\n                  }\n\n                  if (!Splide.is(FADE)) {\n                    var position = startCoord[axis] + currentInfo.offset[axis];\n                    Track.translate(resist(position));\n                  }\n                } else {\n                  if (shouldMove(currentInfo)) {\n                    Splide.emit('drag', startInfo);\n                    isDragging = true;\n                    Track.cancel(); // These params are actual drag data.\n\n                    init(e);\n                  }\n                }\n              }\n            }\n            /**\r\n             * Determine whether to start moving the track or not by drag angle.\r\n             *\r\n             * @param {Object} info - An information object.\r\n             *\r\n             * @return {boolean} - True if the track should be moved or false if not.\r\n             */\n\n\n            function shouldMove(_ref) {\n              var offset = _ref.offset;\n\n              if (Splide.State.is(_MOVING) && Splide.options.waitForTransition) {\n                return false;\n              }\n\n              var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n              if (isVertical) {\n                angle = 90 - angle;\n              }\n\n              return angle < Splide.options.dragAngleThreshold;\n            }\n            /**\r\n             * Resist dragging the track on the first/last page because there is no more.\r\n             *\r\n             * @param {number} position - A position being applied to the track.\r\n             *\r\n             * @return {Object} - Adjusted position.\r\n             */\n\n\n            function resist(position) {\n              if (Splide.is(SLIDE)) {\n                var sign = Track.sign;\n\n                var _start = sign * Track.trim(Track.toPosition(0));\n\n                var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n                position *= sign;\n\n                if (position < _start) {\n                  position = _start - FRICTION_REDUCER * Math.log(_start - position);\n                } else if (position > _end) {\n                  position = _end + FRICTION_REDUCER * Math.log(position - _end);\n                }\n\n                position *= sign;\n              }\n\n              return position;\n            }\n            /**\r\n             * Called when dragging ends.\r\n             */\n\n\n            function end() {\n              startInfo = null;\n\n              if (isDragging) {\n                Splide.emit('dragged', currentInfo);\n                go(currentInfo);\n                isDragging = false;\n              }\n            }\n            /**\r\n             * Go to the slide determined by the analyzed data.\r\n             *\r\n             * @param {Object} info - An info object.\r\n             */\n\n\n            function go(info) {\n              var velocity = info.velocity[axis];\n              var absV = drag_abs(velocity);\n\n              if (absV > 0) {\n                var options = Splide.options;\n                var index = Splide.index;\n                var sign = velocity < 0 ? -1 : 1;\n                var destIndex = index;\n\n                if (!Splide.is(FADE)) {\n                  var destination = Track.position;\n\n                  if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n                    destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n                  }\n\n                  destIndex = Track.toIndex(destination);\n                }\n                /*\r\n                 * Do not allow the track to go to a previous position if there is enough velocity.\r\n                 * Always use the adjacent index for the fade mode.\r\n                 */\n\n\n                if (destIndex === index && absV > MIN_VELOCITY) {\n                  destIndex = index + sign * Track.sign;\n                }\n\n                if (Splide.is(SLIDE)) {\n                  destIndex = between(destIndex, 0, Controller.edgeIndex);\n                }\n\n                Controller.go(destIndex, options.isNavigation);\n              }\n            }\n            /**\r\n             * Analyze the given event object and return important information for handling swipe behavior.\r\n             *\r\n             * @param {Event}   e          - Touch or Mouse event object.\r\n             * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n             *\r\n             * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n             */\n\n\n            function analyze(e, startInfo) {\n              var timeStamp = e.timeStamp,\n                  touches = e.touches;\n\n              var _ref2 = touches ? touches[0] : e,\n                  clientX = _ref2.clientX,\n                  clientY = _ref2.clientY;\n\n              var _ref3 = startInfo.to || {},\n                  _ref3$x = _ref3.x,\n                  fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n                  _ref3$y = _ref3.y,\n                  fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n              var startTime = startInfo.time || 0;\n              var offset = {\n                x: clientX - fromX,\n                y: clientY - fromY\n              };\n              var duration = timeStamp - startTime;\n              var velocity = {\n                x: offset.x / duration,\n                y: offset.y / duration\n              };\n              return {\n                to: {\n                  x: clientX,\n                  y: clientY\n                },\n                offset: offset,\n                time: timeStamp,\n                velocity: velocity\n              };\n            }\n\n            return Drag;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/click/index.js\n\n          /**\r\n           * The component for handling a click event.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for handling a click event.\r\n           * Click should be disabled during drag/swipe.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var click = function click(Splide, Components) {\n            /**\r\n             * Whether click is disabled or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            var disabled = false;\n            /**\r\n             * Click component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Click = {\n              /**\r\n               * Mount only when the drag is activated and the slide type is not \"fade\".\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.drag,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('click', onClick, Components.Elements.track, {\n                  capture: true\n                }).on('drag', function () {\n                  disabled = true;\n                }).on('dragged', function () {\n                  // Make sure the flag is released after the click event is fired.\n                  setTimeout(function () {\n                    disabled = false;\n                  });\n                });\n              }\n            };\n            /**\r\n             * Called when a track element is clicked.\r\n             *\r\n             * @param {Event} e - A click event.\r\n             */\n\n            function onClick(e) {\n              if (disabled) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n              }\n            }\n\n            return Click;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n\n          /**\r\n           * The component for playing slides automatically.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Set of pause flags.\r\n           */\n\n          var PAUSE_FLAGS = {\n            HOVER: 1,\n            FOCUS: 2,\n            MANUAL: 3\n          };\n          /**\r\n           * The component for playing slides automatically.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var autoplay = function autoplay(Splide, Components, name) {\n            /**\r\n             * Store pause flags.\r\n             *\r\n             * @type {Array}\r\n             */\n            var flags = [];\n            /**\r\n             * Store an interval object.\r\n             *\r\n             * @type {Object};\r\n             */\n\n            var interval;\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Autoplay component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Autoplay = {\n              /**\r\n               * Required only when the autoplay option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.autoplay,\n\n              /**\r\n               * Called when the component is mounted.\r\n               * Note that autoplay starts only if there are slides over perPage number.\r\n               */\n              mount: function mount() {\n                var options = Splide.options;\n\n                if (Elements.slides.length > options.perPage) {\n                  interval = createInterval(function () {\n                    Splide.go('>');\n                  }, options.interval, function (rate) {\n                    Splide.emit(name + \":playing\", rate);\n\n                    if (Elements.bar) {\n                      applyStyle(Elements.bar, {\n                        width: rate * 100 + \"%\"\n                      });\n                    }\n                  });\n                  bind();\n                  this.play();\n                }\n              },\n\n              /**\r\n               * Start autoplay.\r\n               *\r\n               * @param {number} flag - A pause flag to be removed.\r\n               */\n              play: function play(flag) {\n                if (flag === void 0) {\n                  flag = 0;\n                }\n\n                flags = flags.filter(function (f) {\n                  return f !== flag;\n                });\n\n                if (!flags.length) {\n                  Splide.emit(name + \":play\");\n                  interval.play(Splide.options.resetProgress);\n                }\n              },\n\n              /**\r\n               * Pause autoplay.\r\n               * Note that Array.includes is not supported by IE.\r\n               *\r\n               * @param {number} flag - A pause flag to be added.\r\n               */\n              pause: function pause(flag) {\n                if (flag === void 0) {\n                  flag = 0;\n                }\n\n                interval.pause();\n\n                if (flags.indexOf(flag) === -1) {\n                  flags.push(flag);\n                }\n\n                if (flags.length === 1) {\n                  Splide.emit(name + \":pause\");\n                }\n              }\n            };\n            /**\r\n             * Listen some events.\r\n             */\n\n            function bind() {\n              var options = Splide.options;\n              var sibling = Splide.sibling;\n              var elms = [Splide.root, sibling ? sibling.root : null];\n\n              if (options.pauseOnHover) {\n                switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n                switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n              }\n\n              if (options.pauseOnFocus) {\n                switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n                switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n              }\n\n              if (Elements.play) {\n                Splide.on('click', function () {\n                  // Need to be removed a focus flag at first.\n                  Autoplay.play(PAUSE_FLAGS.FOCUS);\n                  Autoplay.play(PAUSE_FLAGS.MANUAL);\n                }, Elements.play);\n              }\n\n              if (Elements.pause) {\n                switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n              }\n\n              Splide.on('move refresh', function () {\n                Autoplay.play();\n              }) // Rewind the timer.\n              .on('destroy', function () {\n                Autoplay.pause();\n              });\n            }\n            /**\r\n             * Play or pause on the given event.\r\n             *\r\n             * @param {Element[]} elms  - Elements.\r\n             * @param {string}    event - An event name or names.\r\n             * @param {number}    flag  - A pause flag defined on the top.\r\n             * @param {boolean}   play  - Determine whether to play or pause.\r\n             */\n\n\n            function switchOn(elms, event, flag, play) {\n              elms.forEach(function (elm) {\n                Splide.on(event, function () {\n                  Autoplay[play ? 'play' : 'pause'](flag);\n                }, elm);\n              });\n            }\n\n            return Autoplay;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/cover/index.js\n\n          /**\r\n           * The component for change an img element to background image of its wrapper.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for change an img element to background image of its wrapper.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var cover = function cover(Splide, Components) {\n            /**\r\n             * Hold options.\r\n             *\r\n             * @type {Object}\r\n             */\n            var options = Splide.options;\n            /**\r\n             * Cover component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Cover = {\n              /**\r\n               * Required only when \"cover\" option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: options.cover,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('lazyload:loaded', function (img) {\n                  cover(img, false);\n                });\n                Splide.on('mounted updated refresh', function () {\n                  return apply(false);\n                });\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                apply(true);\n              }\n            };\n            /**\r\n             * Apply \"cover\" to all slides.\r\n             *\r\n             * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n             */\n\n            function apply(uncover) {\n              Components.Elements.each(function (Slide) {\n                var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n                if (img && img.src) {\n                  cover(img, uncover);\n                }\n              });\n            }\n            /**\r\n             * Set background image of the parent element, using source of the given image element.\r\n             *\r\n             * @param {Element} img     - An image element.\r\n             * @param {boolean} uncover - Reset \"cover\".\r\n             */\n\n\n            function cover(img, uncover) {\n              applyStyle(img.parentElement, {\n                background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n              });\n              applyStyle(img, {\n                display: uncover ? '' : 'none'\n              });\n            }\n\n            return Cover;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/arrows/path.js\n\n          /**\r\n           * Export vector path for an arrow.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Namespace definition for SVG element.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n          /**\r\n           * The arrow vector path.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n          /**\r\n           * SVG width and height.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var SIZE = 40;\n          ; // CONCATENATED MODULE: ./src/js/components/arrows/index.js\n\n          /**\r\n           * The component for appending prev/next arrows.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for appending prev/next arrows.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var arrows = function arrows(Splide, Components, name) {\n            /**\r\n             * Previous arrow element.\r\n             *\r\n             * @type {Element|undefined}\r\n             */\n            var prev;\n            /**\r\n             * Next arrow element.\r\n             *\r\n             * @type {Element|undefined}\r\n             */\n\n            var next;\n            /**\r\n             * Store the class list.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var classes = Splide.classes;\n            /**\r\n             * Hold the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Whether arrows are created programmatically or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var created;\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Arrows component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Arrows = {\n              /**\r\n               * Required when the arrows option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.arrows,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                // Attempt to get arrows from HTML source.\n                prev = Elements.arrows.prev;\n                next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n                if ((!prev || !next) && Splide.options.arrows) {\n                  prev = createArrow(true);\n                  next = createArrow(false);\n                  created = true;\n                  appendArrows();\n                }\n\n                if (prev && next) {\n                  bind();\n                }\n\n                this.arrows = {\n                  prev: prev,\n                  next: next\n                };\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                Splide.emit(name + \":mounted\", prev, next);\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                removeAttribute([prev, next], 'disabled');\n\n                if (created) {\n                  dom_remove(prev.parentElement);\n                }\n              }\n            };\n            /**\r\n             * Listen to native and custom events.\r\n             */\n\n            function bind() {\n              Splide.on('click', function () {\n                Splide.go('<');\n              }, prev).on('click', function () {\n                Splide.go('>');\n              }, next).on('mounted move updated refresh', updateDisabled);\n            }\n            /**\r\n             * Update a disabled attribute.\r\n             */\n\n\n            function updateDisabled() {\n              var _Components$Controlle = Components.Controller,\n                  prevIndex = _Components$Controlle.prevIndex,\n                  nextIndex = _Components$Controlle.nextIndex;\n              var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n              prev.disabled = prevIndex < 0 || !isEnough;\n              next.disabled = nextIndex < 0 || !isEnough;\n              Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n            }\n            /**\r\n             * Create a wrapper element and append arrows.\r\n             */\n\n\n            function appendArrows() {\n              var wrapper = create('div', {\n                \"class\": classes.arrows\n              });\n              append(wrapper, prev);\n              append(wrapper, next);\n              var slider = Elements.slider;\n              var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n              before(wrapper, parent.firstElementChild);\n            }\n            /**\r\n             * Create an arrow element.\r\n             *\r\n             * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n             *\r\n             * @return {Element} - A created arrow element.\r\n             */\n\n\n            function createArrow(prev) {\n              var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n              return domify(arrow);\n            }\n\n            return Arrows;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/pagination/index.js\n\n          /**\r\n           * The component for handling pagination\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The event name for updating some attributes of pagination nodes.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ATTRIBUTES_UPDATE_EVENT = 'move.page';\n          /**\r\n           * The event name for recreating pagination.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var UPDATE_EVENT = 'updated.page refresh.page';\n          /**\r\n           * The component for handling pagination\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var pagination = function pagination(Splide, Components, name) {\n            /**\r\n             * Store all data for pagination.\r\n             * - list: A list element.\r\n             * - items: An array that contains objects(li, button, index, page).\r\n             *\r\n             * @type {Object}\r\n             */\n            var data = {};\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Pagination component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Pagination = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var pagination = Splide.options.pagination;\n\n                if (pagination) {\n                  data = createPagination();\n                  var slider = Elements.slider;\n                  var parent = pagination === 'slider' && slider ? slider : Splide.root;\n                  append(parent, data.list);\n                  Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n                }\n\n                Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n                  Pagination.destroy();\n\n                  if (Splide.options.pagination) {\n                    Pagination.mount();\n                    Pagination.mounted();\n                  }\n                });\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                if (Splide.options.pagination) {\n                  var index = Splide.index;\n                  Splide.emit(name + \":mounted\", data, this.getItem(index));\n                  updateAttributes(index, -1);\n                }\n              },\n\n              /**\r\n               * Destroy the pagination.\r\n               * Be aware that node.remove() is not supported by IE.\r\n               */\n              destroy: function destroy() {\n                dom_remove(data.list);\n\n                if (data.items) {\n                  data.items.forEach(function (item) {\n                    Splide.off('click', item.button);\n                  });\n                } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n                Splide.off(ATTRIBUTES_UPDATE_EVENT);\n                data = {};\n              },\n\n              /**\r\n               * Return an item by index.\r\n               *\r\n               * @param {number} index - A slide index.\r\n               *\r\n               * @return {Object|undefined} - An item object on success or undefined on failure.\r\n               */\n              getItem: function getItem(index) {\n                return data.items[Components.Controller.toPage(index)];\n              },\n\n              /**\r\n               * Return object containing pagination data.\r\n               *\r\n               * @return {Object} - Pagination data including list and items.\r\n               */\n              get data() {\n                return data;\n              }\n\n            };\n            /**\r\n             * Update attributes.\r\n             *\r\n             * @param {number} index     - Active index.\r\n             * @param {number} prevIndex - Prev index.\r\n             */\n\n            function updateAttributes(index, prevIndex) {\n              var prev = Pagination.getItem(prevIndex);\n              var curr = Pagination.getItem(index);\n              var active = STATUS_CLASSES.active;\n\n              if (prev) {\n                removeClass(prev.button, active);\n              }\n\n              if (curr) {\n                addClass(curr.button, active);\n              }\n\n              Splide.emit(name + \":updated\", data, prev, curr);\n            }\n            /**\r\n             * Create a wrapper and button elements.\r\n             *\r\n             * @return {Object} - An object contains all data.\r\n             */\n\n\n            function createPagination() {\n              var options = Splide.options;\n              var classes = Splide.classes;\n              var list = create('ul', {\n                \"class\": classes.pagination\n              });\n              var items = Elements.getSlides(false).filter(function (Slide) {\n                return options.focus !== false || Slide.index % options.perPage === 0;\n              }).map(function (Slide, page) {\n                var li = create('li', {});\n                var button = create('button', {\n                  \"class\": classes.page,\n                  type: 'button'\n                });\n                append(li, button);\n                append(list, li);\n                Splide.on('click', function () {\n                  Splide.go(\">\" + page);\n                }, button);\n                return {\n                  li: li,\n                  button: button,\n                  page: page,\n                  Slides: Elements.getSlidesByPage(page)\n                };\n              });\n              return {\n                list: list,\n                items: items\n              };\n            }\n\n            return Pagination;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n\n          /**\r\n           * The component for loading slider images lazily.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The name for a data attribute of src.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SRC_DATA_NAME = 'data-splide-lazy';\n          /**\r\n           * The name for a data attribute of srcset.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n          /**\r\n           * The component for loading slider images lazily.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var lazyload = function lazyload(Splide, Components, name) {\n            /**\r\n             * Next index for sequential loading.\r\n             *\r\n             * @type {number}\r\n             */\n            var nextIndex;\n            /**\r\n             * Store objects containing an img element and a Slide object.\r\n             *\r\n             * @type {Object[]}\r\n             */\n\n            var images;\n            /**\r\n             * Store the options.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var options = Splide.options;\n            /**\r\n             * Whether to load images sequentially or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isSequential = options.lazyLoad === 'sequential';\n            /**\r\n             * Lazyload component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Lazyload = {\n              /**\r\n               * Mount only when the lazyload option is provided.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: options.lazyLoad,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('mounted refresh', function () {\n                  init();\n                  Components.Elements.each(function (Slide) {\n                    each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n                      if (!img.src && !img.srcset) {\n                        images.push({\n                          img: img,\n                          Slide: Slide\n                        });\n                        applyStyle(img, {\n                          display: 'none'\n                        });\n                      }\n                    });\n                  });\n\n                  if (isSequential) {\n                    loadNext();\n                  }\n                });\n\n                if (!isSequential) {\n                  Splide.on(\"mounted refresh moved.\" + name, check);\n                }\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: init\n            };\n            /**\r\n             * Initialize parameters.\r\n             */\n\n            function init() {\n              images = [];\n              nextIndex = 0;\n            }\n            /**\r\n             * Check how close each image is from the active slide and\r\n             * determine whether to start loading or not, according to the distance.\r\n             *\r\n             * @param {number} index - Current index.\r\n             */\n\n\n            function check(index) {\n              index = isNaN(index) ? Splide.index : index;\n              images = images.filter(function (image) {\n                if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n                  load(image.img, image.Slide);\n                  return false;\n                }\n\n                return true;\n              }); // Unbind if all images are loaded.\n\n              if (!images[0]) {\n                Splide.off(\"moved.\" + name);\n              }\n            }\n            /**\r\n             * Start loading an image.\r\n             * Creating a clone of the image element since setting src attribute directly to it\r\n             * often occurs 'hitch', blocking some other processes of a browser.\r\n             *\r\n             * @param {Element} img   - An image element.\r\n             * @param {Object}  Slide - A Slide object.\r\n             */\n\n\n            function load(img, Slide) {\n              addClass(Slide.slide, STATUS_CLASSES.loading);\n              var spinner = create('span', {\n                \"class\": Splide.classes.spinner\n              });\n              append(img.parentElement, spinner);\n\n              img.onload = function () {\n                loaded(img, spinner, Slide, false);\n              };\n\n              img.onerror = function () {\n                loaded(img, spinner, Slide, true);\n              };\n\n              setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n              setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n            }\n            /**\r\n             * Start loading a next image in images array.\r\n             */\n\n\n            function loadNext() {\n              if (nextIndex < images.length) {\n                var image = images[nextIndex];\n                load(image.img, image.Slide);\n              }\n\n              nextIndex++;\n            }\n            /**\r\n             * Called just after the image was loaded or loading was aborted by some error.\r\n             *\r\n             * @param {Element} img     - An image element.\r\n             * @param {Element} spinner - A spinner element.\r\n             * @param {Object}  Slide   - A Slide object.\r\n             * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n             */\n\n\n            function loaded(img, spinner, Slide, error) {\n              removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n              if (!error) {\n                dom_remove(spinner);\n                applyStyle(img, {\n                  display: ''\n                });\n                Splide.emit(name + \":loaded\", img).emit('resize');\n              }\n\n              if (isSequential) {\n                loadNext();\n              }\n            }\n\n            return Lazyload;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/constants/a11y.js\n\n          /**\r\n           * Export aria attribute names.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Attribute name for aria-current.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_CURRENRT = 'aria-current';\n          /**\r\n           * Attribute name for aria-control.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_CONTROLS = 'aria-controls';\n          /**\r\n           * Attribute name for aria-control.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_LABEL = 'aria-label';\n          /**\r\n           * Attribute name for aria-labelledby.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_LABELLEDBY = 'aria-labelledby';\n          /**\r\n           * Attribute name for aria-hidden.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_HIDDEN = 'aria-hidden';\n          /**\r\n           * Attribute name for tab-index.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var TAB_INDEX = 'tabindex';\n          ; // CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n\n          /**\r\n           * The component for controlling slides via keyboard.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Map a key to a slide control.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var KEY_MAP = {\n            ltr: {\n              ArrowLeft: '<',\n              ArrowRight: '>',\n              // For IE.\n              Left: '<',\n              Right: '>'\n            },\n            rtl: {\n              ArrowLeft: '>',\n              ArrowRight: '<',\n              // For IE.\n              Left: '>',\n              Right: '<'\n            },\n            ttb: {\n              ArrowUp: '<',\n              ArrowDown: '>',\n              // For IE.\n              Up: '<',\n              Down: '>'\n            }\n          };\n          /**\r\n           * The component for controlling slides via keyboard.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var keyboard = function keyboard(Splide) {\n            /**\r\n             * Hold the target element.\r\n             *\r\n             * @type {Element|Document|undefined}\r\n             */\n            var target;\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('mounted updated', function () {\n                  var options = Splide.options;\n                  var root = Splide.root;\n                  var map = KEY_MAP[options.direction];\n                  var keyboard = options.keyboard;\n\n                  if (target) {\n                    Splide.off('keydown', target);\n                    removeAttribute(root, TAB_INDEX);\n                  }\n\n                  if (keyboard) {\n                    if (keyboard === 'focused') {\n                      target = root;\n                      setAttribute(root, TAB_INDEX, 0);\n                    } else {\n                      target = document;\n                    }\n\n                    Splide.on('keydown', function (e) {\n                      if (map[e.key]) {\n                        Splide.go(map[e.key]);\n                      }\n                    }, target);\n                  }\n                });\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/a11y/index.js\n\n          /**\r\n           * The component for enhancing accessibility.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for enhancing accessibility.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var a11y = function a11y(Splide, Components) {\n            /**\r\n             * Hold a i18n object.\r\n             *\r\n             * @type {Object}\r\n             */\n            var i18n = Splide.i18n;\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * All attributes related with A11y.\r\n             *\r\n             * @type {string[]}\r\n             */\n\n            var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n            /**\r\n             * A11y component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var A11y = {\n              /**\r\n               * Required only when the accessibility option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.accessibility,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('visible', function (Slide) {\n                  updateSlide(Slide.slide, true);\n                }).on('hidden', function (Slide) {\n                  updateSlide(Slide.slide, false);\n                }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n                  removeAttribute(Components.Clones.clones, allAttributes);\n                });\n\n                if (Splide.options.isNavigation) {\n                  Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n                    updateNavigation(Slide, true);\n                  }).on('inactive', function (Slide) {\n                    updateNavigation(Slide, false);\n                  });\n                }\n\n                initAutoplay();\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                var Arrows = Components.Arrows;\n                var arrows = Arrows ? Arrows.arrows : {};\n                removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n              }\n            };\n            /**\r\n             * Update slide attributes when it gets visible or hidden.\r\n             *\r\n             * @param {Element} slide   - A slide element.\r\n             * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n             */\n\n            function updateSlide(slide, visible) {\n              setAttribute(slide, ARIA_HIDDEN, !visible);\n\n              if (Splide.options.slideFocus) {\n                setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n              }\n            }\n            /**\r\n             * Initialize arrows if they are available.\r\n             * Append screen reader elements and add aria-controls attribute.\r\n             *\r\n             * @param {Element} prev - Previous arrow element.\r\n             * @param {Element} next - Next arrow element.\r\n             */\n\n\n            function initArrows(prev, next) {\n              var controls = Elements.track.id;\n              setAttribute(prev, ARIA_CONTROLS, controls);\n              setAttribute(next, ARIA_CONTROLS, controls);\n            }\n            /**\r\n             * Update arrow attributes.\r\n             *\r\n             * @param {Element} prev      - Previous arrow element.\r\n             * @param {Element} next      - Next arrow element.\r\n             * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n             * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n             */\n\n\n            function updateArrows(prev, next, prevIndex, nextIndex) {\n              var index = Splide.index;\n              var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n              var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n              setAttribute(prev, ARIA_LABEL, prevLabel);\n              setAttribute(next, ARIA_LABEL, nextLabel);\n            }\n            /**\r\n             * Initialize pagination if it's available.\r\n             * Append a screen reader element and add aria-controls/label attribute to each item.\r\n             *\r\n             * @param {Object} data       - Data object containing all items.\r\n             * @param {Object} activeItem - An initial active item.\r\n             */\n\n\n            function initPagination(data, activeItem) {\n              if (activeItem) {\n                setAttribute(activeItem.button, ARIA_CURRENRT, true);\n              }\n\n              data.items.forEach(function (item) {\n                var options = Splide.options;\n                var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n                var label = sprintf(text, item.page + 1);\n                var button = item.button;\n                var controls = item.Slides.map(function (Slide) {\n                  return Slide.slide.id;\n                });\n                setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n                setAttribute(button, ARIA_LABEL, label);\n              });\n            }\n            /**\r\n             * Update pagination attributes.\r\n             *\r\n             * @param {Object}  data - Data object containing all items.\r\n             * @param {Element} prev - A previous active element.\r\n             * @param {Element} curr - A current active element.\r\n             */\n\n\n            function updatePagination(data, prev, curr) {\n              if (prev) {\n                removeAttribute(prev.button, ARIA_CURRENRT);\n              }\n\n              if (curr) {\n                setAttribute(curr.button, ARIA_CURRENRT, true);\n              }\n            }\n            /**\r\n             * Initialize autoplay buttons.\r\n             */\n\n\n            function initAutoplay() {\n              ['play', 'pause'].forEach(function (name) {\n                var elm = Elements[name];\n\n                if (elm) {\n                  if (!isButton(elm)) {\n                    setAttribute(elm, 'role', 'button');\n                  }\n\n                  setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n                  setAttribute(elm, ARIA_LABEL, i18n[name]);\n                }\n              });\n            }\n            /**\r\n             * Initialize navigation slider.\r\n             * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n             *\r\n             * @param {Splide} main - A main Splide instance.\r\n             */\n\n\n            function initNavigation(main) {\n              Elements.each(function (Slide) {\n                var slide = Slide.slide;\n                var realIndex = Slide.realIndex;\n\n                if (!isButton(slide)) {\n                  setAttribute(slide, 'role', 'button');\n                }\n\n                var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n                var label = sprintf(i18n.slideX, slideIndex + 1);\n                var mainSlide = main.Components.Elements.getSlide(slideIndex);\n                setAttribute(slide, ARIA_LABEL, label);\n\n                if (mainSlide) {\n                  setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n                }\n              });\n            }\n            /**\r\n             * Update navigation attributes.\r\n             *\r\n             * @param {Object}  Slide  - A target Slide object.\r\n             * @param {boolean} active - True if the slide is active or false if inactive.\r\n             */\n\n\n            function updateNavigation(_ref, active) {\n              var slide = _ref.slide;\n\n              if (active) {\n                setAttribute(slide, ARIA_CURRENRT, true);\n              } else {\n                removeAttribute(slide, ARIA_CURRENRT);\n              }\n            }\n            /**\r\n             * Check if the given element is button or not.\r\n             *\r\n             * @param {Element} elm - An element to be checked.\r\n             *\r\n             * @return {boolean} - True if the given element is button.\r\n             */\n\n\n            function isButton(elm) {\n              return elm.tagName === 'BUTTON';\n            }\n\n            return A11y;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/sync/index.js\n\n          /**\r\n           * The component for synchronizing a slider with another.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The event name for sync.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SYNC_EVENT = 'move.sync';\n          /**\r\n           * The event names for click navigation.\r\n           * @type {string}\r\n           */\n\n          var CLICK_EVENTS = 'mouseup touchend';\n          /**\r\n           * The keys for triggering the navigation button.\r\n           *\r\n           * @type {String[]}\r\n           */\n\n          var TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n          /**\r\n           * The component for synchronizing a slider with another.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var sync = function sync(Splide) {\n            /**\r\n             * Keep the sibling Splide instance.\r\n             *\r\n             * @type {Splide}\r\n             */\n            var sibling = Splide.sibling;\n            /**\r\n             * Whether the sibling slider is navigation or not.\r\n             *\r\n             * @type {Splide|boolean}\r\n             */\n\n            var isNavigation = sibling && sibling.options.isNavigation;\n            /**\r\n             * Layout component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Sync = {\n              /**\r\n               * Required only when the sub slider is available.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: !!sibling,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                syncMain();\n                syncSibling();\n\n                if (isNavigation) {\n                  bind();\n                  Splide.on('refresh', function () {\n                    setTimeout(function () {\n                      bind();\n                      sibling.emit('navigation:updated', Splide);\n                    });\n                  });\n                }\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                if (isNavigation) {\n                  sibling.emit('navigation:mounted', Splide);\n                }\n              }\n            };\n            /**\r\n             * Listen the primary slider event to move secondary one.\r\n             * Must unbind a handler at first to avoid infinite loop.\r\n             */\n\n            function syncMain() {\n              Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n                sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n                syncSibling();\n              });\n            }\n            /**\r\n             * Listen the secondary slider event to move primary one.\r\n             * Must unbind a handler at first to avoid infinite loop.\r\n             */\n\n\n            function syncSibling() {\n              sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n                Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n                syncMain();\n              });\n            }\n            /**\r\n             * Listen some events on each slide.\r\n             */\n\n\n            function bind() {\n              sibling.Components.Elements.each(function (_ref) {\n                var slide = _ref.slide,\n                    index = _ref.index;\n                /*\r\n                 * Listen mouseup and touchend events to handle click.\r\n                 */\n\n                Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n                  // Ignore a middle or right click.\n                  if (!e.button || e.button === 0) {\n                    moveSibling(index);\n                  }\n                }, slide);\n                /*\r\n                 * Subscribe keyup to handle Enter and Space key.\r\n                 * Note that Array.includes is not supported by IE.\r\n                 */\n\n                Splide.off('keyup', slide).on('keyup', function (e) {\n                  if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n                    e.preventDefault();\n                    moveSibling(index);\n                  }\n                }, slide, {\n                  passive: false\n                });\n              });\n            }\n            /**\r\n             * Move the sibling to the given index.\r\n             * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n             *\r\n             * @param {number} index - Target index.\r\n             */\n\n\n            function moveSibling(index) {\n              if (Splide.State.is(_IDLE)) {\n                sibling.go(index);\n              }\n            }\n\n            return Sync;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n\n          /**\r\n           * The component for updating options according to a current window width.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Interval time for throttle.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var THROTTLE = 50;\n          /**\r\n           * The component for updating options according to a current window width.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          var breakpoints = function breakpoints(Splide) {\n            /**\r\n             * Store breakpoints.\r\n             *\r\n             * @type {Object|boolean}\r\n             */\n            var breakpoints = Splide.options.breakpoints;\n            /**\r\n             * The check function whose frequency of call is reduced.\r\n             *\r\n             * @type {Function}\r\n             */\n\n            var throttledCheck = throttle(check, THROTTLE);\n            /**\r\n             * Keep initial options.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var initialOptions;\n            /**\r\n             * An array containing objects of point and MediaQueryList.\r\n             *\r\n             * @type {Object[]}\r\n             */\n\n            var map = [];\n            /**\r\n             * Hold the previous breakpoint.\r\n             *\r\n             * @type {number|undefined}\r\n             */\n\n            var prevPoint;\n            /**\r\n             * Breakpoints component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Breakpoints = {\n              /**\r\n               * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: breakpoints && matchMedia,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                map = Object.keys(breakpoints).sort(function (n, m) {\n                  return +n - +m;\n                }).map(function (point) {\n                  return {\n                    point: point,\n                    mql: matchMedia(\"(max-width:\" + point + \"px)\")\n                  };\n                });\n                /*\r\n                 * To keep monitoring resize event after destruction without \"completely\",\r\n                 * use native addEventListener instead of Splide.on.\r\n                 */\n\n                this.destroy(true);\n                addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n                initialOptions = Splide.options;\n                check();\n              },\n\n              /**\r\n               * Destroy.\r\n               *\r\n               * @param {boolean} completely - Whether to destroy Splide completely.\r\n               */\n              destroy: function destroy(completely) {\n                if (completely) {\n                  removeEventListener('resize', throttledCheck);\n                }\n              }\n            };\n            /**\r\n             * Check the breakpoint.\r\n             */\n\n            function check() {\n              var point = getPoint();\n\n              if (point !== prevPoint) {\n                prevPoint = point;\n                var State = Splide.State;\n                var options = breakpoints[point] || initialOptions;\n                var destroy = options.destroy;\n\n                if (destroy) {\n                  Splide.options = initialOptions;\n                  Splide.destroy(destroy === 'completely');\n                } else {\n                  if (State.is(_DESTROYED)) {\n                    Splide.mount();\n                  }\n\n                  Splide.options = options;\n                }\n              }\n            }\n            /**\r\n             * Return the breakpoint matching current window width.\r\n             * Note that Array.prototype.find is not supported by IE.\r\n             *\r\n             * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n             */\n\n\n            function getPoint() {\n              var item = map.filter(function (item) {\n                return item.mql.matches;\n              })[0];\n              return item ? item.point : -1;\n            }\n\n            return Breakpoints;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/index.js\n\n          /**\r\n           * Export components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var COMPLETE = {\n            Options: options,\n            Breakpoints: breakpoints,\n            Controller: controller,\n            Elements: components_elements,\n            Track: track,\n            Clones: clones,\n            Layout: layout,\n            Drag: drag,\n            Click: click,\n            Autoplay: autoplay,\n            Cover: cover,\n            Arrows: arrows,\n            Pagination: pagination,\n            LazyLoad: lazyload,\n            Keyboard: keyboard,\n            Sync: sync,\n            A11y: a11y\n          };\n          var LIGHT = {\n            Options: options,\n            Controller: controller,\n            Elements: components_elements,\n            Track: track,\n            Clones: clones,\n            Layout: layout,\n            Drag: drag,\n            Click: click,\n            Arrows: arrows,\n            Pagination: pagination,\n            A11y: a11y\n          };\n          ; // CONCATENATED MODULE: ./build/module/module.js\n\n          function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n          }\n          /**\r\n           * Export Splide class for import.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Export Splide class for import from other projects.\r\n           */\n\n\n          var module_Splide = /*#__PURE__*/function (_Core) {\n            _inheritsLoose(Splide, _Core);\n\n            function Splide(root, options) {\n              return _Core.call(this, root, options, COMPLETE) || this;\n            }\n\n            return Splide;\n          }(Splide);\n          /***/\n\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/define property getters */\n\n      /******/\n\n\n      (function () {\n        /******/\n        // define getter functions for harmony exports\n\n        /******/\n        __webpack_require__.d = function (exports, definition) {\n          /******/\n          for (var key in definition) {\n            /******/\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n              /******/\n              Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n              });\n              /******/\n            }\n            /******/\n\n          }\n          /******/\n\n        };\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/hasOwnProperty shorthand */\n\n      /******/\n\n\n      (function () {\n        /******/\n        __webpack_require__.o = function (obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        };\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/make namespace object */\n\n      /******/\n\n\n      (function () {\n        /******/\n        // define __esModule on exports\n\n        /******/\n        __webpack_require__.r = function (exports) {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n\n      return __webpack_require__(311);\n      /******/\n    }()\n  );\n});","map":{"version":3,"sources":["C:/Users/rodet/Documents/GitHub/but-project/node_modules/@splidejs/splide/dist/js/splide.esm.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","__webpack_modules__","__unused_webpack_module","__webpack_exports__","__webpack_require__","r","d","module_Splide","states_namespaceObject","CREATED","DESTROYED","IDLE","MOUNTED","MOVING","core_event","data","Event","on","events","handler","elm","options","split","forEach","event","addEventListener","push","off","filter","item","unsubscribe","emit","_len","arguments","length","args","Array","_key","apply","destroy","removeEventListener","state","initialState","curr","set","is","_extends","Object","assign","target","i","source","key","prototype","hasOwnProperty","call","keys","each","obj","callback","some","index","values","map","isObject","subject","merge","_ref","from","to","value","object_assign","defineProperty","getOwnPropertyDescriptor","toArray","isArray","between","m1","m2","Math","min","max","sprintf","format","replacements","replace","unit","type","parseFloat","pad","number","toPixel","div","create","applyStyle","position","width","append","clientWidth","dom_remove","find","selector","querySelector","child","parent","tagOrClassName","children","hasClass","tagName","tag","attrs","document","createElement","setAttribute","domify","html","innerHTML","firstChild","elms","parentElement","removeChild","appendChild","before","ref","insertBefore","styles","prop","style","addOrRemoveClasses","classes","remove","name","classList","addClass","removeClass","className","contains","getAttribute","removeAttribute","names","getRect","getBoundingClientRect","loaded","images","querySelectorAll","count","img","onload","onerror","SLIDE","LOOP","FADE","slide","Splide","Components","list","endCallback","mount","Elements","e","start","destIndex","newIndex","prevIndex","coord","done","edgeIndex","Controller","speed","rewindSpeed","transition","easing","transform","x","y","fade","Fade","track","height","clientHeight","setTimeout","slides","compose","Transition","components","Component","toLowerCase","MESSAGE_PREFIX","error","message","console","exist","Error","ROOT","ELEMENT_CLASSES","slider","container","arrows","arrow","prev","next","pagination","page","clone","progress","bar","autoplay","play","pause","spinner","sr","STATUS_CLASSES","active","visible","loading","I18N","first","last","slideX","pageX","DEFAULTS","rewind","waitForTransition","fixedWidth","fixedHeight","heightRatio","autoWidth","autoHeight","perPage","perMove","clones","focus","gap","padding","arrowPath","interval","pauseOnHover","pauseOnFocus","resetProgress","lazyLoad","preloadPages","keyboard","drag","dragAngleThreshold","swipeDistanceThreshold","flickVelocityThreshold","flickPower","flickMaxPages","direction","cover","accessibility","slideFocus","isNavigation","trimSpace","updateOnMove","throttle","breakpoints","i18n","_defineProperties","props","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","Element","State","STATES","_o","_i","_c","_e","_t","_proto","Extensions","_this","component","required","undefined","mounted","visibility","sync","splide","sibling","_this$Event","concat","go","control","wait","add","refresh","bind","completely","_this2","reverse","get","parseInt","created","JSON","parse","LTR","RTL","TTB","STYLE_RESTORE_EVENTS","elements_slide","realIndex","STATUS_UPDATE_EVENTS","Slide","isClone","id","update","restoreStyles","_update","display","isActive","isVisible","ceil","trackRect","slideRect","top","bottom","left","right","isWithin","within","diff","abs","forVisibility","UID_NAME","components_elements","Slides","window","uid","init","getClasses","collect","register","SlideObject","getSlide","getSlides","includeClones","getSlidesByPage","idx","toIndex","splice","total","findParts","rootClass","floor","controller","isLoop","silently","trim","Track","matches","String","match","indicator","parsePage","hasFocus","pageLength","toPage","edge","isRtl","nextIndex","newOptions","sign","Layout","isVertical","isFade","isRTL","isLoopPending","jump","newPosition","getTrimmedPosition","toCoord","onTransitionEnd","translate","cancel","shift","toPosition","innerSize","totalSize","size","minDistance","Infinity","slideIndex","distance","slideSize","offset","cloneCount","Clones","getCloneCount","generateClones","slice","cloneDeeply","baseCount","dimension","fixedSize","cloneNode","horizontal","margin","resize","paddingLeft","paddingRight","totalWidth","listRect","slideWidth","offsetWidth","slideHeight","vertical","paddingTop","paddingBottom","totalHeight","offsetHeight","func","timeout","createInterval","_window","requestAnimationFrame","elapse","rate","_pause","step","timestamp","reset","layout","maxWidth","drag_abs","MIN_VELOCITY","FRICTION_REDUCER","startCoord","startInfo","currentInfo","isDragging","axis","Drag","disabled","move","passive","end","preventDefault","analyze","cancelable","resist","shouldMove","angle","atan","PI","_start","_end","log","info","velocity","absV","destination","timeStamp","touches","_ref2","clientX","clientY","_ref3","_ref3$x","fromX","_ref3$y","fromY","startTime","time","duration","click","Click","onClick","capture","stopPropagation","stopImmediatePropagation","PAUSE_FLAGS","HOVER","FOCUS","MANUAL","flags","Autoplay","flag","f","indexOf","switchOn","Cover","uncover","src","background","XML_NAME_SPACE","PATH","SIZE","Arrows","createArrow","appendArrows","updateDisabled","_Components$Controlle","isEnough","wrapper","firstElementChild","ATTRIBUTES_UPDATE_EVENT","UPDATE_EVENT","Pagination","createPagination","updateAttributes","getItem","items","button","li","SRC_DATA_NAME","SRCSET_DATA_NAME","lazyload","isSequential","Lazyload","srcset","loadNext","check","isNaN","image","load","ARIA_CURRENRT","ARIA_CONTROLS","ARIA_LABEL","ARIA_LABELLEDBY","ARIA_HIDDEN","TAB_INDEX","KEY_MAP","ltr","ArrowLeft","ArrowRight","Left","Right","rtl","ttb","ArrowUp","ArrowDown","Up","Down","a11y","allAttributes","A11y","updateSlide","initArrows","updateArrows","initPagination","updatePagination","initNavigation","updateNavigation","initAutoplay","controls","prevLabel","nextLabel","activeItem","text","label","join","isButton","main","mainSlide","SYNC_EVENT","CLICK_EVENTS","TRIGGER_KEYS","Sync","syncMain","syncSibling","moveSibling","THROTTLE","throttledCheck","initialOptions","prevPoint","Breakpoints","matchMedia","sort","n","m","point","mql","getPoint","COMPLETE","Options","LazyLoad","Keyboard","LIGHT","_inheritsLoose","subClass","superClass","constructor","__proto__","_Core","__webpack_module_cache__","moduleId","definition","o","Symbol","toStringTag"],"mappings":"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;AACA;AACA;AACA;AACA;AACEC,YAAAA,kBAAkB,EAAE,EAvQP;;AAyQb;AACF;AACA;AACA;AACA;AACA;AACEC,YAAAA,sBAAsB,EAAE,GA/QX;;AAiRb;AACF;AACA;AACA;AACA;AACA;AACEC,YAAAA,sBAAsB,EAAE,EAvRX;;AAyRb;AACF;AACA;AACA;AACA;AACA;AACEC,YAAAA,UAAU,EAAE,GA/RC;;AAiSb;AACF;AACA;AACA;AACA;AACEC,YAAAA,aAAa,EAAE,CAtSF;;AAwSb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,YAAAA,SAAS,EAAE,KAhTE;;AAkTb;AACF;AACA;AACA;AACA;AACA;AACA;AACEC,YAAAA,KAAK,EAAE,KAzTM;;AA2Tb;AACF;AACA;AACA;AACA;AACEC,YAAAA,aAAa,EAAE,IAhUF;;AAkUb;AACF;AACA;AACA;AACA;AACEC,YAAAA,UAAU,EAAE,IAvUC;;AAyUb;AACF;AACA;AACA;AACA;AACA;AACEC,YAAAA,YAAY,EAAE,KA/UD;;AAiVb;AACF;AACA;AACA;AACA;AACEC,YAAAA,SAAS,EAAE,IAtVE;;AAwVb;AACF;AACA;AACA;AACA;AACA;AACEC,YAAAA,YAAY,EAAE,KA9VD;;AAgWb;AACF;AACA;AACA;AACA;AACEC,YAAAA,QAAQ,EAAE,GArWG;;AAuWb;AACF;AACA;AACA;AACA;AACExN,YAAAA,OAAO,EAAE,KA5WI;;AA8Wb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEyN,YAAAA,WAAW,EAAE,KA/XA;;AAiYb;AACF;AACA;AACA;AACA;AACA;AACA;AACE/H,YAAAA,OAAO,EAAEiE,eAxYI;;AA0Yb;AACF;AACA;AACA;AACA;AACA;AACA;AACE+D,YAAAA,IAAI,EAAE1C;AAjZO,WAAf;AAmZA,WAr1C8E,CAq1C7E;;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,cAAI9M,QAAO,GAAG,CAAd;AACA;AACA;AACA;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","sourcesContent":["/*!\r\n * Splide.js\r\n * Version  : 2.4.20\r\n * License  : MIT\r\n * Copyright: 2020 Naotoshi Fujita\r\n */\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\tmodule.exports = factory();\r\n\telse if(typeof define === 'function' && define.amd)\r\n\t\tdefine([], factory);\r\n\telse if(typeof exports === 'object')\r\n\t\texports[\"Splide\"] = factory();\r\n\telse\r\n\t\troot[\"Splide\"] = factory();\r\n})(self, function() {\r\nreturn /******/ (() => { // webpackBootstrap\r\n/******/ \t\"use strict\";\r\n/******/ \tvar __webpack_modules__ = ({\r\n\r\n/***/ 311:\r\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\r\n\r\n// ESM COMPAT FLAG\r\n__webpack_require__.r(__webpack_exports__);\r\n\r\n// EXPORTS\r\n__webpack_require__.d(__webpack_exports__, {\r\n  \"default\": () => /* binding */ module_Splide\r\n});\r\n\r\n// NAMESPACE OBJECT: ./src/js/constants/states.js\r\nvar states_namespaceObject = {};\r\n__webpack_require__.r(states_namespaceObject);\r\n__webpack_require__.d(states_namespaceObject, {\r\n  \"CREATED\": () => CREATED,\r\n  \"DESTROYED\": () => DESTROYED,\r\n  \"IDLE\": () => IDLE,\r\n  \"MOUNTED\": () => MOUNTED,\r\n  \"MOVING\": () => MOVING\r\n});\r\n\r\n;// CONCATENATED MODULE: ./src/js/core/event.js\r\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\r\n/* harmony default export */ const core_event = (function () {\r\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\r\n  var data = [];\r\n  var Event = {\r\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\r\n    on: function on(events, handler, elm, options) {\r\n      if (elm === void 0) {\r\n        elm = null;\r\n      }\r\n\r\n      if (options === void 0) {\r\n        options = {};\r\n      }\r\n\r\n      events.split(' ').forEach(function (event) {\r\n        if (elm) {\r\n          elm.addEventListener(event, handler, options);\r\n        }\r\n\r\n        data.push({\r\n          event: event,\r\n          handler: handler,\r\n          elm: elm,\r\n          options: options\r\n        });\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\r\n    off: function off(events, elm) {\r\n      if (elm === void 0) {\r\n        elm = null;\r\n      }\r\n\r\n      events.split(' ').forEach(function (event) {\r\n        data = data.filter(function (item) {\r\n          if (item && item.event === event && item.elm === elm) {\r\n            unsubscribe(item);\r\n            return false;\r\n          }\r\n\r\n          return true;\r\n        });\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\r\n    emit: function emit(event) {\r\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n        args[_key - 1] = arguments[_key];\r\n      }\r\n\r\n      data.forEach(function (item) {\r\n        if (!item.elm && item.event.split('.')[0] === event) {\r\n          item.handler.apply(item, args);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Clear event data.\r\n     */\r\n    destroy: function destroy() {\r\n      data.forEach(unsubscribe);\r\n      data = [];\r\n    }\r\n  };\r\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\r\n\r\n  function unsubscribe(item) {\r\n    if (item.elm) {\r\n      item.elm.removeEventListener(item.event, item.handler, item.options);\r\n    }\r\n  }\r\n\r\n  return Event;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/core/state.js\r\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\r\n/* harmony default export */ const state = (function (initialState) {\r\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\r\n  var curr = initialState;\r\n  return {\r\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\r\n    set: function set(state) {\r\n      curr = state;\r\n    },\r\n\r\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\r\n    is: function is(state) {\r\n      return state === curr;\r\n    }\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/utils/object.js\r\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\r\n\r\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\nvar keys = Object.keys;\r\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\r\n\r\nfunction each(obj, callback) {\r\n  keys(obj).some(function (key, index) {\r\n    return callback(obj[key], key, index);\r\n  });\r\n}\r\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\r\n\r\nfunction values(obj) {\r\n  return keys(obj).map(function (key) {\r\n    return obj[key];\r\n  });\r\n}\r\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\r\n\r\nfunction isObject(subject) {\r\n  return typeof subject === 'object';\r\n}\r\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\r\n\r\nfunction merge(_ref, from) {\r\n  var to = _extends({}, _ref);\r\n\r\n  each(from, function (value, key) {\r\n    if (isObject(value)) {\r\n      if (!isObject(to[key])) {\r\n        to[key] = {};\r\n      }\r\n\r\n      to[key] = merge(to[key], value);\r\n    } else {\r\n      to[key] = value;\r\n    }\r\n  });\r\n  return to;\r\n}\r\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\r\n\r\nfunction object_assign(to, from) {\r\n  keys(from).forEach(function (key) {\r\n    if (!to[key]) {\r\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\r\n    }\r\n  });\r\n  return to;\r\n}\r\n;// CONCATENATED MODULE: ./src/js/utils/utils.js\r\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\r\n\r\nfunction toArray(value) {\r\n  return Array.isArray(value) ? value : [value];\r\n}\r\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\r\n\r\nfunction between(value, m1, m2) {\r\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\r\n}\r\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\r\n\r\nfunction sprintf(format, replacements) {\r\n  var i = 0;\r\n  return format.replace(/%s/g, function () {\r\n    return toArray(replacements)[i++];\r\n  });\r\n}\r\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\r\n\r\nfunction unit(value) {\r\n  var type = typeof value;\r\n\r\n  if (type === 'number' && value > 0) {\r\n    return parseFloat(value) + 'px';\r\n  }\r\n\r\n  return type === 'string' ? value : '';\r\n}\r\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\r\n\r\nfunction pad(number) {\r\n  return number < 10 ? '0' + number : number;\r\n}\r\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\r\n\r\nfunction toPixel(root, value) {\r\n  if (typeof value === 'string') {\r\n    var div = create('div', {});\r\n    applyStyle(div, {\r\n      position: 'absolute',\r\n      width: value\r\n    });\r\n    append(root, div);\r\n    value = div.clientWidth;\r\n    dom_remove(div);\r\n  }\r\n\r\n  return +value || 0;\r\n}\r\n;// CONCATENATED MODULE: ./src/js/utils/dom.js\r\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\r\n\r\nfunction find(elm, selector) {\r\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\r\n}\r\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\r\n\r\nfunction child(parent, tagOrClassName) {\r\n  return children(parent, tagOrClassName)[0];\r\n}\r\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\r\n\r\nfunction children(parent, tagOrClassName) {\r\n  if (parent) {\r\n    return values(parent.children).filter(function (child) {\r\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\r\n    });\r\n  }\r\n\r\n  return [];\r\n}\r\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\r\n\r\nfunction create(tag, attrs) {\r\n  var elm = document.createElement(tag);\r\n  each(attrs, function (value, key) {\r\n    return setAttribute(elm, key, value);\r\n  });\r\n  return elm;\r\n}\r\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\r\n\r\nfunction domify(html) {\r\n  var div = create('div', {});\r\n  div.innerHTML = html;\r\n  return div.firstChild;\r\n}\r\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\r\n\r\nfunction dom_remove(elms) {\r\n  toArray(elms).forEach(function (elm) {\r\n    if (elm) {\r\n      var parent = elm.parentElement;\r\n      parent && parent.removeChild(elm);\r\n    }\r\n  });\r\n}\r\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\r\n\r\nfunction append(parent, child) {\r\n  if (parent) {\r\n    parent.appendChild(child);\r\n  }\r\n}\r\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\r\n\r\nfunction before(elm, ref) {\r\n  if (elm && ref) {\r\n    var parent = ref.parentElement;\r\n    parent && parent.insertBefore(elm, ref);\r\n  }\r\n}\r\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\r\n\r\nfunction applyStyle(elm, styles) {\r\n  if (elm) {\r\n    each(styles, function (value, prop) {\r\n      if (value !== null) {\r\n        elm.style[prop] = value;\r\n      }\r\n    });\r\n  }\r\n}\r\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\r\n\r\nfunction addOrRemoveClasses(elm, classes, remove) {\r\n  if (elm) {\r\n    toArray(classes).forEach(function (name) {\r\n      if (name) {\r\n        elm.classList[remove ? 'remove' : 'add'](name);\r\n      }\r\n    });\r\n  }\r\n}\r\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\r\n\r\n\r\nfunction addClass(elm, classes) {\r\n  addOrRemoveClasses(elm, classes, false);\r\n}\r\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\r\n\r\nfunction removeClass(elm, classes) {\r\n  addOrRemoveClasses(elm, classes, true);\r\n}\r\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\r\n\r\nfunction hasClass(elm, className) {\r\n  return !!elm && elm.classList.contains(className);\r\n}\r\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\r\n\r\nfunction setAttribute(elm, name, value) {\r\n  if (elm) {\r\n    elm.setAttribute(name, value);\r\n  }\r\n}\r\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\r\n\r\nfunction getAttribute(elm, name) {\r\n  return elm ? elm.getAttribute(name) : '';\r\n}\r\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\r\n\r\nfunction removeAttribute(elms, names) {\r\n  toArray(names).forEach(function (name) {\r\n    toArray(elms).forEach(function (elm) {\r\n      return elm && elm.removeAttribute(name);\r\n    });\r\n  });\r\n}\r\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\r\n\r\nfunction getRect(elm) {\r\n  return elm.getBoundingClientRect();\r\n}\r\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\r\n\r\nfunction loaded(elm, callback) {\r\n  var images = elm.querySelectorAll('img');\r\n  var length = images.length;\r\n\r\n  if (length) {\r\n    var count = 0;\r\n    each(images, function (img) {\r\n      img.onload = img.onerror = function () {\r\n        if (++count === length) {\r\n          callback();\r\n        }\r\n      };\r\n    });\r\n  } else {\r\n    // Trigger the callback immediately if there is no image.\r\n    callback();\r\n  }\r\n}\r\n;// CONCATENATED MODULE: ./src/js/constants/types.js\r\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\r\nvar SLIDE = 'slide';\r\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar LOOP = 'loop';\r\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar FADE = 'fade';\r\n;// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\r\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const slide = (function (Splide, Components) {\r\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n  var list;\r\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\r\n\r\n  var endCallback;\r\n  return {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      list = Components.Elements.list;\r\n      Splide.on('transitionend', function (e) {\r\n        if (e.target === list && endCallback) {\r\n          endCallback();\r\n        }\r\n      }, list);\r\n    },\r\n\r\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\r\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\r\n      var options = Splide.options;\r\n      var edgeIndex = Components.Controller.edgeIndex;\r\n      var speed = options.speed;\r\n      endCallback = done;\r\n\r\n      if (Splide.is(SLIDE)) {\r\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\r\n          speed = options.rewindSpeed || speed;\r\n        }\r\n      }\r\n\r\n      applyStyle(list, {\r\n        transition: \"transform \" + speed + \"ms \" + options.easing,\r\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\r\n      });\r\n    }\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\r\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const fade = (function (Splide, Components) {\r\n  var Fade = {\r\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\r\n    mount: function mount() {\r\n      apply(Splide.index);\r\n    },\r\n\r\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\r\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\r\n      var track = Components.Elements.track;\r\n      applyStyle(track, {\r\n        height: unit(track.clientHeight)\r\n      });\r\n      apply(newIndex);\r\n      setTimeout(function () {\r\n        done();\r\n        applyStyle(track, {\r\n          height: ''\r\n        });\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\r\n\r\n  function apply(index) {\r\n    var options = Splide.options;\r\n    applyStyle(Components.Elements.slides[index], {\r\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\r\n    });\r\n  }\r\n\r\n  return Fade;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/transitions/index.js\r\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n;// CONCATENATED MODULE: ./src/js/core/composer.js\r\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\r\n\r\nfunction compose(Splide, Components, Transition) {\r\n  var components = {};\r\n  each(Components, function (Component, name) {\r\n    components[name] = Component(Splide, components, name.toLowerCase());\r\n  });\r\n\r\n  if (!Transition) {\r\n    Transition = Splide.is(FADE) ? fade : slide;\r\n  }\r\n\r\n  components.Transition = Transition(Splide, components);\r\n  return components;\r\n}\r\n;// CONCATENATED MODULE: ./src/js/utils/error.js\r\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\r\nvar MESSAGE_PREFIX = '[SPLIDE]';\r\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\r\n\r\nfunction error(message) {\r\n  console.error(MESSAGE_PREFIX + \" \" + message);\r\n}\r\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\r\n\r\nfunction exist(subject, message) {\r\n  if (!subject) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n;// CONCATENATED MODULE: ./src/js/constants/classes.js\r\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\r\nvar ROOT = 'splide';\r\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\r\n\r\nvar ELEMENT_CLASSES = {\r\n  root: ROOT,\r\n  slider: ROOT + \"__slider\",\r\n  track: ROOT + \"__track\",\r\n  list: ROOT + \"__list\",\r\n  slide: ROOT + \"__slide\",\r\n  container: ROOT + \"__slide__container\",\r\n  arrows: ROOT + \"__arrows\",\r\n  arrow: ROOT + \"__arrow\",\r\n  prev: ROOT + \"__arrow--prev\",\r\n  next: ROOT + \"__arrow--next\",\r\n  pagination: ROOT + \"__pagination\",\r\n  page: ROOT + \"__pagination__page\",\r\n  clone: ROOT + \"__slide--clone\",\r\n  progress: ROOT + \"__progress\",\r\n  bar: ROOT + \"__progress__bar\",\r\n  autoplay: ROOT + \"__autoplay\",\r\n  play: ROOT + \"__play\",\r\n  pause: ROOT + \"__pause\",\r\n  spinner: ROOT + \"__spinner\",\r\n  sr: ROOT + \"__sr\"\r\n};\r\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\r\n\r\nvar STATUS_CLASSES = {\r\n  active: 'is-active',\r\n  visible: 'is-visible',\r\n  loading: 'is-loading'\r\n};\r\n;// CONCATENATED MODULE: ./src/js/constants/i18n.js\r\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\r\nvar I18N = {\r\n  prev: 'Previous slide',\r\n  next: 'Next slide',\r\n  first: 'Go to first slide',\r\n  last: 'Go to last slide',\r\n  slideX: 'Go to slide %s',\r\n  pageX: 'Go to page %s',\r\n  play: 'Start autoplay',\r\n  pause: 'Pause autoplay'\r\n};\r\n;// CONCATENATED MODULE: ./src/js/constants/defaults.js\r\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\nvar DEFAULTS = {\r\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\r\n  type: 'slide',\r\n\r\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  rewind: false,\r\n\r\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\r\n  speed: 400,\r\n\r\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\r\n  rewindSpeed: 0,\r\n\r\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  waitForTransition: true,\r\n\r\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\r\n  width: 0,\r\n\r\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\r\n  height: 0,\r\n\r\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\r\n  fixedWidth: 0,\r\n\r\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\r\n  fixedHeight: 0,\r\n\r\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\r\n  heightRatio: 0,\r\n\r\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  autoWidth: false,\r\n\r\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  autoHeight: false,\r\n\r\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\r\n  perPage: 1,\r\n\r\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\r\n  perMove: 0,\r\n\r\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\r\n  clones: 0,\r\n\r\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\r\n  start: 0,\r\n\r\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\r\n  focus: false,\r\n\r\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\r\n  gap: 0,\r\n\r\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\r\n  padding: 0,\r\n\r\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  arrows: true,\r\n\r\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\r\n  arrowPath: '',\r\n\r\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  pagination: true,\r\n\r\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  autoplay: false,\r\n\r\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\r\n  interval: 5000,\r\n\r\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  pauseOnHover: true,\r\n\r\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  pauseOnFocus: true,\r\n\r\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  resetProgress: true,\r\n\r\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\r\n  lazyLoad: false,\r\n\r\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\r\n  preloadPages: 1,\r\n\r\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\r\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\r\n\r\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\r\n  keyboard: 'global',\r\n\r\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  drag: true,\r\n\r\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\r\n  dragAngleThreshold: 30,\r\n\r\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\r\n  swipeDistanceThreshold: 150,\r\n\r\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\r\n  flickVelocityThreshold: .6,\r\n\r\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\r\n  flickPower: 600,\r\n\r\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\r\n  flickMaxPages: 1,\r\n\r\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\r\n  direction: 'ltr',\r\n\r\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  cover: false,\r\n\r\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  accessibility: true,\r\n\r\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  slideFocus: true,\r\n\r\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  isNavigation: false,\r\n\r\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  trimSpace: true,\r\n\r\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  updateOnMove: false,\r\n\r\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\r\n  throttle: 100,\r\n\r\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  destroy: false,\r\n\r\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\r\n  breakpoints: false,\r\n\r\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\r\n  classes: ELEMENT_CLASSES,\r\n\r\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\r\n  i18n: I18N\r\n};\r\n;// CONCATENATED MODULE: ./src/js/constants/states.js\r\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\r\nvar CREATED = 1;\r\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar MOUNTED = 2;\r\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar IDLE = 3;\r\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar MOVING = 4;\r\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar DESTROYED = 5;\r\n;// CONCATENATED MODULE: ./src/js/splide.js\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\r\n\r\nvar Splide = /*#__PURE__*/function () {\r\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\r\n  function Splide(root, options, Components) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    if (Components === void 0) {\r\n      Components = {};\r\n    }\r\n\r\n    this.root = root instanceof Element ? root : document.querySelector(root);\r\n    exist(this.root, 'An invalid element/selector was given.');\r\n    this.Components = null;\r\n    this.Event = core_event();\r\n    this.State = state(CREATED);\r\n    this.STATES = states_namespaceObject;\r\n    this._o = merge(DEFAULTS, options);\r\n    this._i = 0;\r\n    this._c = Components;\r\n    this._e = {}; // Extensions\r\n\r\n    this._t = null; // Transition\r\n  }\r\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\r\n\r\n\r\n  var _proto = Splide.prototype;\r\n\r\n  _proto.mount = function mount(Extensions, Transition) {\r\n    var _this = this;\r\n\r\n    if (Extensions === void 0) {\r\n      Extensions = this._e;\r\n    }\r\n\r\n    if (Transition === void 0) {\r\n      Transition = this._t;\r\n    }\r\n\r\n    // Reset the state.\r\n    this.State.set(CREATED);\r\n    this._e = Extensions;\r\n    this._t = Transition;\r\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\r\n\r\n    try {\r\n      each(this.Components, function (component, key) {\r\n        var required = component.required;\r\n\r\n        if (required === undefined || required) {\r\n          component.mount && component.mount();\r\n        } else {\r\n          delete _this.Components[key];\r\n        }\r\n      });\r\n    } catch (e) {\r\n      error(e.message);\r\n      return;\r\n    }\r\n\r\n    var State = this.State;\r\n    State.set(MOUNTED);\r\n    each(this.Components, function (component) {\r\n      component.mounted && component.mounted();\r\n    });\r\n    this.emit('mounted');\r\n    State.set(IDLE);\r\n    this.emit('ready');\r\n    applyStyle(this.root, {\r\n      visibility: 'visible'\r\n    });\r\n    this.on('move drag', function () {\r\n      return State.set(MOVING);\r\n    }).on('moved dragged', function () {\r\n      return State.set(IDLE);\r\n    });\r\n    return this;\r\n  }\r\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\r\n  ;\r\n\r\n  _proto.sync = function sync(splide) {\r\n    this.sibling = splide;\r\n    return this;\r\n  }\r\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\r\n  ;\r\n\r\n  _proto.on = function on(events, handler, elm, options) {\r\n    if (elm === void 0) {\r\n      elm = null;\r\n    }\r\n\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    this.Event.on(events, handler, elm, options);\r\n    return this;\r\n  }\r\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\r\n  ;\r\n\r\n  _proto.off = function off(events, elm) {\r\n    if (elm === void 0) {\r\n      elm = null;\r\n    }\r\n\r\n    this.Event.off(events, elm);\r\n    return this;\r\n  }\r\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\r\n  ;\r\n\r\n  _proto.emit = function emit(event) {\r\n    var _this$Event;\r\n\r\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      args[_key - 1] = arguments[_key];\r\n    }\r\n\r\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\r\n  ;\r\n\r\n  _proto.go = function go(control, wait) {\r\n    if (wait === void 0) {\r\n      wait = this.options.waitForTransition;\r\n    }\r\n\r\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\r\n      this.Components.Controller.go(control, false);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\r\n  ;\r\n\r\n  _proto.is = function is(type) {\r\n    return type === this._o.type;\r\n  }\r\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\r\n  ;\r\n\r\n  _proto.add = function add(slide, index) {\r\n    if (index === void 0) {\r\n      index = -1;\r\n    }\r\n\r\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\r\n    return this;\r\n  }\r\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\r\n  ;\r\n\r\n  _proto.remove = function remove(index) {\r\n    this.Components.Elements.remove(index);\r\n    this.refresh();\r\n    return this;\r\n  }\r\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\r\n  ;\r\n\r\n  _proto.refresh = function refresh() {\r\n    this.emit('refresh:before').emit('refresh').emit('resize');\r\n    return this;\r\n  }\r\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\r\n  ;\r\n\r\n  _proto.destroy = function destroy(completely) {\r\n    var _this2 = this;\r\n\r\n    if (completely === void 0) {\r\n      completely = true;\r\n    }\r\n\r\n    // Postpone destroy because it should be done after mount.\r\n    if (this.State.is(CREATED)) {\r\n      this.on('ready', function () {\r\n        return _this2.destroy(completely);\r\n      });\r\n      return;\r\n    }\r\n\r\n    values(this.Components).reverse().forEach(function (component) {\r\n      component.destroy && component.destroy(completely);\r\n    });\r\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\r\n\r\n    this.Event.destroy();\r\n    this.State.set(DESTROYED);\r\n    return this;\r\n  }\r\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\r\n  ;\r\n\r\n  _createClass(Splide, [{\r\n    key: \"index\",\r\n    get: function get() {\r\n      return this._i;\r\n    }\r\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\r\n    ,\r\n    set: function set(index) {\r\n      this._i = parseInt(index);\r\n    }\r\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\r\n\r\n  }, {\r\n    key: \"length\",\r\n    get: function get() {\r\n      return this.Components.Elements.length;\r\n    }\r\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\r\n\r\n  }, {\r\n    key: \"options\",\r\n    get: function get() {\r\n      return this._o;\r\n    }\r\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\r\n    ,\r\n    set: function set(options) {\r\n      var created = this.State.is(CREATED);\r\n\r\n      if (!created) {\r\n        this.emit('update');\r\n      }\r\n\r\n      this._o = merge(this._o, options);\r\n\r\n      if (!created) {\r\n        this.emit('updated', this._o);\r\n      }\r\n    }\r\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\r\n\r\n  }, {\r\n    key: \"classes\",\r\n    get: function get() {\r\n      return this._o.classes;\r\n    }\r\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\r\n\r\n  }, {\r\n    key: \"i18n\",\r\n    get: function get() {\r\n      return this._o.i18n;\r\n    }\r\n  }]);\r\n\r\n  return Splide;\r\n}();\r\n\r\n\r\n;// CONCATENATED MODULE: ./src/js/components/options/index.js\r\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const options = (function (Splide) {\r\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\r\n  var options = getAttribute(Splide.root, 'data-splide');\r\n\r\n  if (options) {\r\n    try {\r\n      Splide.options = JSON.parse(options);\r\n    } catch (e) {\r\n      error(e.message);\r\n    }\r\n  }\r\n\r\n  return {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      if (Splide.State.is(CREATED)) {\r\n        Splide.index = Splide.options.start;\r\n      }\r\n    }\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/constants/directions.js\r\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\r\nvar LTR = 'ltr';\r\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar RTL = 'rtl';\r\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar TTB = 'ttb';\r\n;// CONCATENATED MODULE: ./src/js/components/elements/slide.js\r\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar STYLE_RESTORE_EVENTS = 'update.slide';\r\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\r\n\r\n/* harmony default export */ const elements_slide = (function (Splide, index, realIndex, slide) {\r\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  var updateOnMove = Splide.options.updateOnMove;\r\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\r\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Slide = {\r\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    slide: slide,\r\n\r\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\r\n    index: index,\r\n\r\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\r\n    realIndex: realIndex,\r\n\r\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\r\n    container: child(slide, Splide.classes.container),\r\n\r\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    isClone: realIndex > -1,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      var _this = this;\r\n\r\n      if (!this.isClone) {\r\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\r\n      }\r\n\r\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\r\n        return _this.update();\r\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\r\n        return Splide.emit('click', _this);\r\n      }, slide);\r\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\r\n\r\n      if (updateOnMove) {\r\n        Splide.on('move.slide', function (newIndex) {\r\n          if (newIndex === realIndex) {\r\n            _update(true, false);\r\n          }\r\n        });\r\n      } // Make sure the slide is shown.\r\n\r\n\r\n      applyStyle(slide, {\r\n        display: ''\r\n      }); // Hold the original styles.\r\n\r\n      this.styles = getAttribute(slide, 'style') || '';\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\r\n      removeClass(slide, values(STATUS_CLASSES));\r\n      restoreStyles();\r\n      removeAttribute(this.container, 'style');\r\n    },\r\n\r\n    /**\r\n     * Update active and visible status.\r\n     */\r\n    update: function update() {\r\n      _update(this.isActive(), false);\r\n\r\n      _update(this.isVisible(), true);\r\n    },\r\n\r\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\r\n    isActive: function isActive() {\r\n      return Splide.index === index;\r\n    },\r\n\r\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\r\n    isVisible: function isVisible() {\r\n      var active = this.isActive();\r\n\r\n      if (Splide.is(FADE) || active) {\r\n        return active;\r\n      }\r\n\r\n      var ceil = Math.ceil;\r\n      var trackRect = getRect(Splide.Components.Elements.track);\r\n      var slideRect = getRect(slide);\r\n\r\n      if (Splide.options.direction === TTB) {\r\n        return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\r\n      }\r\n\r\n      return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\r\n    },\r\n\r\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\r\n    isWithin: function isWithin(from, within) {\r\n      var diff = Math.abs(from - index);\r\n\r\n      if (!Splide.is(SLIDE) && !this.isClone) {\r\n        diff = Math.min(diff, Splide.length - diff);\r\n      }\r\n\r\n      return diff < within;\r\n    }\r\n  };\r\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\r\n\r\n  function _update(active, forVisibility) {\r\n    var type = forVisibility ? 'visible' : 'active';\r\n    var className = STATUS_CLASSES[type];\r\n\r\n    if (active) {\r\n      addClass(slide, className);\r\n      Splide.emit(\"\" + type, Slide);\r\n    } else {\r\n      if (hasClass(slide, className)) {\r\n        removeClass(slide, className);\r\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Restore the original styles.\r\n   */\r\n\r\n\r\n  function restoreStyles() {\r\n    setAttribute(slide, 'style', Slide.styles);\r\n  }\r\n\r\n  return Slide;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/elements/index.js\r\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar UID_NAME = 'uid';\r\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const components_elements = (function (Splide, Components) {\r\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n  var root = Splide.root;\r\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var classes = Splide.classes;\r\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\r\n\r\n  var Slides = [];\r\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\r\n\r\n  if (!root.id) {\r\n    window.splide = window.splide || {};\r\n    var uid = window.splide[UID_NAME] || 0;\r\n    window.splide[UID_NAME] = ++uid;\r\n    root.id = \"splide\" + pad(uid);\r\n  }\r\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n\r\n  var Elements = {\r\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\r\n    mount: function mount() {\r\n      var _this = this;\r\n\r\n      this.init();\r\n      Splide.on('refresh', function () {\r\n        _this.destroy();\r\n\r\n        _this.init();\r\n      }).on('updated', function () {\r\n        removeClass(root, getClasses());\r\n        addClass(root, getClasses());\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      Slides.forEach(function (Slide) {\r\n        Slide.destroy();\r\n      });\r\n      Slides = [];\r\n      removeClass(root, getClasses());\r\n    },\r\n\r\n    /**\r\n     * Initialization.\r\n     */\r\n    init: function init() {\r\n      var _this2 = this;\r\n\r\n      collect();\r\n      addClass(root, getClasses());\r\n      this.slides.forEach(function (slide, index) {\r\n        _this2.register(slide, index, -1);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\r\n    register: function register(slide, index, realIndex) {\r\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\r\n      SlideObject.mount();\r\n      Slides.push(SlideObject);\r\n    },\r\n\r\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\r\n    getSlide: function getSlide(index) {\r\n      return Slides.filter(function (Slide) {\r\n        return Slide.index === index;\r\n      })[0];\r\n    },\r\n\r\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\r\n    getSlides: function getSlides(includeClones) {\r\n      return includeClones ? Slides : Slides.filter(function (Slide) {\r\n        return !Slide.isClone;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\r\n    getSlidesByPage: function getSlidesByPage(page) {\r\n      var idx = Components.Controller.toIndex(page);\r\n      var options = Splide.options;\r\n      var max = options.focus !== false ? 1 : options.perPage;\r\n      return Slides.filter(function (_ref) {\r\n        var index = _ref.index;\r\n        return idx <= index && index < idx + max;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\r\n    add: function add(slide, index, callback) {\r\n      if (typeof slide === 'string') {\r\n        slide = domify(slide);\r\n      }\r\n\r\n      if (slide instanceof Element) {\r\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\r\n\r\n        applyStyle(slide, {\r\n          display: 'none'\r\n        });\r\n\r\n        if (ref) {\r\n          before(slide, ref);\r\n          this.slides.splice(index, 0, slide);\r\n        } else {\r\n          append(this.list, slide);\r\n          this.slides.push(slide);\r\n        }\r\n\r\n        loaded(slide, function () {\r\n          callback && callback(slide);\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\r\n    remove: function remove(index) {\r\n      dom_remove(this.slides.splice(index, 1)[0]);\r\n    },\r\n\r\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\r\n    each: function each(callback) {\r\n      Slides.forEach(callback);\r\n    },\r\n\r\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\r\n    get length() {\r\n      return this.slides.length;\r\n    },\r\n\r\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\r\n    get total() {\r\n      return Slides.length;\r\n    }\r\n\r\n  };\r\n  /**\r\n   * Collect elements.\r\n   */\r\n\r\n  function collect() {\r\n    Elements.slider = child(root, classes.slider);\r\n    Elements.track = find(root, \".\" + classes.track);\r\n    Elements.list = child(Elements.track, classes.list);\r\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\r\n    Elements.slides = children(Elements.list, classes.slide);\r\n    var arrows = findParts(classes.arrows);\r\n    Elements.arrows = {\r\n      prev: find(arrows, \".\" + classes.prev),\r\n      next: find(arrows, \".\" + classes.next)\r\n    };\r\n    var autoplay = findParts(classes.autoplay);\r\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\r\n    Elements.play = find(autoplay, \".\" + classes.play);\r\n    Elements.pause = find(autoplay, \".\" + classes.pause);\r\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\r\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\r\n  }\r\n  /**\r\n   * Return class names for the root element.\r\n   */\r\n\r\n\r\n  function getClasses() {\r\n    var rootClass = classes.root;\r\n    var options = Splide.options;\r\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\r\n  }\r\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\r\n\r\n\r\n  function findParts(className) {\r\n    return child(root, className) || child(Elements.slider, className);\r\n  }\r\n\r\n  return Elements;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/controller/index.js\r\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\nvar floor = Math.floor;\r\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const controller = (function (Splide, Components) {\r\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var options;\r\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isLoop;\r\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Controller = {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      options = Splide.options;\r\n      isLoop = Splide.is(LOOP);\r\n      bind();\r\n    },\r\n\r\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\r\n    go: function go(control, silently) {\r\n      var destIndex = this.trim(this.parse(control));\r\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\r\n    },\r\n\r\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\r\n    parse: function parse(control) {\r\n      var index = Splide.index;\r\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\r\n      var indicator = matches ? matches[1] : '';\r\n      var number = matches ? parseInt(matches[2]) : 0;\r\n\r\n      switch (indicator) {\r\n        case '+':\r\n          index += number || 1;\r\n          break;\r\n\r\n        case '-':\r\n          index -= number || 1;\r\n          break;\r\n\r\n        case '>':\r\n        case '<':\r\n          index = parsePage(number, index, indicator === '<');\r\n          break;\r\n\r\n        default:\r\n          index = parseInt(control);\r\n      }\r\n\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\r\n    toIndex: function toIndex(page) {\r\n      if (hasFocus()) {\r\n        return page;\r\n      }\r\n\r\n      var length = Splide.length;\r\n      var perPage = options.perPage;\r\n      var index = page * perPage;\r\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\r\n\r\n      if (length - perPage <= index && index < length) {\r\n        index = length - perPage;\r\n      }\r\n\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\r\n    toPage: function toPage(index) {\r\n      if (hasFocus()) {\r\n        return index;\r\n      }\r\n\r\n      var length = Splide.length;\r\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\r\n\r\n      if (length - perPage <= index && index < length) {\r\n        return floor((length - 1) / perPage);\r\n      }\r\n\r\n      return floor(index / perPage);\r\n    },\r\n\r\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\r\n    trim: function trim(index) {\r\n      if (!isLoop) {\r\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\r\n      }\r\n\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\r\n    rewind: function rewind(index) {\r\n      var edge = this.edgeIndex;\r\n\r\n      if (isLoop) {\r\n        while (index > edge) {\r\n          index -= edge + 1;\r\n        }\r\n\r\n        while (index < 0) {\r\n          index += edge + 1;\r\n        }\r\n      } else {\r\n        if (index > edge) {\r\n          index = 0;\r\n        } else if (index < 0) {\r\n          index = edge;\r\n        }\r\n      }\r\n\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\r\n    isRtl: function isRtl() {\r\n      return options.direction === RTL;\r\n    },\r\n\r\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\r\n    get pageLength() {\r\n      var length = Splide.length;\r\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\r\n    },\r\n\r\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\r\n    get edgeIndex() {\r\n      var length = Splide.length;\r\n\r\n      if (!length) {\r\n        return 0;\r\n      }\r\n\r\n      if (hasFocus() || options.isNavigation || isLoop) {\r\n        return length - 1;\r\n      }\r\n\r\n      return length - options.perPage;\r\n    },\r\n\r\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\r\n    get prevIndex() {\r\n      var prev = Splide.index - 1;\r\n\r\n      if (isLoop || options.rewind) {\r\n        prev = this.rewind(prev);\r\n      }\r\n\r\n      return prev > -1 ? prev : -1;\r\n    },\r\n\r\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\r\n    get nextIndex() {\r\n      var next = Splide.index + 1;\r\n\r\n      if (isLoop || options.rewind) {\r\n        next = this.rewind(next);\r\n      }\r\n\r\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\r\n    }\r\n\r\n  };\r\n  /**\r\n   * Listen to some events.\r\n   */\r\n\r\n  function bind() {\r\n    Splide.on('move', function (newIndex) {\r\n      Splide.index = newIndex;\r\n    }).on('updated refresh', function (newOptions) {\r\n      options = newOptions || options;\r\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\r\n    });\r\n  }\r\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\r\n\r\n\r\n  function hasFocus() {\r\n    return options.focus !== false;\r\n  }\r\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\r\n\r\n\r\n  function parsePage(number, index, prev) {\r\n    if (number > -1) {\r\n      return Controller.toIndex(number);\r\n    }\r\n\r\n    var perMove = options.perMove;\r\n    var sign = prev ? -1 : 1;\r\n\r\n    if (perMove) {\r\n      return index + perMove * sign;\r\n    }\r\n\r\n    return Controller.toIndex(Controller.toPage(index) + sign);\r\n  }\r\n\r\n  return Controller;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/track/index.js\r\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar abs = Math.abs;\r\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const track = (function (Splide, Components) {\r\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var Layout;\r\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Elements;\r\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var list;\r\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isVertical = Splide.options.direction === TTB;\r\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isFade = Splide.is(FADE);\r\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isRTL = Splide.options.direction === RTL;\r\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isLoopPending = false;\r\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\r\n\r\n  var sign = isRTL ? 1 : -1;\r\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Track = {\r\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\r\n    sign: sign,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Elements = Components.Elements;\r\n      Layout = Components.Layout;\r\n      list = Elements.list;\r\n    },\r\n\r\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\r\n    mounted: function mounted() {\r\n      var _this = this;\r\n\r\n      if (!isFade) {\r\n        this.jump(0);\r\n        Splide.on('mounted resize updated', function () {\r\n          _this.jump(Splide.index);\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\r\n    go: function go(destIndex, newIndex, silently) {\r\n      var newPosition = getTrimmedPosition(destIndex);\r\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\r\n\r\n      if (Splide.State.is(MOVING) && isLoopPending) {\r\n        return;\r\n      }\r\n\r\n      isLoopPending = destIndex !== newIndex;\r\n\r\n      if (!silently) {\r\n        Splide.emit('move', newIndex, prevIndex, destIndex);\r\n      }\r\n\r\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\r\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\r\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\r\n        });\r\n      } else {\r\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\r\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\r\n        } else {\r\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\r\n    jump: function jump(index) {\r\n      this.translate(getTrimmedPosition(index));\r\n    },\r\n\r\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\r\n    translate: function translate(position) {\r\n      applyStyle(list, {\r\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\r\n    cancel: function cancel() {\r\n      if (Splide.is(LOOP)) {\r\n        this.shift();\r\n      } else {\r\n        // Ensure the current position.\r\n        this.translate(this.position);\r\n      }\r\n\r\n      applyStyle(list, {\r\n        transition: ''\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\r\n    shift: function shift() {\r\n      var position = abs(this.position);\r\n      var left = abs(this.toPosition(0));\r\n      var right = abs(this.toPosition(Splide.length));\r\n      var innerSize = right - left;\r\n\r\n      if (position < left) {\r\n        position += innerSize;\r\n      } else if (position > right) {\r\n        position -= innerSize;\r\n      }\r\n\r\n      this.translate(sign * position);\r\n    },\r\n\r\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\r\n    trim: function trim(position) {\r\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\r\n        return position;\r\n      }\r\n\r\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\r\n      return between(position, edge, 0);\r\n    },\r\n\r\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\r\n    toIndex: function toIndex(position) {\r\n      var _this2 = this;\r\n\r\n      var index = 0;\r\n      var minDistance = Infinity;\r\n      Elements.getSlides(true).forEach(function (Slide) {\r\n        var slideIndex = Slide.index;\r\n        var distance = abs(_this2.toPosition(slideIndex) - position);\r\n\r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          index = slideIndex;\r\n        }\r\n      });\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\r\n    toCoord: function toCoord(position) {\r\n      return {\r\n        x: isVertical ? 0 : position,\r\n        y: isVertical ? position : 0\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\r\n    toPosition: function toPosition(index) {\r\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\r\n      return sign * (position + this.offset(index));\r\n    },\r\n\r\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\r\n    offset: function offset(index) {\r\n      var focus = Splide.options.focus;\r\n      var slideSize = Layout.slideSize(index);\r\n\r\n      if (focus === 'center') {\r\n        return -(Layout.size - slideSize) / 2;\r\n      }\r\n\r\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\r\n    },\r\n\r\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\r\n    get position() {\r\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\r\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\r\n    }\r\n\r\n  };\r\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\r\n\r\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\r\n    applyStyle(list, {\r\n      transition: ''\r\n    });\r\n    isLoopPending = false;\r\n\r\n    if (!isFade) {\r\n      Track.jump(newIndex);\r\n    }\r\n\r\n    if (!silently) {\r\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\r\n    }\r\n  }\r\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\r\n\r\n\r\n  function getTrimmedPosition(index) {\r\n    return Track.trim(Track.toPosition(index));\r\n  }\r\n\r\n  return Track;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/clones/index.js\r\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const clones = (function (Splide, Components) {\r\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\r\n  var clones = [];\r\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\r\n\r\n  var cloneCount = 0;\r\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Clones = {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      var _this = this;\r\n\r\n      if (Splide.is(LOOP)) {\r\n        init();\r\n        Splide.on('refresh:before', function () {\r\n          _this.destroy();\r\n        }).on('refresh', init).on('resize', function () {\r\n          if (cloneCount !== getCloneCount()) {\r\n            // Destroy before refresh not to collect clones by the Elements component.\r\n            _this.destroy();\r\n\r\n            Splide.refresh();\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      dom_remove(clones);\r\n      clones = [];\r\n    },\r\n\r\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\r\n    get clones() {\r\n      return clones;\r\n    },\r\n\r\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\r\n    get length() {\r\n      return clones.length;\r\n    }\r\n\r\n  };\r\n  /**\r\n   * Initialization.\r\n   */\r\n\r\n  function init() {\r\n    Clones.destroy();\r\n    cloneCount = getCloneCount();\r\n    generateClones(cloneCount);\r\n  }\r\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\r\n\r\n\r\n  function generateClones(count) {\r\n    var length = Elements.length,\r\n        register = Elements.register;\r\n\r\n    if (length) {\r\n      var slides = Elements.slides;\r\n\r\n      while (slides.length < count) {\r\n        slides = slides.concat(slides);\r\n      } // Clones after the last element.\r\n\r\n\r\n      slides.slice(0, count).forEach(function (elm, index) {\r\n        var clone = cloneDeeply(elm);\r\n        append(Elements.list, clone);\r\n        clones.push(clone);\r\n        register(clone, index + length, index % length);\r\n      }); // Clones before the first element.\r\n\r\n      slides.slice(-count).forEach(function (elm, index) {\r\n        var clone = cloneDeeply(elm);\r\n        before(clone, slides[0]);\r\n        clones.push(clone);\r\n        register(clone, index - count, (length + index - count % length) % length);\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\r\n\r\n\r\n  function getCloneCount() {\r\n    var options = Splide.options;\r\n\r\n    if (options.clones) {\r\n      return options.clones;\r\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\r\n\r\n\r\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\r\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\r\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\r\n\r\n    if (fixedSize) {\r\n      // Roughly calculate the count. This needs not to be strict.\r\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\r\n    }\r\n\r\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\r\n  }\r\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\r\n\r\n\r\n  function cloneDeeply(elm) {\r\n    var clone = elm.cloneNode(true);\r\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\r\n\r\n    removeAttribute(clone, 'id');\r\n    return clone;\r\n  }\r\n\r\n  return Clones;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\r\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\r\n\r\n/* harmony default export */ const horizontal = (function (Splide, Components) {\r\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var root = Splide.root;\r\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var track;\r\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var options = Splide.options;\r\n  return {\r\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\r\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\r\n\r\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\r\n    height: 0,\r\n\r\n    /**\r\n     * Initialization.\r\n     */\r\n    init: function init() {\r\n      this.resize();\r\n    },\r\n\r\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\r\n    resize: function resize() {\r\n      options = Splide.options;\r\n      track = Elements.track;\r\n      this.gap = toPixel(root, options.gap);\r\n      var padding = options.padding;\r\n      var left = toPixel(root, padding.left || padding);\r\n      var right = toPixel(root, padding.right || padding);\r\n      this.padding = {\r\n        left: left,\r\n        right: right\r\n      };\r\n      applyStyle(track, {\r\n        paddingLeft: unit(left),\r\n        paddingRight: unit(right)\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\r\n    totalWidth: function totalWidth(index) {\r\n      if (index === void 0) {\r\n        index = Splide.length - 1;\r\n      }\r\n\r\n      var Slide = Elements.getSlide(index);\r\n      var width = 0;\r\n\r\n      if (Slide) {\r\n        var slideRect = getRect(Slide.slide);\r\n        var listRect = getRect(Elements.list);\r\n\r\n        if (options.direction === RTL) {\r\n          width = listRect.right - slideRect.left;\r\n        } else {\r\n          width = slideRect.right - listRect.left;\r\n        }\r\n\r\n        width += this.gap;\r\n      }\r\n\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\r\n    slideWidth: function slideWidth(index) {\r\n      if (options.autoWidth) {\r\n        var Slide = Elements.getSlide(index);\r\n        return Slide ? Slide.slide.offsetWidth : 0;\r\n      }\r\n\r\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\r\n      return toPixel(root, width);\r\n    },\r\n\r\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\r\n    slideHeight: function slideHeight() {\r\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\r\n      return toPixel(root, height);\r\n    },\r\n\r\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\r\n    get width() {\r\n      return track.clientWidth - this.padding.left - this.padding.right;\r\n    }\r\n\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\r\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\r\n\r\n/* harmony default export */ const vertical = (function (Splide, Components) {\r\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var root = Splide.root;\r\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var track;\r\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var options;\r\n  return {\r\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\r\n    margin: 'marginBottom',\r\n\r\n    /**\r\n     * Initialization.\r\n     */\r\n    init: function init() {\r\n      this.resize();\r\n    },\r\n\r\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\r\n    resize: function resize() {\r\n      options = Splide.options;\r\n      track = Elements.track;\r\n      this.gap = toPixel(root, options.gap);\r\n      var padding = options.padding;\r\n      var top = toPixel(root, padding.top || padding);\r\n      var bottom = toPixel(root, padding.bottom || padding);\r\n      this.padding = {\r\n        top: top,\r\n        bottom: bottom\r\n      };\r\n      applyStyle(track, {\r\n        paddingTop: unit(top),\r\n        paddingBottom: unit(bottom)\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\r\n    totalHeight: function totalHeight(index) {\r\n      if (index === void 0) {\r\n        index = Splide.length - 1;\r\n      }\r\n\r\n      var Slide = Elements.getSlide(index);\r\n\r\n      if (Slide) {\r\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\r\n      }\r\n\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\r\n    slideWidth: function slideWidth() {\r\n      return toPixel(root, options.fixedWidth || this.width);\r\n    },\r\n\r\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\r\n    slideHeight: function slideHeight(index) {\r\n      if (options.autoHeight) {\r\n        var Slide = Elements.getSlide(index);\r\n        return Slide ? Slide.slide.offsetHeight : 0;\r\n      }\r\n\r\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\r\n      return toPixel(root, height);\r\n    },\r\n\r\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\r\n    get width() {\r\n      return track.clientWidth;\r\n    },\r\n\r\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\r\n    get height() {\r\n      var height = options.height || this.width * options.heightRatio;\r\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\r\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\r\n    }\r\n\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/utils/time.js\r\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\r\nfunction throttle(func, wait) {\r\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\r\n\r\n  return function () {\r\n    if (!timeout) {\r\n      timeout = setTimeout(function () {\r\n        func();\r\n        timeout = null;\r\n      }, wait);\r\n    }\r\n  };\r\n}\r\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\r\n\r\nfunction createInterval(callback, interval, progress) {\r\n  var _window = window,\r\n      requestAnimationFrame = _window.requestAnimationFrame;\r\n  var start,\r\n      elapse,\r\n      rate,\r\n      _pause = true;\r\n\r\n  var step = function step(timestamp) {\r\n    if (!_pause) {\r\n      if (!start) {\r\n        start = timestamp;\r\n\r\n        if (rate && rate < 1) {\r\n          start -= rate * interval;\r\n        }\r\n      }\r\n\r\n      elapse = timestamp - start;\r\n      rate = elapse / interval;\r\n\r\n      if (elapse >= interval) {\r\n        start = 0;\r\n        rate = 1;\r\n        callback();\r\n      }\r\n\r\n      if (progress) {\r\n        progress(rate);\r\n      }\r\n\r\n      requestAnimationFrame(step);\r\n    }\r\n  };\r\n\r\n  return {\r\n    pause: function pause() {\r\n      _pause = true;\r\n      start = 0;\r\n    },\r\n    play: function play(reset) {\r\n      start = 0;\r\n\r\n      if (reset) {\r\n        rate = 0;\r\n      }\r\n\r\n      if (_pause) {\r\n        _pause = false;\r\n        requestAnimationFrame(step);\r\n      }\r\n    }\r\n  };\r\n}\r\n;// CONCATENATED MODULE: ./src/js/components/layout/index.js\r\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const layout = (function (Splide, Components) {\r\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isVertical = Splide.options.direction === TTB;\r\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Layout = object_assign({\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      bind();\r\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\r\n\r\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\r\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\r\n    },\r\n\r\n    /**\r\n     * Destroy the component.\r\n     */\r\n    destroy: function destroy() {\r\n      removeAttribute([Elements.list, Elements.track], 'style');\r\n    },\r\n\r\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\r\n    get size() {\r\n      return isVertical ? this.height : this.width;\r\n    }\r\n\r\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\r\n  /**\r\n   * Init slider styles according to options.\r\n   */\r\n\r\n  function init() {\r\n    Layout.init();\r\n    applyStyle(Splide.root, {\r\n      maxWidth: unit(Splide.options.width)\r\n    });\r\n    Elements.each(function (Slide) {\r\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\r\n    });\r\n    resize();\r\n  }\r\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\r\n\r\n\r\n  function bind() {\r\n    Splide.on('resize load', throttle(function () {\r\n      Splide.emit('resize');\r\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\r\n  }\r\n  /**\r\n   * Resize the track and slide elements.\r\n   */\r\n\r\n\r\n  function resize() {\r\n    var options = Splide.options;\r\n    Layout.resize();\r\n    applyStyle(Elements.track, {\r\n      height: unit(Layout.height)\r\n    });\r\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\r\n    Elements.each(function (Slide) {\r\n      applyStyle(Slide.container, {\r\n        height: slideHeight\r\n      });\r\n      applyStyle(Slide.slide, {\r\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\r\n        height: Slide.container ? null : slideHeight\r\n      });\r\n    });\r\n    Splide.emit('resized');\r\n  }\r\n\r\n  return Layout;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/drag/index.js\r\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar drag_abs = Math.abs;\r\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\r\n\r\nvar MIN_VELOCITY = 0.1;\r\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar FRICTION_REDUCER = 7;\r\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const drag = (function (Splide, Components) {\r\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var Track = Components.Track;\r\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Controller = Components.Controller;\r\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var startCoord;\r\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\r\n\r\n  var startInfo;\r\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var currentInfo;\r\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isDragging;\r\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isVertical = Splide.options.direction === TTB;\r\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n  var axis = isVertical ? 'y' : 'x';\r\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Drag = {\r\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    disabled: false,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      var _this = this;\r\n\r\n      var Elements = Components.Elements;\r\n      var track = Elements.track;\r\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\r\n        passive: false\r\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\r\n        // Prevent dragging an image or anchor itself.\r\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\r\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\r\n            e.preventDefault();\r\n          }, elm, {\r\n            passive: false\r\n          });\r\n        });\r\n      }).on('mounted updated', function () {\r\n        _this.disabled = !Splide.options.drag;\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\r\n\r\n  function start(e) {\r\n    if (!Drag.disabled && !isDragging) {\r\n      // These prams are used to evaluate whether the slider should start moving.\r\n      init(e);\r\n    }\r\n  }\r\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\r\n\r\n\r\n  function init(e) {\r\n    startCoord = Track.toCoord(Track.position);\r\n    startInfo = analyze(e, {});\r\n    currentInfo = startInfo;\r\n  }\r\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\r\n\r\n\r\n  function move(e) {\r\n    if (startInfo) {\r\n      currentInfo = analyze(e, startInfo);\r\n\r\n      if (isDragging) {\r\n        if (e.cancelable) {\r\n          e.preventDefault();\r\n        }\r\n\r\n        if (!Splide.is(FADE)) {\r\n          var position = startCoord[axis] + currentInfo.offset[axis];\r\n          Track.translate(resist(position));\r\n        }\r\n      } else {\r\n        if (shouldMove(currentInfo)) {\r\n          Splide.emit('drag', startInfo);\r\n          isDragging = true;\r\n          Track.cancel(); // These params are actual drag data.\r\n\r\n          init(e);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\r\n\r\n\r\n  function shouldMove(_ref) {\r\n    var offset = _ref.offset;\r\n\r\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\r\n      return false;\r\n    }\r\n\r\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\r\n\r\n    if (isVertical) {\r\n      angle = 90 - angle;\r\n    }\r\n\r\n    return angle < Splide.options.dragAngleThreshold;\r\n  }\r\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\r\n\r\n\r\n  function resist(position) {\r\n    if (Splide.is(SLIDE)) {\r\n      var sign = Track.sign;\r\n\r\n      var _start = sign * Track.trim(Track.toPosition(0));\r\n\r\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\r\n\r\n      position *= sign;\r\n\r\n      if (position < _start) {\r\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\r\n      } else if (position > _end) {\r\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\r\n      }\r\n\r\n      position *= sign;\r\n    }\r\n\r\n    return position;\r\n  }\r\n  /**\r\n   * Called when dragging ends.\r\n   */\r\n\r\n\r\n  function end() {\r\n    startInfo = null;\r\n\r\n    if (isDragging) {\r\n      Splide.emit('dragged', currentInfo);\r\n      go(currentInfo);\r\n      isDragging = false;\r\n    }\r\n  }\r\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\r\n\r\n\r\n  function go(info) {\r\n    var velocity = info.velocity[axis];\r\n    var absV = drag_abs(velocity);\r\n\r\n    if (absV > 0) {\r\n      var options = Splide.options;\r\n      var index = Splide.index;\r\n      var sign = velocity < 0 ? -1 : 1;\r\n      var destIndex = index;\r\n\r\n      if (!Splide.is(FADE)) {\r\n        var destination = Track.position;\r\n\r\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\r\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\r\n        }\r\n\r\n        destIndex = Track.toIndex(destination);\r\n      }\r\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\r\n\r\n\r\n      if (destIndex === index && absV > MIN_VELOCITY) {\r\n        destIndex = index + sign * Track.sign;\r\n      }\r\n\r\n      if (Splide.is(SLIDE)) {\r\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\r\n      }\r\n\r\n      Controller.go(destIndex, options.isNavigation);\r\n    }\r\n  }\r\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\r\n\r\n\r\n  function analyze(e, startInfo) {\r\n    var timeStamp = e.timeStamp,\r\n        touches = e.touches;\r\n\r\n    var _ref2 = touches ? touches[0] : e,\r\n        clientX = _ref2.clientX,\r\n        clientY = _ref2.clientY;\r\n\r\n    var _ref3 = startInfo.to || {},\r\n        _ref3$x = _ref3.x,\r\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\r\n        _ref3$y = _ref3.y,\r\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\r\n\r\n    var startTime = startInfo.time || 0;\r\n    var offset = {\r\n      x: clientX - fromX,\r\n      y: clientY - fromY\r\n    };\r\n    var duration = timeStamp - startTime;\r\n    var velocity = {\r\n      x: offset.x / duration,\r\n      y: offset.y / duration\r\n    };\r\n    return {\r\n      to: {\r\n        x: clientX,\r\n        y: clientY\r\n      },\r\n      offset: offset,\r\n      time: timeStamp,\r\n      velocity: velocity\r\n    };\r\n  }\r\n\r\n  return Drag;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/click/index.js\r\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n/* harmony default export */ const click = (function (Splide, Components) {\r\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  var disabled = false;\r\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Click = {\r\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: Splide.options.drag,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Splide.on('click', onClick, Components.Elements.track, {\r\n        capture: true\r\n      }).on('drag', function () {\r\n        disabled = true;\r\n      }).on('dragged', function () {\r\n        // Make sure the flag is released after the click event is fired.\r\n        setTimeout(function () {\r\n          disabled = false;\r\n        });\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\r\n\r\n  function onClick(e) {\r\n    if (disabled) {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      e.stopImmediatePropagation();\r\n    }\r\n  }\r\n\r\n  return Click;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\r\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * Set of pause flags.\r\n */\r\n\r\nvar PAUSE_FLAGS = {\r\n  HOVER: 1,\r\n  FOCUS: 2,\r\n  MANUAL: 3\r\n};\r\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const autoplay = (function (Splide, Components, name) {\r\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\r\n  var flags = [];\r\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\r\n\r\n  var interval;\r\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\r\n\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Autoplay = {\r\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: Splide.options.autoplay,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\r\n    mount: function mount() {\r\n      var options = Splide.options;\r\n\r\n      if (Elements.slides.length > options.perPage) {\r\n        interval = createInterval(function () {\r\n          Splide.go('>');\r\n        }, options.interval, function (rate) {\r\n          Splide.emit(name + \":playing\", rate);\r\n\r\n          if (Elements.bar) {\r\n            applyStyle(Elements.bar, {\r\n              width: rate * 100 + \"%\"\r\n            });\r\n          }\r\n        });\r\n        bind();\r\n        this.play();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\r\n    play: function play(flag) {\r\n      if (flag === void 0) {\r\n        flag = 0;\r\n      }\r\n\r\n      flags = flags.filter(function (f) {\r\n        return f !== flag;\r\n      });\r\n\r\n      if (!flags.length) {\r\n        Splide.emit(name + \":play\");\r\n        interval.play(Splide.options.resetProgress);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\r\n    pause: function pause(flag) {\r\n      if (flag === void 0) {\r\n        flag = 0;\r\n      }\r\n\r\n      interval.pause();\r\n\r\n      if (flags.indexOf(flag) === -1) {\r\n        flags.push(flag);\r\n      }\r\n\r\n      if (flags.length === 1) {\r\n        Splide.emit(name + \":pause\");\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Listen some events.\r\n   */\r\n\r\n  function bind() {\r\n    var options = Splide.options;\r\n    var sibling = Splide.sibling;\r\n    var elms = [Splide.root, sibling ? sibling.root : null];\r\n\r\n    if (options.pauseOnHover) {\r\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\r\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\r\n    }\r\n\r\n    if (options.pauseOnFocus) {\r\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\r\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\r\n    }\r\n\r\n    if (Elements.play) {\r\n      Splide.on('click', function () {\r\n        // Need to be removed a focus flag at first.\r\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\r\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\r\n      }, Elements.play);\r\n    }\r\n\r\n    if (Elements.pause) {\r\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\r\n    }\r\n\r\n    Splide.on('move refresh', function () {\r\n      Autoplay.play();\r\n    }) // Rewind the timer.\r\n    .on('destroy', function () {\r\n      Autoplay.pause();\r\n    });\r\n  }\r\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\r\n\r\n\r\n  function switchOn(elms, event, flag, play) {\r\n    elms.forEach(function (elm) {\r\n      Splide.on(event, function () {\r\n        Autoplay[play ? 'play' : 'pause'](flag);\r\n      }, elm);\r\n    });\r\n  }\r\n\r\n  return Autoplay;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/cover/index.js\r\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const cover = (function (Splide, Components) {\r\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var options = Splide.options;\r\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Cover = {\r\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: options.cover,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Splide.on('lazyload:loaded', function (img) {\r\n        cover(img, false);\r\n      });\r\n      Splide.on('mounted updated refresh', function () {\r\n        return apply(false);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      apply(true);\r\n    }\r\n  };\r\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\r\n\r\n  function apply(uncover) {\r\n    Components.Elements.each(function (Slide) {\r\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\r\n\r\n      if (img && img.src) {\r\n        cover(img, uncover);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\r\n\r\n\r\n  function cover(img, uncover) {\r\n    applyStyle(img.parentElement, {\r\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\r\n    });\r\n    applyStyle(img, {\r\n      display: uncover ? '' : 'none'\r\n    });\r\n  }\r\n\r\n  return Cover;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/arrows/path.js\r\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\r\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\r\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\r\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar SIZE = 40;\r\n;// CONCATENATED MODULE: ./src/js/components/arrows/index.js\r\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const arrows = (function (Splide, Components, name) {\r\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\r\n  var prev;\r\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\r\n\r\n  var next;\r\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var classes = Splide.classes;\r\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\r\n\r\n  var root = Splide.root;\r\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var created;\r\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Arrows = {\r\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: Splide.options.arrows,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      // Attempt to get arrows from HTML source.\r\n      prev = Elements.arrows.prev;\r\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\r\n\r\n      if ((!prev || !next) && Splide.options.arrows) {\r\n        prev = createArrow(true);\r\n        next = createArrow(false);\r\n        created = true;\r\n        appendArrows();\r\n      }\r\n\r\n      if (prev && next) {\r\n        bind();\r\n      }\r\n\r\n      this.arrows = {\r\n        prev: prev,\r\n        next: next\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Called after all components are mounted.\r\n     */\r\n    mounted: function mounted() {\r\n      Splide.emit(name + \":mounted\", prev, next);\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      removeAttribute([prev, next], 'disabled');\r\n\r\n      if (created) {\r\n        dom_remove(prev.parentElement);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Listen to native and custom events.\r\n   */\r\n\r\n  function bind() {\r\n    Splide.on('click', function () {\r\n      Splide.go('<');\r\n    }, prev).on('click', function () {\r\n      Splide.go('>');\r\n    }, next).on('mounted move updated refresh', updateDisabled);\r\n  }\r\n  /**\r\n   * Update a disabled attribute.\r\n   */\r\n\r\n\r\n  function updateDisabled() {\r\n    var _Components$Controlle = Components.Controller,\r\n        prevIndex = _Components$Controlle.prevIndex,\r\n        nextIndex = _Components$Controlle.nextIndex;\r\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\r\n    prev.disabled = prevIndex < 0 || !isEnough;\r\n    next.disabled = nextIndex < 0 || !isEnough;\r\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\r\n  }\r\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\r\n\r\n\r\n  function appendArrows() {\r\n    var wrapper = create('div', {\r\n      \"class\": classes.arrows\r\n    });\r\n    append(wrapper, prev);\r\n    append(wrapper, next);\r\n    var slider = Elements.slider;\r\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\r\n    before(wrapper, parent.firstElementChild);\r\n  }\r\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\r\n\r\n\r\n  function createArrow(prev) {\r\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\r\n    return domify(arrow);\r\n  }\r\n\r\n  return Arrows;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/pagination/index.js\r\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\r\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar UPDATE_EVENT = 'updated.page refresh.page';\r\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const pagination = (function (Splide, Components, name) {\r\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var data = {};\r\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Pagination = {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      var pagination = Splide.options.pagination;\r\n\r\n      if (pagination) {\r\n        data = createPagination();\r\n        var slider = Elements.slider;\r\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\r\n        append(parent, data.list);\r\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\r\n      }\r\n\r\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\r\n        Pagination.destroy();\r\n\r\n        if (Splide.options.pagination) {\r\n          Pagination.mount();\r\n          Pagination.mounted();\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Called after all components are mounted.\r\n     */\r\n    mounted: function mounted() {\r\n      if (Splide.options.pagination) {\r\n        var index = Splide.index;\r\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\r\n        updateAttributes(index, -1);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\r\n    destroy: function destroy() {\r\n      dom_remove(data.list);\r\n\r\n      if (data.items) {\r\n        data.items.forEach(function (item) {\r\n          Splide.off('click', item.button);\r\n        });\r\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\r\n\r\n\r\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\r\n      data = {};\r\n    },\r\n\r\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\r\n    getItem: function getItem(index) {\r\n      return data.items[Components.Controller.toPage(index)];\r\n    },\r\n\r\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\r\n    get data() {\r\n      return data;\r\n    }\r\n\r\n  };\r\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\r\n\r\n  function updateAttributes(index, prevIndex) {\r\n    var prev = Pagination.getItem(prevIndex);\r\n    var curr = Pagination.getItem(index);\r\n    var active = STATUS_CLASSES.active;\r\n\r\n    if (prev) {\r\n      removeClass(prev.button, active);\r\n    }\r\n\r\n    if (curr) {\r\n      addClass(curr.button, active);\r\n    }\r\n\r\n    Splide.emit(name + \":updated\", data, prev, curr);\r\n  }\r\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\r\n\r\n\r\n  function createPagination() {\r\n    var options = Splide.options;\r\n    var classes = Splide.classes;\r\n    var list = create('ul', {\r\n      \"class\": classes.pagination\r\n    });\r\n    var items = Elements.getSlides(false).filter(function (Slide) {\r\n      return options.focus !== false || Slide.index % options.perPage === 0;\r\n    }).map(function (Slide, page) {\r\n      var li = create('li', {});\r\n      var button = create('button', {\r\n        \"class\": classes.page,\r\n        type: 'button'\r\n      });\r\n      append(li, button);\r\n      append(list, li);\r\n      Splide.on('click', function () {\r\n        Splide.go(\">\" + page);\r\n      }, button);\r\n      return {\r\n        li: li,\r\n        button: button,\r\n        page: page,\r\n        Slides: Elements.getSlidesByPage(page)\r\n      };\r\n    });\r\n    return {\r\n      list: list,\r\n      items: items\r\n    };\r\n  }\r\n\r\n  return Pagination;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\r\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar SRC_DATA_NAME = 'data-splide-lazy';\r\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\r\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const lazyload = (function (Splide, Components, name) {\r\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\r\n  var nextIndex;\r\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\r\n\r\n  var images;\r\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var options = Splide.options;\r\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n\r\n  var isSequential = options.lazyLoad === 'sequential';\r\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Lazyload = {\r\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: options.lazyLoad,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Splide.on('mounted refresh', function () {\r\n        init();\r\n        Components.Elements.each(function (Slide) {\r\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\r\n            if (!img.src && !img.srcset) {\r\n              images.push({\r\n                img: img,\r\n                Slide: Slide\r\n              });\r\n              applyStyle(img, {\r\n                display: 'none'\r\n              });\r\n            }\r\n          });\r\n        });\r\n\r\n        if (isSequential) {\r\n          loadNext();\r\n        }\r\n      });\r\n\r\n      if (!isSequential) {\r\n        Splide.on(\"mounted refresh moved.\" + name, check);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: init\r\n  };\r\n  /**\r\n   * Initialize parameters.\r\n   */\r\n\r\n  function init() {\r\n    images = [];\r\n    nextIndex = 0;\r\n  }\r\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\r\n\r\n\r\n  function check(index) {\r\n    index = isNaN(index) ? Splide.index : index;\r\n    images = images.filter(function (image) {\r\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\r\n        load(image.img, image.Slide);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }); // Unbind if all images are loaded.\r\n\r\n    if (!images[0]) {\r\n      Splide.off(\"moved.\" + name);\r\n    }\r\n  }\r\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\r\n\r\n\r\n  function load(img, Slide) {\r\n    addClass(Slide.slide, STATUS_CLASSES.loading);\r\n    var spinner = create('span', {\r\n      \"class\": Splide.classes.spinner\r\n    });\r\n    append(img.parentElement, spinner);\r\n\r\n    img.onload = function () {\r\n      loaded(img, spinner, Slide, false);\r\n    };\r\n\r\n    img.onerror = function () {\r\n      loaded(img, spinner, Slide, true);\r\n    };\r\n\r\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\r\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\r\n  }\r\n  /**\r\n   * Start loading a next image in images array.\r\n   */\r\n\r\n\r\n  function loadNext() {\r\n    if (nextIndex < images.length) {\r\n      var image = images[nextIndex];\r\n      load(image.img, image.Slide);\r\n    }\r\n\r\n    nextIndex++;\r\n  }\r\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\r\n\r\n\r\n  function loaded(img, spinner, Slide, error) {\r\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\r\n\r\n    if (!error) {\r\n      dom_remove(spinner);\r\n      applyStyle(img, {\r\n        display: ''\r\n      });\r\n      Splide.emit(name + \":loaded\", img).emit('resize');\r\n    }\r\n\r\n    if (isSequential) {\r\n      loadNext();\r\n    }\r\n  }\r\n\r\n  return Lazyload;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/constants/a11y.js\r\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\r\nvar ARIA_CURRENRT = 'aria-current';\r\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar ARIA_CONTROLS = 'aria-controls';\r\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar ARIA_LABEL = 'aria-label';\r\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar ARIA_LABELLEDBY = 'aria-labelledby';\r\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar ARIA_HIDDEN = 'aria-hidden';\r\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar TAB_INDEX = 'tabindex';\r\n;// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\r\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\r\n\r\nvar KEY_MAP = {\r\n  ltr: {\r\n    ArrowLeft: '<',\r\n    ArrowRight: '>',\r\n    // For IE.\r\n    Left: '<',\r\n    Right: '>'\r\n  },\r\n  rtl: {\r\n    ArrowLeft: '>',\r\n    ArrowRight: '<',\r\n    // For IE.\r\n    Left: '>',\r\n    Right: '<'\r\n  },\r\n  ttb: {\r\n    ArrowUp: '<',\r\n    ArrowDown: '>',\r\n    // For IE.\r\n    Up: '<',\r\n    Down: '>'\r\n  }\r\n};\r\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const keyboard = (function (Splide) {\r\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\r\n  var target;\r\n  return {\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Splide.on('mounted updated', function () {\r\n        var options = Splide.options;\r\n        var root = Splide.root;\r\n        var map = KEY_MAP[options.direction];\r\n        var keyboard = options.keyboard;\r\n\r\n        if (target) {\r\n          Splide.off('keydown', target);\r\n          removeAttribute(root, TAB_INDEX);\r\n        }\r\n\r\n        if (keyboard) {\r\n          if (keyboard === 'focused') {\r\n            target = root;\r\n            setAttribute(root, TAB_INDEX, 0);\r\n          } else {\r\n            target = document;\r\n          }\r\n\r\n          Splide.on('keydown', function (e) {\r\n            if (map[e.key]) {\r\n              Splide.go(map[e.key]);\r\n            }\r\n          }, target);\r\n        }\r\n      });\r\n    }\r\n  };\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/a11y/index.js\r\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const a11y = (function (Splide, Components) {\r\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var i18n = Splide.i18n;\r\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Elements = Components.Elements;\r\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\r\n\r\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\r\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var A11y = {\r\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: Splide.options.accessibility,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      Splide.on('visible', function (Slide) {\r\n        updateSlide(Slide.slide, true);\r\n      }).on('hidden', function (Slide) {\r\n        updateSlide(Slide.slide, false);\r\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\r\n        removeAttribute(Components.Clones.clones, allAttributes);\r\n      });\r\n\r\n      if (Splide.options.isNavigation) {\r\n        Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\r\n          updateNavigation(Slide, true);\r\n        }).on('inactive', function (Slide) {\r\n          updateNavigation(Slide, false);\r\n        });\r\n      }\r\n\r\n      initAutoplay();\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     */\r\n    destroy: function destroy() {\r\n      var Arrows = Components.Arrows;\r\n      var arrows = Arrows ? Arrows.arrows : {};\r\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\r\n    }\r\n  };\r\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\r\n\r\n  function updateSlide(slide, visible) {\r\n    setAttribute(slide, ARIA_HIDDEN, !visible);\r\n\r\n    if (Splide.options.slideFocus) {\r\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\r\n    }\r\n  }\r\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\r\n\r\n\r\n  function initArrows(prev, next) {\r\n    var controls = Elements.track.id;\r\n    setAttribute(prev, ARIA_CONTROLS, controls);\r\n    setAttribute(next, ARIA_CONTROLS, controls);\r\n  }\r\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\r\n\r\n\r\n  function updateArrows(prev, next, prevIndex, nextIndex) {\r\n    var index = Splide.index;\r\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\r\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\r\n    setAttribute(prev, ARIA_LABEL, prevLabel);\r\n    setAttribute(next, ARIA_LABEL, nextLabel);\r\n  }\r\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\r\n\r\n\r\n  function initPagination(data, activeItem) {\r\n    if (activeItem) {\r\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\r\n    }\r\n\r\n    data.items.forEach(function (item) {\r\n      var options = Splide.options;\r\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\r\n      var label = sprintf(text, item.page + 1);\r\n      var button = item.button;\r\n      var controls = item.Slides.map(function (Slide) {\r\n        return Slide.slide.id;\r\n      });\r\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\r\n      setAttribute(button, ARIA_LABEL, label);\r\n    });\r\n  }\r\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\r\n\r\n\r\n  function updatePagination(data, prev, curr) {\r\n    if (prev) {\r\n      removeAttribute(prev.button, ARIA_CURRENRT);\r\n    }\r\n\r\n    if (curr) {\r\n      setAttribute(curr.button, ARIA_CURRENRT, true);\r\n    }\r\n  }\r\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\r\n\r\n\r\n  function initAutoplay() {\r\n    ['play', 'pause'].forEach(function (name) {\r\n      var elm = Elements[name];\r\n\r\n      if (elm) {\r\n        if (!isButton(elm)) {\r\n          setAttribute(elm, 'role', 'button');\r\n        }\r\n\r\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\r\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\r\n\r\n\r\n  function initNavigation(main) {\r\n    Elements.each(function (Slide) {\r\n      var slide = Slide.slide;\r\n      var realIndex = Slide.realIndex;\r\n\r\n      if (!isButton(slide)) {\r\n        setAttribute(slide, 'role', 'button');\r\n      }\r\n\r\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\r\n      var label = sprintf(i18n.slideX, slideIndex + 1);\r\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\r\n      setAttribute(slide, ARIA_LABEL, label);\r\n\r\n      if (mainSlide) {\r\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\r\n\r\n\r\n  function updateNavigation(_ref, active) {\r\n    var slide = _ref.slide;\r\n\r\n    if (active) {\r\n      setAttribute(slide, ARIA_CURRENRT, true);\r\n    } else {\r\n      removeAttribute(slide, ARIA_CURRENRT);\r\n    }\r\n  }\r\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\r\n\r\n\r\n  function isButton(elm) {\r\n    return elm.tagName === 'BUTTON';\r\n  }\r\n\r\n  return A11y;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/sync/index.js\r\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\r\n\r\nvar SYNC_EVENT = 'move.sync';\r\n/**\r\n * The event names for click navigation.\r\n * @type {string}\r\n */\r\n\r\nvar CLICK_EVENTS = 'mouseup touchend';\r\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\r\n\r\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\r\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const sync = (function (Splide) {\r\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\r\n  var sibling = Splide.sibling;\r\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\r\n\r\n  var isNavigation = sibling && sibling.options.isNavigation;\r\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Sync = {\r\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: !!sibling,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      syncMain();\r\n      syncSibling();\r\n\r\n      if (isNavigation) {\r\n        bind();\r\n        Splide.on('refresh', function () {\r\n          setTimeout(function () {\r\n            bind();\r\n            sibling.emit('navigation:updated', Splide);\r\n          });\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Called after all components are mounted.\r\n     */\r\n    mounted: function mounted() {\r\n      if (isNavigation) {\r\n        sibling.emit('navigation:mounted', Splide);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\r\n\r\n  function syncMain() {\r\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\r\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\r\n      syncSibling();\r\n    });\r\n  }\r\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\r\n\r\n\r\n  function syncSibling() {\r\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\r\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\r\n      syncMain();\r\n    });\r\n  }\r\n  /**\r\n   * Listen some events on each slide.\r\n   */\r\n\r\n\r\n  function bind() {\r\n    sibling.Components.Elements.each(function (_ref) {\r\n      var slide = _ref.slide,\r\n          index = _ref.index;\r\n\r\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\r\n      Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\r\n        // Ignore a middle or right click.\r\n        if (!e.button || e.button === 0) {\r\n          moveSibling(index);\r\n        }\r\n      }, slide);\r\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\r\n\r\n      Splide.off('keyup', slide).on('keyup', function (e) {\r\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\r\n          e.preventDefault();\r\n          moveSibling(index);\r\n        }\r\n      }, slide, {\r\n        passive: false\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\r\n\r\n\r\n  function moveSibling(index) {\r\n    if (Splide.State.is(IDLE)) {\r\n      sibling.go(index);\r\n    }\r\n  }\r\n\r\n  return Sync;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\r\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\r\n\r\nvar THROTTLE = 50;\r\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\r\n\r\n/* harmony default export */ const breakpoints = (function (Splide) {\r\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\r\n  var breakpoints = Splide.options.breakpoints;\r\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\r\n\r\n  var throttledCheck = throttle(check, THROTTLE);\r\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var initialOptions;\r\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\r\n\r\n  var map = [];\r\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\r\n\r\n  var prevPoint;\r\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\r\n\r\n  var Breakpoints = {\r\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    required: breakpoints && matchMedia,\r\n\r\n    /**\r\n     * Called when the component is mounted.\r\n     */\r\n    mount: function mount() {\r\n      map = Object.keys(breakpoints).sort(function (n, m) {\r\n        return +n - +m;\r\n      }).map(function (point) {\r\n        return {\r\n          point: point,\r\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\r\n        };\r\n      });\r\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\r\n\r\n      this.destroy(true);\r\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\r\n\r\n      initialOptions = Splide.options;\r\n      check();\r\n    },\r\n\r\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\r\n    destroy: function destroy(completely) {\r\n      if (completely) {\r\n        removeEventListener('resize', throttledCheck);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Check the breakpoint.\r\n   */\r\n\r\n  function check() {\r\n    var point = getPoint();\r\n\r\n    if (point !== prevPoint) {\r\n      prevPoint = point;\r\n      var State = Splide.State;\r\n      var options = breakpoints[point] || initialOptions;\r\n      var destroy = options.destroy;\r\n\r\n      if (destroy) {\r\n        Splide.options = initialOptions;\r\n        Splide.destroy(destroy === 'completely');\r\n      } else {\r\n        if (State.is(DESTROYED)) {\r\n          Splide.mount();\r\n        }\r\n\r\n        Splide.options = options;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\r\n\r\n\r\n  function getPoint() {\r\n    var item = map.filter(function (item) {\r\n      return item.mql.matches;\r\n    })[0];\r\n    return item ? item.point : -1;\r\n  }\r\n\r\n  return Breakpoints;\r\n});\r\n;// CONCATENATED MODULE: ./src/js/components/index.js\r\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar COMPLETE = {\r\n  Options: options,\r\n  Breakpoints: breakpoints,\r\n  Controller: controller,\r\n  Elements: components_elements,\r\n  Track: track,\r\n  Clones: clones,\r\n  Layout: layout,\r\n  Drag: drag,\r\n  Click: click,\r\n  Autoplay: autoplay,\r\n  Cover: cover,\r\n  Arrows: arrows,\r\n  Pagination: pagination,\r\n  LazyLoad: lazyload,\r\n  Keyboard: keyboard,\r\n  Sync: sync,\r\n  A11y: a11y\r\n};\r\nvar LIGHT = {\r\n  Options: options,\r\n  Controller: controller,\r\n  Elements: components_elements,\r\n  Track: track,\r\n  Clones: clones,\r\n  Layout: layout,\r\n  Drag: drag,\r\n  Click: click,\r\n  Arrows: arrows,\r\n  Pagination: pagination,\r\n  A11y: a11y\r\n};\r\n;// CONCATENATED MODULE: ./build/module/module.js\r\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\r\n\r\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\r\n\r\n\r\n/**\r\n * Export Splide class for import from other projects.\r\n */\r\n\r\nvar module_Splide = /*#__PURE__*/function (_Core) {\r\n  _inheritsLoose(Splide, _Core);\r\n\r\n  function Splide(root, options) {\r\n    return _Core.call(this, root, options, COMPLETE) || this;\r\n  }\r\n\r\n  return Splide;\r\n}(Splide);\r\n\r\n\r\n\r\n/***/ })\r\n\r\n/******/ \t});\r\n/************************************************************************/\r\n/******/ \t// The module cache\r\n/******/ \tvar __webpack_module_cache__ = {};\r\n/******/ \t\r\n/******/ \t// The require function\r\n/******/ \tfunction __webpack_require__(moduleId) {\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\r\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\r\n/******/ \t\t\t// no module.id needed\r\n/******/ \t\t\t// no module.loaded needed\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/ \t\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\r\n/******/ \t\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/ \t\r\n/************************************************************************/\r\n/******/ \t/* webpack/runtime/define property getters */\r\n/******/ \t(() => {\r\n/******/ \t\t// define getter functions for harmony exports\r\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\r\n/******/ \t\t\tfor(var key in definition) {\r\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\r\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t};\r\n/******/ \t})();\r\n/******/ \t\r\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\r\n/******/ \t(() => {\r\n/******/ \t\t__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\r\n/******/ \t})();\r\n/******/ \t\r\n/******/ \t/* webpack/runtime/make namespace object */\r\n/******/ \t(() => {\r\n/******/ \t\t// define __esModule on exports\r\n/******/ \t\t__webpack_require__.r = (exports) => {\r\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t\t}\r\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t\t};\r\n/******/ \t})();\r\n/******/ \t\r\n/************************************************************************/\r\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\r\n/******/ \t// startup\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __webpack_require__(311);\r\n/******/ })()\r\n;\r\n});"]},"metadata":{},"sourceType":"script"}