{"ast":null,"code":"/*\r\n * libpannellum - A WebGL and CSS 3D transform based Panorama Renderer\r\n * Copyright (c) 2012-2018 Matthew Petroff\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\nwindow.libpannellum = function (window, document, undefined) {\n  /**\r\n  * Creates a new panorama renderer.\r\n  * @constructor\r\n  * @param {HTMLElement} container - The container element for the renderer.\r\n  */\n  function Renderer(container) {\n    var canvas = document.createElement('canvas');\n    canvas.style.width = canvas.style.height = '100%';\n    container.appendChild(canvas);\n    var program, gl, vs, fs;\n    var fallbackImgSize;\n    var world;\n    var vtmps;\n    var pose;\n    var image, imageType, dynamic;\n    var texCoordBuffer, cubeVertBuf, cubeVertTexCoordBuf, cubeVertIndBuf;\n    var globalParams;\n    /**\r\n     * Initialize renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {Image|Array|Object} image - Input image; format varies based on\r\n     *      `imageType`. For `equirectangular`, this is an image; for\r\n     *      `cubemap`, this is an array of images for the cube faces in the\r\n     *      order [+z, +x, -z, -x, +y, -y]; for `multires`, this is a\r\n     *      configuration object.\r\n     * @param {string} imageType - The type of the image: `equirectangular`,\r\n     *      `cubemap`, or `multires`.\r\n     * @param {boolean} dynamic - Whether or not the image is dynamic (e.g. video).\r\n     * @param {number} haov - Initial horizontal angle of view.\r\n     * @param {number} vaov - Initial vertical angle of view.\r\n     * @param {number} voffset - Initial vertical offset angle.\r\n     * @param {function} callback - Load callback function.\r\n     * @param {Object} [params] - Other configuration parameters (`horizonPitch`, `horizonRoll`, `backgroundColor`).\r\n     */\n\n    this.init = function (_image, _imageType, _dynamic, haov, vaov, voffset, callback, params) {\n      // Default argument for image type\n      if (_imageType === undefined) {\n        _imageType = 'equirectangular';\n      }\n\n      if (_imageType != 'equirectangular' && _imageType != 'cubemap' && _imageType != 'multires') {\n        console.log('Error: invalid image type specified!');\n        throw {\n          type: 'config error'\n        };\n      }\n\n      imageType = _imageType;\n      image = _image;\n      dynamic = _dynamic;\n      globalParams = params || {}; // Clear old data\n\n      if (program) {\n        if (vs) {\n          gl.detachShader(program, vs);\n          gl.deleteShader(vs);\n        }\n\n        if (fs) {\n          gl.detachShader(program, fs);\n          gl.deleteShader(fs);\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n        if (program.texture) {\n          gl.deleteTexture(program.texture);\n        }\n\n        if (program.nodeCache) {\n          for (var i = 0; i < program.nodeCache.length; i++) {\n            gl.deleteTexture(program.nodeCache[i].texture);\n          }\n        }\n\n        gl.deleteProgram(program);\n        program = undefined;\n      }\n\n      pose = undefined;\n      var s;\n      var faceMissing = false;\n      var cubeImgWidth;\n\n      if (imageType == 'cubemap') {\n        for (s = 0; s < 6; s++) {\n          if (image[s].width > 0) {\n            if (cubeImgWidth === undefined) {\n              cubeImgWidth = image[s].width;\n            }\n\n            if (cubeImgWidth != image[s].width) {\n              console.log('Cube faces have inconsistent widths: ' + cubeImgWidth + ' vs. ' + image[s].width);\n            }\n          } else {\n            faceMissing = true;\n          }\n        }\n      }\n\n      function fillMissingFaces(imgSize) {\n        if (faceMissing) {\n          // Fill any missing fallback/cubemap faces with background\n          var nbytes = imgSize * imgSize * 4; // RGB, plus non-functional alpha\n\n          var imageArray = new Uint8ClampedArray(nbytes);\n          var rgb = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\n          rgb[0] *= 255;\n          rgb[1] *= 255;\n          rgb[2] *= 255; // Maybe filling could be done faster, see e.g. https://stackoverflow.com/questions/1295584/most-efficient-way-to-create-a-zero-filled-javascript-array\n\n          for (var i = 0; i < nbytes; i++) {\n            imageArray[i++] = rgb[0];\n            imageArray[i++] = rgb[1];\n            imageArray[i++] = rgb[2];\n          }\n\n          var backgroundSquare = new ImageData(imageArray, imgSize, imgSize);\n\n          for (s = 0; s < 6; s++) {\n            if (image[s].width == 0) {\n              image[s] = backgroundSquare;\n            }\n          }\n        }\n      } // This awful browser specific test exists because iOS 8/9 and IE 11\n      // don't display non-power-of-two cubemap textures but also don't\n      // throw an error (tested on an iPhone 5c / iOS 8.1.3 / iOS 9.2 /\n      // iOS 10.3.1).\n      // Therefore, the WebGL context is never created for these browsers for\n      // NPOT cubemaps, and the CSS 3D transform fallback renderer is used\n      // instead.\n\n\n      if (!(imageType == 'cubemap' && (cubeImgWidth & cubeImgWidth - 1) !== 0 && (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 9_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 10_/) || navigator.userAgent.match(/Trident.*rv[ :]*11\\./)))) {\n        // Enable WebGL on canvas\n        if (!gl) {\n          gl = canvas.getContext('experimental-webgl', {\n            alpha: false,\n            depth: false\n          });\n        }\n\n        if (gl && gl.getError() == 1286) {\n          handleWebGLError1286();\n        }\n      } // If there is no WebGL, fall back to CSS 3D transform renderer.\n      // This will discard the image loaded so far and load the fallback image.\n      // While browser specific tests are usually frowned upon, the\n      // fallback viewer only really works with WebKit/Blink and IE 10/11\n      // (it doesn't work properly in Firefox).\n\n\n      if (!gl && (imageType == 'multires' && image.hasOwnProperty('fallbackPath') || imageType == 'cubemap') && ('WebkitAppearance' in document.documentElement.style || navigator.userAgent.match(/Trident.*rv[ :]*11\\./) || navigator.appVersion.indexOf('MSIE 10') !== -1)) {\n        // Remove old world if it exists\n        if (world) {\n          container.removeChild(world);\n        } // Initialize renderer\n\n\n        world = document.createElement('div');\n        world.className = 'pnlm-world'; // Add images\n\n        var path;\n\n        if (image.basePath) {\n          path = image.basePath + image.fallbackPath;\n        } else {\n          path = image.fallbackPath;\n        }\n\n        var sides = ['f', 'r', 'b', 'l', 'u', 'd'];\n        var loaded = 0;\n\n        var onLoad = function onLoad() {\n          // Draw image on canvas\n          var faceCanvas = document.createElement('canvas');\n          faceCanvas.className = 'pnlm-face pnlm-' + sides[this.side] + 'face';\n          world.appendChild(faceCanvas);\n          var faceContext = faceCanvas.getContext('2d');\n          faceCanvas.style.width = this.width + 4 + 'px';\n          faceCanvas.style.height = this.height + 4 + 'px';\n          faceCanvas.width = this.width + 4;\n          faceCanvas.height = this.height + 4;\n          faceContext.drawImage(this, 2, 2);\n          var imgData = faceContext.getImageData(0, 0, faceCanvas.width, faceCanvas.height);\n          var data = imgData.data; // Duplicate edge pixels\n\n          var i;\n          var j;\n\n          for (i = 2; i < faceCanvas.width - 2; i++) {\n            for (j = 0; j < 4; j++) {\n              data[(i + faceCanvas.width) * 4 + j] = data[(i + faceCanvas.width * 2) * 4 + j];\n              data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 3)) * 4 + j];\n            }\n          }\n\n          for (i = 2; i < faceCanvas.height - 2; i++) {\n            for (j = 0; j < 4; j++) {\n              data[(i * faceCanvas.width + 1) * 4 + j] = data[(i * faceCanvas.width + 2) * 4 + j];\n              data[((i + 1) * faceCanvas.width - 2) * 4 + j] = data[((i + 1) * faceCanvas.width - 3) * 4 + j];\n            }\n          }\n\n          for (j = 0; j < 4; j++) {\n            data[(faceCanvas.width + 1) * 4 + j] = data[(faceCanvas.width * 2 + 2) * 4 + j];\n            data[(faceCanvas.width * 2 - 2) * 4 + j] = data[(faceCanvas.width * 3 - 3) * 4 + j];\n            data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 3) + 2) * 4 + j];\n            data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) - 3) * 4 + j];\n          }\n\n          for (i = 1; i < faceCanvas.width - 1; i++) {\n            for (j = 0; j < 4; j++) {\n              data[i * 4 + j] = data[(i + faceCanvas.width) * 4 + j];\n              data[(i + faceCanvas.width * (faceCanvas.height - 1)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j];\n            }\n          }\n\n          for (i = 1; i < faceCanvas.height - 1; i++) {\n            for (j = 0; j < 4; j++) {\n              data[i * faceCanvas.width * 4 + j] = data[(i * faceCanvas.width + 1) * 4 + j];\n              data[((i + 1) * faceCanvas.width - 1) * 4 + j] = data[((i + 1) * faceCanvas.width - 2) * 4 + j];\n            }\n          }\n\n          for (j = 0; j < 4; j++) {\n            data[j] = data[(faceCanvas.width + 1) * 4 + j];\n            data[(faceCanvas.width - 1) * 4 + j] = data[(faceCanvas.width * 2 - 2) * 4 + j];\n            data[faceCanvas.width * (faceCanvas.height - 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j];\n            data[(faceCanvas.width * faceCanvas.height - 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j];\n          } // Draw image width duplicated edge pixels on canvas\n\n\n          faceContext.putImageData(imgData, 0, 0);\n          incLoaded.call(this);\n        };\n\n        var incLoaded = function incLoaded() {\n          if (this.width > 0) {\n            if (fallbackImgSize === undefined) {\n              fallbackImgSize = this.width;\n            }\n\n            if (fallbackImgSize != this.width) {\n              console.log('Fallback faces have inconsistent widths: ' + fallbackImgSize + ' vs. ' + this.width);\n            }\n          } else {\n            faceMissing = true;\n          }\n\n          loaded++;\n\n          if (loaded == 6) {\n            fallbackImgSize = this.width;\n            container.appendChild(world);\n            callback();\n          }\n        };\n\n        faceMissing = false;\n\n        for (s = 0; s < 6; s++) {\n          var faceImg = new Image();\n          faceImg.crossOrigin = globalParams.crossOrigin ? globalParams.crossOrigin : 'anonymous';\n          faceImg.side = s;\n          faceImg.onload = onLoad;\n          faceImg.onerror = incLoaded; // ignore missing face to support partial fallback image\n\n          if (imageType == 'multires') {\n            faceImg.src = encodeURI(path.replace('%s', sides[s]) + '.' + image.extension);\n          } else {\n            faceImg.src = encodeURI(image[s].src);\n          }\n        }\n\n        fillMissingFaces(fallbackImgSize);\n        return;\n      } else if (!gl) {\n        console.log('Error: no WebGL support detected!');\n        throw {\n          type: 'no webgl'\n        };\n      }\n\n      if (imageType == 'cubemap') {\n        fillMissingFaces(cubeImgWidth);\n      }\n\n      if (image.basePath) {\n        image.fullpath = image.basePath + image.path;\n      } else {\n        image.fullpath = image.path;\n      }\n\n      image.invTileResolution = 1 / image.tileResolution;\n      var vertices = createCube();\n      vtmps = [];\n\n      for (s = 0; s < 6; s++) {\n        vtmps[s] = vertices.slice(s * 12, s * 12 + 12);\n        vertices = createCube();\n      } // Make sure image isn't too big\n\n\n      var width = 0,\n          maxWidth = 0;\n\n      if (imageType == 'equirectangular') {\n        width = Math.max(image.width, image.height);\n        maxWidth = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      } else if (imageType == 'cubemap') {\n        width = cubeImgWidth;\n        maxWidth = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n      }\n\n      if (width > maxWidth) {\n        console.log('Error: The image is too big; it\\'s ' + width + 'px wide, ' + 'but this device\\'s maximum supported size is ' + maxWidth + 'px.');\n        throw {\n          type: 'webgl size error',\n          width: width,\n          maxWidth: maxWidth\n        };\n      } // Store horizon pitch and roll if applicable\n\n\n      if (params !== undefined && (params.horizonPitch !== undefined || params.horizonRoll !== undefined)) {\n        pose = [params.horizonPitch == undefined ? 0 : params.horizonPitch, params.horizonRoll == undefined ? 0 : params.horizonRoll];\n      } // Set 2d texture binding\n\n\n      var glBindType = gl.TEXTURE_2D; // Create viewport for entire canvas\n\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); // Create vertex shader\n\n      vs = gl.createShader(gl.VERTEX_SHADER);\n      var vertexSrc = v;\n\n      if (imageType == 'multires') {\n        vertexSrc = vMulti;\n      }\n\n      gl.shaderSource(vs, vertexSrc);\n      gl.compileShader(vs); // Create fragment shader\n\n      fs = gl.createShader(gl.FRAGMENT_SHADER);\n      var fragmentSrc = fragEquirectangular;\n\n      if (imageType == 'cubemap') {\n        glBindType = gl.TEXTURE_CUBE_MAP;\n        fragmentSrc = fragCube;\n      } else if (imageType == 'multires') {\n        fragmentSrc = fragMulti;\n      }\n\n      gl.shaderSource(fs, fragmentSrc);\n      gl.compileShader(fs); // Link WebGL program\n\n      program = gl.createProgram();\n      gl.attachShader(program, vs);\n      gl.attachShader(program, fs);\n      gl.linkProgram(program); // Log errors\n\n      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n        console.log(gl.getShaderInfoLog(vs));\n      }\n\n      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n        console.log(gl.getShaderInfoLog(fs));\n      }\n\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.log(gl.getProgramInfoLog(program));\n      } // Use WebGL program\n\n\n      gl.useProgram(program);\n      program.drawInProgress = false; // Set background clear color (does not apply to cubemap/fallback image)\n\n      var color = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\n      gl.clearColor(color[0], color[1], color[2], 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT); // Look up texture coordinates location\n\n      program.texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');\n      gl.enableVertexAttribArray(program.texCoordLocation);\n\n      if (imageType != 'multires') {\n        // Provide texture coordinates for rectangle\n        if (!texCoordBuffer) {\n          texCoordBuffer = gl.createBuffer();\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);\n        gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0); // Pass aspect ratio\n\n        program.aspectRatio = gl.getUniformLocation(program, 'u_aspectRatio');\n        gl.uniform1f(program.aspectRatio, gl.drawingBufferWidth / gl.drawingBufferHeight); // Locate psi, theta, focal length, horizontal extent, vertical extent, and vertical offset\n\n        program.psi = gl.getUniformLocation(program, 'u_psi');\n        program.theta = gl.getUniformLocation(program, 'u_theta');\n        program.f = gl.getUniformLocation(program, 'u_f');\n        program.h = gl.getUniformLocation(program, 'u_h');\n        program.v = gl.getUniformLocation(program, 'u_v');\n        program.vo = gl.getUniformLocation(program, 'u_vo');\n        program.rot = gl.getUniformLocation(program, 'u_rot'); // Pass horizontal extent, vertical extent, and vertical offset\n\n        gl.uniform1f(program.h, haov / (Math.PI * 2.0));\n        gl.uniform1f(program.v, vaov / Math.PI);\n        gl.uniform1f(program.vo, voffset / Math.PI * 2); // Set background color\n\n        if (imageType == 'equirectangular') {\n          program.backgroundColor = gl.getUniformLocation(program, 'u_backgroundColor');\n          gl.uniform4fv(program.backgroundColor, color.concat([1]));\n        } // Create texture\n\n\n        program.texture = gl.createTexture();\n        gl.bindTexture(glBindType, program.texture); // Upload images to texture depending on type\n\n        if (imageType == 'cubemap') {\n          // Load all six sides of the cube map\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[1]);\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[3]);\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[4]);\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[5]);\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[0]);\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[2]);\n        } else {\n          // Upload image to the texture\n          gl.texImage2D(glBindType, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n        } // Set parameters for rendering any size\n\n\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(glBindType, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(glBindType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      } else {\n        // Look up vertex coordinates location\n        program.vertPosLocation = gl.getAttribLocation(program, 'a_vertCoord');\n        gl.enableVertexAttribArray(program.vertPosLocation); // Create buffers\n\n        if (!cubeVertBuf) {\n          cubeVertBuf = gl.createBuffer();\n        }\n\n        if (!cubeVertTexCoordBuf) {\n          cubeVertTexCoordBuf = gl.createBuffer();\n        }\n\n        if (!cubeVertIndBuf) {\n          cubeVertIndBuf = gl.createBuffer();\n        } // Bind texture coordinate buffer and pass coordinates to WebGL\n\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), gl.STATIC_DRAW); // Bind square index buffer and pass indicies to WebGL\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertIndBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW); // Find uniforms\n\n        program.perspUniform = gl.getUniformLocation(program, 'u_perspMatrix');\n        program.cubeUniform = gl.getUniformLocation(program, 'u_cubeMatrix'); //program.colorUniform = gl.getUniformLocation(program, 'u_color');\n\n        program.level = -1;\n        program.currentNodes = [];\n        program.nodeCache = [];\n        program.nodeCacheTimestamp = 0;\n      } // Check if there was an error\n\n\n      var err = gl.getError();\n\n      if (err !== 0) {\n        console.log('Error: Something went wrong with WebGL!', err);\n        throw {\n          type: 'webgl error'\n        };\n      }\n\n      callback();\n    };\n    /**\r\n     * Destroy renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\n\n\n    this.destroy = function () {\n      if (container !== undefined) {\n        if (canvas !== undefined && container.contains(canvas)) {\n          container.removeChild(canvas);\n        }\n\n        if (world !== undefined && container.contains(world)) {\n          container.removeChild(world);\n        }\n      }\n\n      if (gl) {\n        // The spec says this is only supposed to simulate losing the WebGL\n        // context, but in practice it tends to actually free the memory.\n        var extension = gl.getExtension('WEBGL_lose_context');\n\n        if (extension) {\n          extension.loseContext();\n        }\n      }\n    };\n    /**\r\n     * Resize renderer (call after resizing container).\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\n\n\n    this.resize = function () {\n      var pixelRatio = window.devicePixelRatio || 1;\n      canvas.width = canvas.clientWidth * pixelRatio;\n      canvas.height = canvas.clientHeight * pixelRatio;\n\n      if (gl) {\n        if (gl.getError() == 1286) {\n          handleWebGLError1286();\n        }\n\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n        if (imageType != 'multires') {\n          gl.uniform1f(program.aspectRatio, canvas.clientWidth / canvas.clientHeight);\n        }\n      }\n    }; // Initialize canvas size\n\n\n    this.resize();\n    /**\r\n     * Set renderer horizon pitch and roll.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\n\n    this.setPose = function (horizonPitch, horizonRoll) {\n      pose = [horizonPitch, horizonRoll];\n    };\n    /**\r\n     * Render new view of panorama.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {number} pitch - Pitch to render at (in radians).\r\n     * @param {number} yaw - Yaw to render at (in radians).\r\n     * @param {number} hfov - Horizontal field of view to render with (in radians).\r\n     * @param {Object} [params] - Extra configuration parameters. \r\n     * @param {number} [params.roll] - Camera roll (in radians).\r\n     * @param {boolean} [params.returnImage] - Return rendered image?\r\n     */\n\n\n    this.render = function (pitch, yaw, hfov, params) {\n      var focal,\n          i,\n          s,\n          roll = 0;\n\n      if (params === undefined) {\n        params = {};\n      }\n\n      if (params.roll) {\n        roll = params.roll;\n      } // Apply pitch and roll transformation if applicable\n\n\n      if (pose !== undefined) {\n        var horizonPitch = pose[0],\n            horizonRoll = pose[1]; // Calculate new pitch and yaw\n\n        var orig_pitch = pitch,\n            orig_yaw = yaw,\n            x = Math.cos(horizonRoll) * Math.sin(pitch) * Math.sin(horizonPitch) + Math.cos(pitch) * (Math.cos(horizonPitch) * Math.cos(yaw) + Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.sin(yaw)),\n            y = -Math.sin(pitch) * Math.sin(horizonRoll) + Math.cos(pitch) * Math.cos(horizonRoll) * Math.sin(yaw),\n            z = Math.cos(horizonRoll) * Math.cos(horizonPitch) * Math.sin(pitch) + Math.cos(pitch) * (-Math.cos(yaw) * Math.sin(horizonPitch) + Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.sin(yaw));\n        pitch = Math.asin(Math.max(Math.min(z, 1), -1));\n        yaw = Math.atan2(y, x); // Calculate roll\n\n        var v = [Math.cos(orig_pitch) * (Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.cos(orig_yaw) - Math.cos(horizonPitch) * Math.sin(orig_yaw)), Math.cos(orig_pitch) * Math.cos(horizonRoll) * Math.cos(orig_yaw), Math.cos(orig_pitch) * (Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.cos(orig_yaw) + Math.sin(orig_yaw) * Math.sin(horizonPitch))],\n            w = [-Math.cos(pitch) * Math.sin(yaw), Math.cos(pitch) * Math.cos(yaw)];\n        var roll_adj = Math.acos(Math.max(Math.min((v[0] * w[0] + v[1] * w[1]) / (Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) * Math.sqrt(w[0] * w[0] + w[1] * w[1])), 1), -1));\n\n        if (v[2] < 0) {\n          roll_adj = 2 * Math.PI - roll_adj;\n        }\n\n        roll += roll_adj;\n      } // If no WebGL\n\n\n      if (!gl && (imageType == 'multires' || imageType == 'cubemap')) {\n        // Determine face transforms\n        s = fallbackImgSize / 2;\n        var transforms = {\n          f: 'translate3d(-' + (s + 2) + 'px, -' + (s + 2) + 'px, -' + s + 'px)',\n          b: 'translate3d(' + (s + 2) + 'px, -' + (s + 2) + 'px, ' + s + 'px) rotateX(180deg) rotateZ(180deg)',\n          u: 'translate3d(-' + (s + 2) + 'px, -' + s + 'px, ' + (s + 2) + 'px) rotateX(270deg)',\n          d: 'translate3d(-' + (s + 2) + 'px, ' + s + 'px, -' + (s + 2) + 'px) rotateX(90deg)',\n          l: 'translate3d(-' + s + 'px, -' + (s + 2) + 'px, ' + (s + 2) + 'px) rotateX(180deg) rotateY(90deg) rotateZ(180deg)',\n          r: 'translate3d(' + s + 'px, -' + (s + 2) + 'px, -' + (s + 2) + 'px) rotateY(270deg)'\n        };\n        focal = 1 / Math.tan(hfov / 2);\n        var zoom = focal * canvas.clientWidth / 2 + 'px';\n        var transform = 'perspective(' + zoom + ') translateZ(' + zoom + ') rotateX(' + pitch + 'rad) rotateY(' + yaw + 'rad) '; // Apply face transforms\n\n        var faces = Object.keys(transforms);\n\n        for (i = 0; i < 6; i++) {\n          var face = world.querySelector('.pnlm-' + faces[i] + 'face');\n\n          if (!face) {\n            continue;\n          } // ignore missing face to support partial cubemap/fallback image\n\n\n          face.style.webkitTransform = transform + transforms[faces[i]];\n          face.style.transform = transform + transforms[faces[i]];\n        }\n\n        return;\n      }\n\n      if (imageType != 'multires') {\n        // Calculate focal length from vertical field of view\n        var vfov = 2 * Math.atan(Math.tan(hfov * 0.5) / (gl.drawingBufferWidth / gl.drawingBufferHeight));\n        focal = 1 / Math.tan(vfov * 0.5); // Pass psi, theta, roll, and focal length\n\n        gl.uniform1f(program.psi, yaw);\n        gl.uniform1f(program.theta, pitch);\n        gl.uniform1f(program.rot, roll);\n        gl.uniform1f(program.f, focal);\n\n        if (dynamic === true) {\n          // Update texture if dynamic\n          if (imageType == 'equirectangular') {\n            gl.bindTexture(gl.TEXTURE_2D, program.texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n          }\n        } // Draw using current buffer\n\n\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n      } else {\n        // Create perspective matrix\n        var perspMatrix = makePersp(hfov, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 100.0); // Find correct zoom level\n\n        checkZoom(hfov); // Create rotation matrix\n\n        var matrix = identityMatrix3();\n        matrix = rotateMatrix(matrix, -roll, 'z');\n        matrix = rotateMatrix(matrix, -pitch, 'x');\n        matrix = rotateMatrix(matrix, yaw, 'y');\n        matrix = makeMatrix4(matrix); // Set matrix uniforms\n\n        gl.uniformMatrix4fv(program.perspUniform, false, new Float32Array(transposeMatrix4(perspMatrix)));\n        gl.uniformMatrix4fv(program.cubeUniform, false, new Float32Array(transposeMatrix4(matrix))); // Find current nodes\n\n        var rotPersp = rotatePersp(perspMatrix, matrix);\n        program.nodeCache.sort(multiresNodeSort);\n\n        if (program.nodeCache.length > 200 && program.nodeCache.length > program.currentNodes.length + 50) {\n          // Remove older nodes from cache\n          var removed = program.nodeCache.splice(200, program.nodeCache.length - 200);\n\n          for (var i = 0; i < removed.length; i++) {\n            // Explicitly delete textures\n            gl.deleteTexture(removed[i].texture);\n          }\n        }\n\n        program.currentNodes = [];\n        var sides = ['f', 'b', 'u', 'd', 'l', 'r'];\n\n        for (s = 0; s < 6; s++) {\n          var ntmp = new MultiresNode(vtmps[s], sides[s], 1, 0, 0, image.fullpath);\n          testMultiresNode(rotPersp, ntmp, pitch, yaw, hfov);\n        }\n\n        program.currentNodes.sort(multiresNodeRenderSort); // Unqueue any pending requests for nodes that are no longer visible\n\n        for (i = pendingTextureRequests.length - 1; i >= 0; i--) {\n          if (program.currentNodes.indexOf(pendingTextureRequests[i].node) === -1) {\n            pendingTextureRequests[i].node.textureLoad = false;\n            pendingTextureRequests.splice(i, 1);\n          }\n        } // Allow one request to be pending, so that we can create a texture buffer for that in advance of loading actually beginning\n\n\n        if (pendingTextureRequests.length === 0) {\n          for (i = 0; i < program.currentNodes.length; i++) {\n            var node = program.currentNodes[i];\n\n            if (!node.texture && !node.textureLoad) {\n              node.textureLoad = true;\n              setTimeout(processNextTile, 0, node); // Only process one tile per frame to improve responsiveness\n\n              break;\n            }\n          }\n        } // Draw tiles\n\n\n        multiresDraw();\n      }\n\n      if (params.returnImage !== undefined) {\n        return canvas.toDataURL('image/png');\n      }\n    };\n    /**\r\n     * Check if images are loading.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {boolean} Whether or not images are loading.\r\n     */\n\n\n    this.isLoading = function () {\n      if (gl && imageType == 'multires') {\n        for (var i = 0; i < program.currentNodes.length; i++) {\n          if (!program.currentNodes[i].textureLoaded) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n    /**\r\n     * Retrieve renderer's canvas.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {HTMLElement} Renderer's canvas.\r\n     */\n\n\n    this.getCanvas = function () {\n      return canvas;\n    };\n    /**\r\n     * Sorting method for multires nodes.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Base tiles first, then higher timestamp first.\r\n     */\n\n\n    function multiresNodeSort(a, b) {\n      // Base tiles are always first\n      if (a.level == 1 && b.level != 1) {\n        return -1;\n      }\n\n      if (b.level == 1 && a.level != 1) {\n        return 1;\n      } // Higher timestamp first\n\n\n      return b.timestamp - a.timestamp;\n    }\n    /**\r\n     * Sorting method for multires node rendering.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Lower zoom levels first, then closest to center first.\r\n     */\n\n\n    function multiresNodeRenderSort(a, b) {\n      // Lower zoom levels first\n      if (a.level != b.level) {\n        return a.level - b.level;\n      } // Lower distance from center first\n\n\n      return a.diff - b.diff;\n    }\n    /**\r\n     * Draws multires nodes.\r\n     * @private\r\n     */\n\n\n    function multiresDraw() {\n      if (!program.drawInProgress) {\n        program.drawInProgress = true;\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        for (var i = 0; i < program.currentNodes.length; i++) {\n          if (program.currentNodes[i].textureLoaded > 1) {\n            //var color = program.currentNodes[i].color;\n            //gl.uniform4f(program.colorUniform, color[0], color[1], color[2], 1.0);\n            // Bind vertex buffer and pass vertices to WebGL\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertBuf);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(program.currentNodes[i].vertices), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(program.vertPosLocation, 3, gl.FLOAT, false, 0, 0); // Prep for texture\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\n            gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0); // Bind texture and draw tile\n\n            gl.bindTexture(gl.TEXTURE_2D, program.currentNodes[i].texture); // Bind program.currentNodes[i].texture to TEXTURE0\n\n            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n          }\n        }\n\n        program.drawInProgress = false;\n      }\n    }\n    /**\r\n     * Creates new multires node.\r\n     * @constructor\r\n     * @private\r\n     * @param {number[]} vertices - Node's verticies.\r\n     * @param {string} side - Node's cube face.\r\n     * @param {number} level - Node's zoom level.\r\n     * @param {number} x - Node's x position.\r\n     * @param {number} y - Node's y position.\r\n     * @param {string} path - Node's path.\r\n     */\n\n\n    function MultiresNode(vertices, side, level, x, y, path) {\n      this.vertices = vertices;\n      this.side = side;\n      this.level = level;\n      this.x = x;\n      this.y = y;\n      this.path = path.replace('%s', side).replace('%l', level).replace('%x', x).replace('%y', y);\n    }\n    /**\r\n     * Test if multires node is visible. If it is, add it to current nodes,\r\n     * load its texture, and load appropriate child nodes.\r\n     * @private\r\n     * @param {number[]} rotPersp - Rotated perspective matrix.\r\n     * @param {MultiresNode} node - Multires node to check.\r\n     * @param {number} pitch - Pitch to check at.\r\n     * @param {number} yaw - Yaw to check at.\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\n\n\n    function testMultiresNode(rotPersp, node, pitch, yaw, hfov) {\n      if (checkSquareInView(rotPersp, node.vertices)) {\n        // Calculate central angle between center of view and center of tile\n        var v = node.vertices;\n        var x = v[0] + v[3] + v[6] + v[9];\n        var y = v[1] + v[4] + v[7] + v[10];\n        var z = v[2] + v[5] + v[8] + v[11];\n        var r = Math.sqrt(x * x + y * y + z * z);\n        var theta = Math.asin(z / r);\n        var phi = Math.atan2(y, x);\n        var ydiff = phi - yaw;\n        ydiff += ydiff > Math.PI ? -2 * Math.PI : ydiff < -Math.PI ? 2 * Math.PI : 0;\n        ydiff = Math.abs(ydiff);\n        node.diff = Math.acos(Math.sin(pitch) * Math.sin(theta) + Math.cos(pitch) * Math.cos(theta) * Math.cos(ydiff)); // Add node to current nodes and load texture if needed\n\n        var inCurrent = false;\n\n        for (var k = 0; k < program.nodeCache.length; k++) {\n          if (program.nodeCache[k].path == node.path) {\n            inCurrent = true;\n            program.nodeCache[k].timestamp = program.nodeCacheTimestamp++;\n            program.nodeCache[k].diff = node.diff;\n            program.currentNodes.push(program.nodeCache[k]);\n            break;\n          }\n        }\n\n        if (!inCurrent) {\n          //node.color = [Math.random(), Math.random(), Math.random()];\n          node.timestamp = program.nodeCacheTimestamp++;\n          program.currentNodes.push(node);\n          program.nodeCache.push(node);\n        } // TODO: Test error\n        // Create child nodes\n\n\n        if (node.level < program.level) {\n          var cubeSize = image.cubeResolution * Math.pow(2, node.level - image.maxLevel);\n          var numTiles = Math.ceil(cubeSize * image.invTileResolution) - 1;\n          var doubleTileSize = cubeSize % image.tileResolution * 2;\n          var lastTileSize = cubeSize * 2 % image.tileResolution;\n\n          if (lastTileSize === 0) {\n            lastTileSize = image.tileResolution;\n          }\n\n          if (doubleTileSize === 0) {\n            doubleTileSize = image.tileResolution * 2;\n          }\n\n          var f = 0.5;\n\n          if (node.x == numTiles || node.y == numTiles) {\n            f = 1.0 - image.tileResolution / (image.tileResolution + lastTileSize);\n          }\n\n          var i = 1.0 - f;\n          var children = [];\n          var vtmp, ntmp;\n          var f1 = f,\n              f2 = f,\n              f3 = f,\n              i1 = i,\n              i2 = i,\n              i3 = i; // Handle non-symmetric tiles\n\n          if (lastTileSize < image.tileResolution) {\n            if (node.x == numTiles && node.y != numTiles) {\n              f2 = 0.5;\n              i2 = 0.5;\n\n              if (node.side == 'd' || node.side == 'u') {\n                f3 = 0.5;\n                i3 = 0.5;\n              }\n            } else if (node.x != numTiles && node.y == numTiles) {\n              f1 = 0.5;\n              i1 = 0.5;\n\n              if (node.side == 'l' || node.side == 'r') {\n                f3 = 0.5;\n                i3 = 0.5;\n              }\n            }\n          } // Handle small tiles that have fewer than four children\n\n\n          if (doubleTileSize <= image.tileResolution) {\n            if (node.x == numTiles) {\n              f1 = 0;\n              i1 = 1;\n\n              if (node.side == 'l' || node.side == 'r') {\n                f3 = 0;\n                i3 = 1;\n              }\n            }\n\n            if (node.y == numTiles) {\n              f2 = 0;\n              i2 = 1;\n\n              if (node.side == 'd' || node.side == 'u') {\n                f3 = 0;\n                i3 = 1;\n              }\n            }\n          }\n\n          vtmp = [v[0], v[1], v[2], v[0] * f1 + v[3] * i1, v[1] * f + v[4] * i, v[2] * f3 + v[5] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[0] * f + v[9] * i, v[1] * f2 + v[10] * i2, v[2] * f3 + v[11] * i3];\n          ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2, node.y * 2, image.fullpath);\n          children.push(ntmp);\n\n          if (!(node.x == numTiles && doubleTileSize <= image.tileResolution)) {\n            vtmp = [v[0] * f1 + v[3] * i1, v[1] * f + v[4] * i, v[2] * f3 + v[5] * i3, v[3], v[4], v[5], v[3] * f + v[6] * i, v[4] * f2 + v[7] * i2, v[5] * f3 + v[8] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3];\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2 + 1, node.y * 2, image.fullpath);\n            children.push(ntmp);\n          }\n\n          if (!(node.x == numTiles && doubleTileSize <= image.tileResolution) && !(node.y == numTiles && doubleTileSize <= image.tileResolution)) {\n            vtmp = [v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[3] * f + v[6] * i, v[4] * f2 + v[7] * i2, v[5] * f3 + v[8] * i3, v[6], v[7], v[8], v[9] * f1 + v[6] * i1, v[10] * f + v[7] * i, v[11] * f3 + v[8] * i3];\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2 + 1, node.y * 2 + 1, image.fullpath);\n            children.push(ntmp);\n          }\n\n          if (!(node.y == numTiles && doubleTileSize <= image.tileResolution)) {\n            vtmp = [v[0] * f + v[9] * i, v[1] * f2 + v[10] * i2, v[2] * f3 + v[11] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[9] * f1 + v[6] * i1, v[10] * f + v[7] * i, v[11] * f3 + v[8] * i3, v[9], v[10], v[11]];\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2, node.y * 2 + 1, image.fullpath);\n            children.push(ntmp);\n          }\n\n          for (var j = 0; j < children.length; j++) {\n            testMultiresNode(rotPersp, children[j], pitch, yaw, hfov);\n          }\n        }\n      }\n    }\n    /**\r\n     * Creates cube vertex array.\r\n     * @private\r\n     * @returns {number[]} Cube vertex array.\r\n     */\n\n\n    function createCube() {\n      return [-1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, // Front face\n      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // Back face\n      -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, // Up face\n      -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Down face\n      -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // Left face\n      1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1 // Right face\n      ];\n    }\n    /**\r\n     * Creates 3x3 identity matrix.\r\n     * @private\r\n     * @returns {number[]} Identity matrix.\r\n     */\n\n\n    function identityMatrix3() {\n      return [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n    /**\r\n     * Rotates a 3x3 matrix.\r\n     * @private\r\n     * @param {number[]} m - Matrix to rotate.\r\n     * @param {number[]} angle - Angle to rotate by in radians.\r\n     * @param {string} axis - Axis to rotate about (`x`, `y`, or `z`).\r\n     * @returns {number[]} Rotated matrix.\r\n     */\n\n\n    function rotateMatrix(m, angle, axis) {\n      var s = Math.sin(angle);\n      var c = Math.cos(angle);\n\n      if (axis == 'x') {\n        return [m[0], c * m[1] + s * m[2], c * m[2] - s * m[1], m[3], c * m[4] + s * m[5], c * m[5] - s * m[4], m[6], c * m[7] + s * m[8], c * m[8] - s * m[7]];\n      }\n\n      if (axis == 'y') {\n        return [c * m[0] - s * m[2], m[1], c * m[2] + s * m[0], c * m[3] - s * m[5], m[4], c * m[5] + s * m[3], c * m[6] - s * m[8], m[7], c * m[8] + s * m[6]];\n      }\n\n      if (axis == 'z') {\n        return [c * m[0] + s * m[1], c * m[1] - s * m[0], m[2], c * m[3] + s * m[4], c * m[4] - s * m[3], m[5], c * m[6] + s * m[7], c * m[7] - s * m[6], m[8]];\n      }\n    }\n    /**\r\n     * Turns a 3x3 matrix into a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Expanded matrix.\r\n     */\n\n\n    function makeMatrix4(m) {\n      return [m[0], m[1], m[2], 0, m[3], m[4], m[5], 0, m[6], m[7], m[8], 0, 0, 0, 0, 1];\n    }\n    /**\r\n     * Transposes a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Transposed matrix.\r\n     */\n\n\n    function transposeMatrix4(m) {\n      return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];\n    }\n    /**\r\n     * Creates a perspective matrix.\r\n     * @private\r\n     * @param {number} hfov - Desired horizontal field of view.\r\n     * @param {number} aspect - Desired aspect ratio.\r\n     * @param {number} znear - Near distance.\r\n     * @param {number} zfar - Far distance.\r\n     * @returns {number[]} Generated perspective matrix.\r\n     */\n\n\n    function makePersp(hfov, aspect, znear, zfar) {\n      var fovy = 2 * Math.atan(Math.tan(hfov / 2) * gl.drawingBufferHeight / gl.drawingBufferWidth);\n      var f = 1 / Math.tan(fovy / 2);\n      return [f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zfar + znear) / (znear - zfar), 2 * zfar * znear / (znear - zfar), 0, 0, -1, 0];\n    }\n    /**\r\n     * Processes a loaded texture image into a WebGL texture.\r\n     * @private\r\n     * @param {Image} img - Input image.\r\n     * @param {WebGLTexture} tex - Texture to bind image to.\r\n     */\n\n\n    function processLoadedTexture(img, tex) {\n      gl.bindTexture(gl.TEXTURE_2D, tex);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    var pendingTextureRequests = []; // Based on http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html\n\n    var loadTexture = function () {\n      var cacheTop = 4; // Maximum number of concurrents loads\n\n      var textureImageCache = {};\n      var crossOrigin;\n\n      function TextureImageLoader() {\n        var self = this;\n        this.texture = this.callback = null;\n        this.image = new Image();\n        this.image.crossOrigin = crossOrigin ? crossOrigin : 'anonymous';\n\n        var loadFn = function loadFn() {\n          if (self.image.width > 0 && self.image.height > 0) {\n            // ignore missing tile to supporting partial image\n            processLoadedTexture(self.image, self.texture);\n            self.callback(self.texture, true);\n          } else {\n            self.callback(self.texture, false);\n          }\n\n          releaseTextureImageLoader(self);\n        };\n\n        this.image.addEventListener('load', loadFn);\n        this.image.addEventListener('error', loadFn); // ignore missing tile file to support partial image, otherwise retry loop causes high CPU load\n      }\n\n      ;\n\n      TextureImageLoader.prototype.loadTexture = function (src, texture, callback) {\n        this.texture = texture;\n        this.callback = callback;\n        this.image.src = src;\n      };\n\n      function PendingTextureRequest(node, src, texture, callback) {\n        this.node = node;\n        this.src = src;\n        this.texture = texture;\n        this.callback = callback;\n      }\n\n      ;\n\n      function releaseTextureImageLoader(til) {\n        if (pendingTextureRequests.length) {\n          var req = pendingTextureRequests.shift();\n          til.loadTexture(req.src, req.texture, req.callback);\n        } else {\n          textureImageCache[cacheTop++] = til;\n        }\n      }\n\n      for (var i = 0; i < cacheTop; i++) {\n        textureImageCache[i] = new TextureImageLoader();\n      }\n\n      return function (node, src, callback, _crossOrigin) {\n        crossOrigin = _crossOrigin;\n        var texture = gl.createTexture();\n\n        if (cacheTop) {\n          textureImageCache[--cacheTop].loadTexture(src, texture, callback);\n        } else {\n          pendingTextureRequests.push(new PendingTextureRequest(node, src, texture, callback));\n        }\n\n        return texture;\n      };\n    }();\n    /**\r\n     * Loads image and creates texture for a multires node / tile.\r\n     * @private\r\n     * @param {MultiresNode} node - Input node.\r\n     */\n\n\n    function processNextTile(node) {\n      loadTexture(node, encodeURI(node.path + '.' + image.extension), function (texture, loaded) {\n        node.texture = texture;\n        node.textureLoaded = loaded ? 2 : 1;\n      }, globalParams.crossOrigin);\n    }\n    /**\r\n     * Finds and applies optimal multires zoom level.\r\n     * @private\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\n\n\n    function checkZoom(hfov) {\n      // Find optimal level\n      var newLevel = 1;\n\n      while (newLevel < image.maxLevel && gl.drawingBufferWidth > image.tileResolution * Math.pow(2, newLevel - 1) * Math.tan(hfov / 2) * 0.707) {\n        newLevel++;\n      } // Apply change\n\n\n      program.level = newLevel;\n    }\n    /**\r\n     * Rotates perspective matrix.\r\n     * @private\r\n     * @param {number[]} p - Perspective matrix.\r\n     * @param {number[]} r - Rotation matrix.\r\n     * @returns {number[]} Rotated matrix.\r\n     */\n\n\n    function rotatePersp(p, r) {\n      return [p[0] * r[0], p[0] * r[1], p[0] * r[2], 0, p[5] * r[4], p[5] * r[5], p[5] * r[6], 0, p[10] * r[8], p[10] * r[9], p[10] * r[10], p[11], -r[8], -r[9], -r[10], 0];\n    }\n    /**\r\n     * Applies rotated perspective matrix to a 3-vector\r\n     * (last element is inverted).\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input 3-vector.\r\n     * @returns {number[]} Resulting 4-vector.\r\n     */\n\n\n    function applyRotPerspToVec(m, v) {\n      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[4] * v[0] + m[5] * v[1] + m[6] * v[2], m[11] + m[8] * v[0] + m[9] * v[1] + m[10] * v[2], 1 / (m[12] * v[0] + m[13] * v[1] + m[14] * v[2])];\n    }\n    /**\r\n     * Checks if a vertex is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input vertex.\r\n     * @returns {number} 1 or -1 if the vertex is or is not visible,\r\n     *      respectively.\r\n     */\n\n\n    function checkInView(m, v) {\n      var vpp = applyRotPerspToVec(m, v);\n      var winX = vpp[0] * vpp[3];\n      var winY = vpp[1] * vpp[3];\n      var winZ = vpp[2] * vpp[3];\n      var ret = [0, 0, 0];\n\n      if (winX < -1) {\n        ret[0] = -1;\n      }\n\n      if (winX > 1) {\n        ret[0] = 1;\n      }\n\n      if (winY < -1) {\n        ret[1] = -1;\n      }\n\n      if (winY > 1) {\n        ret[1] = 1;\n      }\n\n      if (winZ < -1 || winZ > 1) {\n        ret[2] = 1;\n      }\n\n      return ret;\n    }\n    /**\r\n     * Checks if a square (tile) is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Square's vertex array.\r\n     * @returns {boolean} Whether or not the square is visible.\r\n     */\n\n\n    function checkSquareInView(m, v) {\n      var check1 = checkInView(m, v.slice(0, 3));\n      var check2 = checkInView(m, v.slice(3, 6));\n      var check3 = checkInView(m, v.slice(6, 9));\n      var check4 = checkInView(m, v.slice(9, 12));\n      var testX = check1[0] + check2[0] + check3[0] + check4[0];\n\n      if (testX == -4 || testX == 4) {\n        return false;\n      }\n\n      var testY = check1[1] + check2[1] + check3[1] + check4[1];\n\n      if (testY == -4 || testY == 4) {\n        return false;\n      }\n\n      var testZ = check1[2] + check2[2] + check3[2] + check4[2];\n      return testZ != 4;\n    }\n    /**\r\n     * On iOS (iPhone 5c, iOS 10.3), this WebGL error occurs when the canvas is\r\n     * too big. Unfortuately, there's no way to test for this beforehand, so we\r\n     * reduce the canvas size if this error is thrown.\r\n     * @private\r\n     */\n\n\n    function handleWebGLError1286() {\n      console.log('Reducing canvas size due to error 1286!');\n      canvas.width = Math.round(canvas.width / 2);\n      canvas.height = Math.round(canvas.height / 2);\n    }\n  } // Vertex shader for equirectangular and cube\n\n\n  var v = ['attribute vec2 a_texCoord;', 'varying vec2 v_texCoord;', 'void main() {', // Set position\n  'gl_Position = vec4(a_texCoord, 0.0, 1.0);', // Pass the coordinates to the fragment shader\n  'v_texCoord = a_texCoord;', '}'].join(''); // Vertex shader for multires\n\n  var vMulti = ['attribute vec3 a_vertCoord;', 'attribute vec2 a_texCoord;', 'uniform mat4 u_cubeMatrix;', 'uniform mat4 u_perspMatrix;', 'varying mediump vec2 v_texCoord;', 'void main(void) {', // Set position\n  'gl_Position = u_perspMatrix * u_cubeMatrix * vec4(a_vertCoord, 1.0);', // Pass the coordinates to the fragment shader\n  'v_texCoord = a_texCoord;', '}'].join(''); // Fragment shader\n\n  var fragEquiCubeBase = ['precision mediump float;', 'uniform float u_aspectRatio;', 'uniform float u_psi;', 'uniform float u_theta;', 'uniform float u_f;', 'uniform float u_h;', 'uniform float u_v;', 'uniform float u_vo;', 'uniform float u_rot;', 'const float PI = 3.14159265358979323846264;', // Texture\n  'uniform sampler2D u_image;', 'uniform samplerCube u_imageCube;', // Coordinates passed in from vertex shader\n  'varying vec2 v_texCoord;', // Background color (display for partial panoramas)\n  'uniform vec4 u_backgroundColor;', 'void main() {', // Map canvas/camera to sphere\n  'float x = v_texCoord.x * u_aspectRatio;', 'float y = v_texCoord.y;', 'float sinrot = sin(u_rot);', 'float cosrot = cos(u_rot);', 'float rot_x = x * cosrot - y * sinrot;', 'float rot_y = x * sinrot + y * cosrot;', 'float sintheta = sin(u_theta);', 'float costheta = cos(u_theta);', 'float a = u_f * costheta - rot_y * sintheta;', 'float root = sqrt(rot_x * rot_x + a * a);', 'float lambda = atan(rot_x / root, a / root) + u_psi;', 'float phi = atan((rot_y * costheta + u_f * sintheta) / root);'].join('\\n'); // Fragment shader\n\n  var fragCube = fragEquiCubeBase + [// Look up color from texture\n  'float cosphi = cos(phi);', 'gl_FragColor = textureCube(u_imageCube, vec3(cosphi*sin(lambda), sin(phi), cosphi*cos(lambda)));', '}'].join('\\n'); // Fragment shader\n\n  var fragEquirectangular = fragEquiCubeBase + [// Wrap image\n  'lambda = mod(lambda + PI, PI * 2.0) - PI;', // Map texture to sphere\n  'vec2 coord = vec2(lambda / PI, phi / (PI / 2.0));', // Look up color from texture\n  // Map from [-1,1] to [0,1] and flip y-axis\n  'if(coord.x < -u_h || coord.x > u_h || coord.y < -u_v + u_vo || coord.y > u_v + u_vo)', 'gl_FragColor = u_backgroundColor;', 'else', 'gl_FragColor = texture2D(u_image, vec2((coord.x + u_h) / (u_h * 2.0), (-coord.y + u_v + u_vo) / (u_v * 2.0)));', '}'].join('\\n'); // Fragment shader\n\n  var fragMulti = ['varying mediump vec2 v_texCoord;', 'uniform sampler2D u_sampler;', //'uniform mediump vec4 u_color;',\n  'void main(void) {', // Look up color from texture\n  'gl_FragColor = texture2D(u_sampler, v_texCoord);', //    'gl_FragColor = u_color;',\n  '}'].join('');\n  return {\n    renderer: function renderer(container, image, imagetype, dynamic) {\n      return new Renderer(container, image, imagetype, dynamic);\n    }\n  };\n}(window, document);","map":{"version":3,"sources":["C:/Users/rodet/Documents/GitHub/but-project/node_modules/pannellum-react/es/pannellum/js/libpannellum.js"],"names":["window","libpannellum","document","undefined","Renderer","container","canvas","createElement","style","width","height","appendChild","program","gl","vs","fs","fallbackImgSize","world","vtmps","pose","image","imageType","dynamic","texCoordBuffer","cubeVertBuf","cubeVertTexCoordBuf","cubeVertIndBuf","globalParams","init","_image","_imageType","_dynamic","haov","vaov","voffset","callback","params","console","log","type","detachShader","deleteShader","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","texture","deleteTexture","nodeCache","i","length","deleteProgram","s","faceMissing","cubeImgWidth","fillMissingFaces","imgSize","nbytes","imageArray","Uint8ClampedArray","rgb","backgroundColor","backgroundSquare","ImageData","navigator","userAgent","toLowerCase","match","getContext","alpha","depth","getError","handleWebGLError1286","hasOwnProperty","documentElement","appVersion","indexOf","removeChild","className","path","basePath","fallbackPath","sides","loaded","onLoad","faceCanvas","side","faceContext","drawImage","imgData","getImageData","data","j","putImageData","incLoaded","call","faceImg","Image","crossOrigin","onload","onerror","src","encodeURI","replace","extension","fullpath","invTileResolution","tileResolution","vertices","createCube","slice","maxWidth","Math","max","getParameter","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","horizonPitch","horizonRoll","glBindType","TEXTURE_2D","viewport","drawingBufferWidth","drawingBufferHeight","createShader","VERTEX_SHADER","vertexSrc","v","vMulti","shaderSource","compileShader","FRAGMENT_SHADER","fragmentSrc","fragEquirectangular","TEXTURE_CUBE_MAP","fragCube","fragMulti","createProgram","attachShader","linkProgram","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","drawInProgress","color","clearColor","clear","COLOR_BUFFER_BIT","texCoordLocation","getAttribLocation","enableVertexAttribArray","createBuffer","bufferData","Float32Array","STATIC_DRAW","vertexAttribPointer","FLOAT","aspectRatio","getUniformLocation","uniform1f","psi","theta","f","h","vo","rot","PI","uniform4fv","concat","createTexture","bindTexture","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","RGB","UNSIGNED_BYTE","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","vertPosLocation","Uint16Array","perspUniform","cubeUniform","level","currentNodes","nodeCacheTimestamp","err","destroy","contains","getExtension","loseContext","resize","pixelRatio","devicePixelRatio","clientWidth","clientHeight","setPose","render","pitch","yaw","hfov","focal","roll","orig_pitch","orig_yaw","x","cos","sin","y","z","asin","min","atan2","w","roll_adj","acos","sqrt","transforms","b","u","d","l","r","tan","zoom","transform","faces","Object","keys","face","querySelector","webkitTransform","vfov","atan","drawArrays","TRIANGLES","perspMatrix","makePersp","checkZoom","matrix","identityMatrix3","rotateMatrix","makeMatrix4","uniformMatrix4fv","transposeMatrix4","rotPersp","rotatePersp","sort","multiresNodeSort","removed","splice","ntmp","MultiresNode","testMultiresNode","multiresNodeRenderSort","pendingTextureRequests","node","textureLoad","setTimeout","processNextTile","multiresDraw","returnImage","toDataURL","isLoading","textureLoaded","getCanvas","a","timestamp","diff","drawElements","UNSIGNED_SHORT","checkSquareInView","phi","ydiff","abs","inCurrent","k","push","cubeSize","cubeResolution","pow","maxLevel","numTiles","ceil","doubleTileSize","lastTileSize","children","vtmp","f1","f2","f3","i1","i2","i3","m","angle","axis","c","aspect","znear","zfar","fovy","processLoadedTexture","img","tex","loadTexture","cacheTop","textureImageCache","TextureImageLoader","self","loadFn","releaseTextureImageLoader","addEventListener","prototype","PendingTextureRequest","til","req","shift","_crossOrigin","newLevel","p","applyRotPerspToVec","checkInView","vpp","winX","winY","winZ","ret","check1","check2","check3","check4","testX","testY","testZ","round","join","fragEquiCubeBase","renderer","imagetype"],"mappings":"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","sourcesContent":["/*\r\n * libpannellum - A WebGL and CSS 3D transform based Panorama Renderer\r\n * Copyright (c) 2012-2018 Matthew Petroff\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\nwindow.libpannellum = function (window, document, undefined) {\r\n\r\n  /**\r\n  * Creates a new panorama renderer.\r\n  * @constructor\r\n  * @param {HTMLElement} container - The container element for the renderer.\r\n  */\r\n  function Renderer(container) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.style.width = canvas.style.height = '100%';\r\n    container.appendChild(canvas);\r\n\r\n    var program, gl, vs, fs;\r\n    var fallbackImgSize;\r\n    var world;\r\n    var vtmps;\r\n    var pose;\r\n    var image, imageType, dynamic;\r\n    var texCoordBuffer, cubeVertBuf, cubeVertTexCoordBuf, cubeVertIndBuf;\r\n    var globalParams;\r\n\r\n    /**\r\n     * Initialize renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {Image|Array|Object} image - Input image; format varies based on\r\n     *      `imageType`. For `equirectangular`, this is an image; for\r\n     *      `cubemap`, this is an array of images for the cube faces in the\r\n     *      order [+z, +x, -z, -x, +y, -y]; for `multires`, this is a\r\n     *      configuration object.\r\n     * @param {string} imageType - The type of the image: `equirectangular`,\r\n     *      `cubemap`, or `multires`.\r\n     * @param {boolean} dynamic - Whether or not the image is dynamic (e.g. video).\r\n     * @param {number} haov - Initial horizontal angle of view.\r\n     * @param {number} vaov - Initial vertical angle of view.\r\n     * @param {number} voffset - Initial vertical offset angle.\r\n     * @param {function} callback - Load callback function.\r\n     * @param {Object} [params] - Other configuration parameters (`horizonPitch`, `horizonRoll`, `backgroundColor`).\r\n     */\r\n    this.init = function (_image, _imageType, _dynamic, haov, vaov, voffset, callback, params) {\r\n      // Default argument for image type\r\n      if (_imageType === undefined) {\r\n        _imageType = 'equirectangular';\r\n      }\r\n\r\n      if (_imageType != 'equirectangular' && _imageType != 'cubemap' && _imageType != 'multires') {\r\n        console.log('Error: invalid image type specified!');\r\n        throw { type: 'config error' };\r\n      }\r\n\r\n      imageType = _imageType;\r\n      image = _image;\r\n      dynamic = _dynamic;\r\n      globalParams = params || {};\r\n\r\n      // Clear old data\r\n      if (program) {\r\n        if (vs) {\r\n          gl.detachShader(program, vs);\r\n          gl.deleteShader(vs);\r\n        }\r\n        if (fs) {\r\n          gl.detachShader(program, fs);\r\n          gl.deleteShader(fs);\r\n        }\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n        if (program.texture) {\r\n          gl.deleteTexture(program.texture);\r\n        }\r\n        if (program.nodeCache) {\r\n          for (var i = 0; i < program.nodeCache.length; i++) {\r\n            gl.deleteTexture(program.nodeCache[i].texture);\r\n          }\r\n        }\r\n        gl.deleteProgram(program);\r\n        program = undefined;\r\n      }\r\n      pose = undefined;\r\n\r\n      var s;\r\n      var faceMissing = false;\r\n      var cubeImgWidth;\r\n      if (imageType == 'cubemap') {\r\n        for (s = 0; s < 6; s++) {\r\n          if (image[s].width > 0) {\r\n            if (cubeImgWidth === undefined) {\r\n              cubeImgWidth = image[s].width;\r\n            }\r\n            if (cubeImgWidth != image[s].width) {\r\n              console.log('Cube faces have inconsistent widths: ' + cubeImgWidth + ' vs. ' + image[s].width);\r\n            }\r\n          } else {\r\n            faceMissing = true;\r\n          }\r\n        }\r\n      }\r\n      function fillMissingFaces(imgSize) {\r\n        if (faceMissing) {\r\n          // Fill any missing fallback/cubemap faces with background\r\n          var nbytes = imgSize * imgSize * 4; // RGB, plus non-functional alpha\r\n          var imageArray = new Uint8ClampedArray(nbytes);\r\n          var rgb = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\r\n          rgb[0] *= 255;\r\n          rgb[1] *= 255;\r\n          rgb[2] *= 255;\r\n          // Maybe filling could be done faster, see e.g. https://stackoverflow.com/questions/1295584/most-efficient-way-to-create-a-zero-filled-javascript-array\r\n          for (var i = 0; i < nbytes; i++) {\r\n            imageArray[i++] = rgb[0];\r\n            imageArray[i++] = rgb[1];\r\n            imageArray[i++] = rgb[2];\r\n          }\r\n          var backgroundSquare = new ImageData(imageArray, imgSize, imgSize);\r\n          for (s = 0; s < 6; s++) {\r\n            if (image[s].width == 0) {\r\n              image[s] = backgroundSquare;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // This awful browser specific test exists because iOS 8/9 and IE 11\r\n      // don't display non-power-of-two cubemap textures but also don't\r\n      // throw an error (tested on an iPhone 5c / iOS 8.1.3 / iOS 9.2 /\r\n      // iOS 10.3.1).\r\n      // Therefore, the WebGL context is never created for these browsers for\r\n      // NPOT cubemaps, and the CSS 3D transform fallback renderer is used\r\n      // instead.\r\n      if (!(imageType == 'cubemap' && (cubeImgWidth & cubeImgWidth - 1) !== 0 && (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 9_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 10_/) || navigator.userAgent.match(/Trident.*rv[ :]*11\\./)))) {\r\n        // Enable WebGL on canvas\r\n        if (!gl) {\r\n          gl = canvas.getContext('experimental-webgl', { alpha: false, depth: false });\r\n        }\r\n        if (gl && gl.getError() == 1286) {\r\n          handleWebGLError1286();\r\n        }\r\n      }\r\n\r\n      // If there is no WebGL, fall back to CSS 3D transform renderer.\r\n      // This will discard the image loaded so far and load the fallback image.\r\n      // While browser specific tests are usually frowned upon, the\r\n      // fallback viewer only really works with WebKit/Blink and IE 10/11\r\n      // (it doesn't work properly in Firefox).\r\n      if (!gl && (imageType == 'multires' && image.hasOwnProperty('fallbackPath') || imageType == 'cubemap') && ('WebkitAppearance' in document.documentElement.style || navigator.userAgent.match(/Trident.*rv[ :]*11\\./) || navigator.appVersion.indexOf('MSIE 10') !== -1)) {\r\n        // Remove old world if it exists\r\n        if (world) {\r\n          container.removeChild(world);\r\n        }\r\n\r\n        // Initialize renderer\r\n        world = document.createElement('div');\r\n        world.className = 'pnlm-world';\r\n\r\n        // Add images\r\n        var path;\r\n        if (image.basePath) {\r\n          path = image.basePath + image.fallbackPath;\r\n        } else {\r\n          path = image.fallbackPath;\r\n        }\r\n        var sides = ['f', 'r', 'b', 'l', 'u', 'd'];\r\n        var loaded = 0;\r\n        var onLoad = function onLoad() {\r\n          // Draw image on canvas\r\n          var faceCanvas = document.createElement('canvas');\r\n          faceCanvas.className = 'pnlm-face pnlm-' + sides[this.side] + 'face';\r\n          world.appendChild(faceCanvas);\r\n          var faceContext = faceCanvas.getContext('2d');\r\n          faceCanvas.style.width = this.width + 4 + 'px';\r\n          faceCanvas.style.height = this.height + 4 + 'px';\r\n          faceCanvas.width = this.width + 4;\r\n          faceCanvas.height = this.height + 4;\r\n          faceContext.drawImage(this, 2, 2);\r\n          var imgData = faceContext.getImageData(0, 0, faceCanvas.width, faceCanvas.height);\r\n          var data = imgData.data;\r\n\r\n          // Duplicate edge pixels\r\n          var i;\r\n          var j;\r\n          for (i = 2; i < faceCanvas.width - 2; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[(i + faceCanvas.width) * 4 + j] = data[(i + faceCanvas.width * 2) * 4 + j];\r\n              data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 3)) * 4 + j];\r\n            }\r\n          }\r\n          for (i = 2; i < faceCanvas.height - 2; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[(i * faceCanvas.width + 1) * 4 + j] = data[(i * faceCanvas.width + 2) * 4 + j];\r\n              data[((i + 1) * faceCanvas.width - 2) * 4 + j] = data[((i + 1) * faceCanvas.width - 3) * 4 + j];\r\n            }\r\n          }\r\n          for (j = 0; j < 4; j++) {\r\n            data[(faceCanvas.width + 1) * 4 + j] = data[(faceCanvas.width * 2 + 2) * 4 + j];\r\n            data[(faceCanvas.width * 2 - 2) * 4 + j] = data[(faceCanvas.width * 3 - 3) * 4 + j];\r\n            data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 3) + 2) * 4 + j];\r\n            data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) - 3) * 4 + j];\r\n          }\r\n          for (i = 1; i < faceCanvas.width - 1; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[i * 4 + j] = data[(i + faceCanvas.width) * 4 + j];\r\n              data[(i + faceCanvas.width * (faceCanvas.height - 1)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j];\r\n            }\r\n          }\r\n          for (i = 1; i < faceCanvas.height - 1; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[i * faceCanvas.width * 4 + j] = data[(i * faceCanvas.width + 1) * 4 + j];\r\n              data[((i + 1) * faceCanvas.width - 1) * 4 + j] = data[((i + 1) * faceCanvas.width - 2) * 4 + j];\r\n            }\r\n          }\r\n          for (j = 0; j < 4; j++) {\r\n            data[j] = data[(faceCanvas.width + 1) * 4 + j];\r\n            data[(faceCanvas.width - 1) * 4 + j] = data[(faceCanvas.width * 2 - 2) * 4 + j];\r\n            data[faceCanvas.width * (faceCanvas.height - 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j];\r\n            data[(faceCanvas.width * faceCanvas.height - 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j];\r\n          }\r\n\r\n          // Draw image width duplicated edge pixels on canvas\r\n          faceContext.putImageData(imgData, 0, 0);\r\n\r\n          incLoaded.call(this);\r\n        };\r\n        var incLoaded = function incLoaded() {\r\n          if (this.width > 0) {\r\n            if (fallbackImgSize === undefined) {\r\n              fallbackImgSize = this.width;\r\n            }\r\n            if (fallbackImgSize != this.width) {\r\n              console.log('Fallback faces have inconsistent widths: ' + fallbackImgSize + ' vs. ' + this.width);\r\n            }\r\n          } else {\r\n            faceMissing = true;\r\n          }\r\n          loaded++;\r\n          if (loaded == 6) {\r\n            fallbackImgSize = this.width;\r\n            container.appendChild(world);\r\n            callback();\r\n          }\r\n        };\r\n        faceMissing = false;\r\n        for (s = 0; s < 6; s++) {\r\n          var faceImg = new Image();\r\n          faceImg.crossOrigin = globalParams.crossOrigin ? globalParams.crossOrigin : 'anonymous';\r\n          faceImg.side = s;\r\n          faceImg.onload = onLoad;\r\n          faceImg.onerror = incLoaded; // ignore missing face to support partial fallback image\r\n          if (imageType == 'multires') {\r\n            faceImg.src = encodeURI(path.replace('%s', sides[s]) + '.' + image.extension);\r\n          } else {\r\n            faceImg.src = encodeURI(image[s].src);\r\n          }\r\n        }\r\n        fillMissingFaces(fallbackImgSize);\r\n        return;\r\n      } else if (!gl) {\r\n        console.log('Error: no WebGL support detected!');\r\n        throw { type: 'no webgl' };\r\n      }\r\n      if (imageType == 'cubemap') {\r\n        fillMissingFaces(cubeImgWidth);\r\n      }\r\n      if (image.basePath) {\r\n        image.fullpath = image.basePath + image.path;\r\n      } else {\r\n        image.fullpath = image.path;\r\n      }\r\n      image.invTileResolution = 1 / image.tileResolution;\r\n\r\n      var vertices = createCube();\r\n      vtmps = [];\r\n      for (s = 0; s < 6; s++) {\r\n        vtmps[s] = vertices.slice(s * 12, s * 12 + 12);\r\n        vertices = createCube();\r\n      }\r\n\r\n      // Make sure image isn't too big\r\n      var width = 0,\r\n          maxWidth = 0;\r\n      if (imageType == 'equirectangular') {\r\n        width = Math.max(image.width, image.height);\r\n        maxWidth = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n      } else if (imageType == 'cubemap') {\r\n        width = cubeImgWidth;\r\n        maxWidth = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\r\n      }\r\n      if (width > maxWidth) {\r\n        console.log('Error: The image is too big; it\\'s ' + width + 'px wide, ' + 'but this device\\'s maximum supported size is ' + maxWidth + 'px.');\r\n        throw { type: 'webgl size error', width: width, maxWidth: maxWidth };\r\n      }\r\n\r\n      // Store horizon pitch and roll if applicable\r\n      if (params !== undefined && (params.horizonPitch !== undefined || params.horizonRoll !== undefined)) {\r\n        pose = [params.horizonPitch == undefined ? 0 : params.horizonPitch, params.horizonRoll == undefined ? 0 : params.horizonRoll];\r\n      }\r\n\r\n      // Set 2d texture binding\r\n      var glBindType = gl.TEXTURE_2D;\r\n\r\n      // Create viewport for entire canvas\r\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n      // Create vertex shader\r\n      vs = gl.createShader(gl.VERTEX_SHADER);\r\n      var vertexSrc = v;\r\n      if (imageType == 'multires') {\r\n        vertexSrc = vMulti;\r\n      }\r\n      gl.shaderSource(vs, vertexSrc);\r\n      gl.compileShader(vs);\r\n\r\n      // Create fragment shader\r\n      fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n      var fragmentSrc = fragEquirectangular;\r\n      if (imageType == 'cubemap') {\r\n        glBindType = gl.TEXTURE_CUBE_MAP;\r\n        fragmentSrc = fragCube;\r\n      } else if (imageType == 'multires') {\r\n        fragmentSrc = fragMulti;\r\n      }\r\n      gl.shaderSource(fs, fragmentSrc);\r\n      gl.compileShader(fs);\r\n\r\n      // Link WebGL program\r\n      program = gl.createProgram();\r\n      gl.attachShader(program, vs);\r\n      gl.attachShader(program, fs);\r\n      gl.linkProgram(program);\r\n\r\n      // Log errors\r\n      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\r\n        console.log(gl.getShaderInfoLog(vs));\r\n      }\r\n      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\r\n        console.log(gl.getShaderInfoLog(fs));\r\n      }\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        console.log(gl.getProgramInfoLog(program));\r\n      }\r\n\r\n      // Use WebGL program\r\n      gl.useProgram(program);\r\n\r\n      program.drawInProgress = false;\r\n\r\n      // Set background clear color (does not apply to cubemap/fallback image)\r\n      var color = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\r\n      gl.clearColor(color[0], color[1], color[2], 1.0);\r\n      gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n      // Look up texture coordinates location\r\n      program.texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');\r\n      gl.enableVertexAttribArray(program.texCoordLocation);\r\n\r\n      if (imageType != 'multires') {\r\n        // Provide texture coordinates for rectangle\r\n        if (!texCoordBuffer) {\r\n          texCoordBuffer = gl.createBuffer();\r\n        }\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);\r\n        gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n        // Pass aspect ratio\r\n        program.aspectRatio = gl.getUniformLocation(program, 'u_aspectRatio');\r\n        gl.uniform1f(program.aspectRatio, gl.drawingBufferWidth / gl.drawingBufferHeight);\r\n\r\n        // Locate psi, theta, focal length, horizontal extent, vertical extent, and vertical offset\r\n        program.psi = gl.getUniformLocation(program, 'u_psi');\r\n        program.theta = gl.getUniformLocation(program, 'u_theta');\r\n        program.f = gl.getUniformLocation(program, 'u_f');\r\n        program.h = gl.getUniformLocation(program, 'u_h');\r\n        program.v = gl.getUniformLocation(program, 'u_v');\r\n        program.vo = gl.getUniformLocation(program, 'u_vo');\r\n        program.rot = gl.getUniformLocation(program, 'u_rot');\r\n\r\n        // Pass horizontal extent, vertical extent, and vertical offset\r\n        gl.uniform1f(program.h, haov / (Math.PI * 2.0));\r\n        gl.uniform1f(program.v, vaov / Math.PI);\r\n        gl.uniform1f(program.vo, voffset / Math.PI * 2);\r\n\r\n        // Set background color\r\n        if (imageType == 'equirectangular') {\r\n          program.backgroundColor = gl.getUniformLocation(program, 'u_backgroundColor');\r\n          gl.uniform4fv(program.backgroundColor, color.concat([1]));\r\n        }\r\n\r\n        // Create texture\r\n        program.texture = gl.createTexture();\r\n        gl.bindTexture(glBindType, program.texture);\r\n\r\n        // Upload images to texture depending on type\r\n        if (imageType == 'cubemap') {\r\n          // Load all six sides of the cube map\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[1]);\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[3]);\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[4]);\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[5]);\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[0]);\r\n          gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[2]);\r\n        } else {\r\n          // Upload image to the texture\r\n          gl.texImage2D(glBindType, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\r\n        }\r\n\r\n        // Set parameters for rendering any size\r\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n      } else {\r\n        // Look up vertex coordinates location\r\n        program.vertPosLocation = gl.getAttribLocation(program, 'a_vertCoord');\r\n        gl.enableVertexAttribArray(program.vertPosLocation);\r\n\r\n        // Create buffers\r\n        if (!cubeVertBuf) {\r\n          cubeVertBuf = gl.createBuffer();\r\n        }\r\n        if (!cubeVertTexCoordBuf) {\r\n          cubeVertTexCoordBuf = gl.createBuffer();\r\n        }\r\n        if (!cubeVertIndBuf) {\r\n          cubeVertIndBuf = gl.createBuffer();\r\n        }\r\n\r\n        // Bind texture coordinate buffer and pass coordinates to WebGL\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\r\n\r\n        // Bind square index buffer and pass indicies to WebGL\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertIndBuf);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\r\n\r\n        // Find uniforms\r\n        program.perspUniform = gl.getUniformLocation(program, 'u_perspMatrix');\r\n        program.cubeUniform = gl.getUniformLocation(program, 'u_cubeMatrix');\r\n        //program.colorUniform = gl.getUniformLocation(program, 'u_color');\r\n\r\n        program.level = -1;\r\n\r\n        program.currentNodes = [];\r\n        program.nodeCache = [];\r\n        program.nodeCacheTimestamp = 0;\r\n      }\r\n\r\n      // Check if there was an error\r\n      var err = gl.getError();\r\n      if (err !== 0) {\r\n        console.log('Error: Something went wrong with WebGL!', err);\r\n        throw { type: 'webgl error' };\r\n      }\r\n\r\n      callback();\r\n    };\r\n\r\n    /**\r\n     * Destroy renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n    this.destroy = function () {\r\n      if (container !== undefined) {\r\n        if (canvas !== undefined && container.contains(canvas)) {\r\n          container.removeChild(canvas);\r\n        }\r\n        if (world !== undefined && container.contains(world)) {\r\n          container.removeChild(world);\r\n        }\r\n      }\r\n      if (gl) {\r\n        // The spec says this is only supposed to simulate losing the WebGL\r\n        // context, but in practice it tends to actually free the memory.\r\n        var extension = gl.getExtension('WEBGL_lose_context');\r\n        if (extension) {\r\n          extension.loseContext();\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Resize renderer (call after resizing container).\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n    this.resize = function () {\r\n      var pixelRatio = window.devicePixelRatio || 1;\r\n      canvas.width = canvas.clientWidth * pixelRatio;\r\n      canvas.height = canvas.clientHeight * pixelRatio;\r\n      if (gl) {\r\n        if (gl.getError() == 1286) {\r\n          handleWebGLError1286();\r\n        }\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n        if (imageType != 'multires') {\r\n          gl.uniform1f(program.aspectRatio, canvas.clientWidth / canvas.clientHeight);\r\n        }\r\n      }\r\n    };\r\n    // Initialize canvas size\r\n    this.resize();\r\n\r\n    /**\r\n     * Set renderer horizon pitch and roll.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n    this.setPose = function (horizonPitch, horizonRoll) {\r\n      pose = [horizonPitch, horizonRoll];\r\n    };\r\n\r\n    /**\r\n     * Render new view of panorama.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {number} pitch - Pitch to render at (in radians).\r\n     * @param {number} yaw - Yaw to render at (in radians).\r\n     * @param {number} hfov - Horizontal field of view to render with (in radians).\r\n     * @param {Object} [params] - Extra configuration parameters. \r\n     * @param {number} [params.roll] - Camera roll (in radians).\r\n     * @param {boolean} [params.returnImage] - Return rendered image?\r\n     */\r\n    this.render = function (pitch, yaw, hfov, params) {\r\n      var focal,\r\n          i,\r\n          s,\r\n          roll = 0;\r\n      if (params === undefined) {\r\n        params = {};\r\n      }\r\n      if (params.roll) {\r\n        roll = params.roll;\r\n      }\r\n\r\n      // Apply pitch and roll transformation if applicable\r\n      if (pose !== undefined) {\r\n        var horizonPitch = pose[0],\r\n            horizonRoll = pose[1];\r\n\r\n        // Calculate new pitch and yaw\r\n        var orig_pitch = pitch,\r\n            orig_yaw = yaw,\r\n            x = Math.cos(horizonRoll) * Math.sin(pitch) * Math.sin(horizonPitch) + Math.cos(pitch) * (Math.cos(horizonPitch) * Math.cos(yaw) + Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.sin(yaw)),\r\n            y = -Math.sin(pitch) * Math.sin(horizonRoll) + Math.cos(pitch) * Math.cos(horizonRoll) * Math.sin(yaw),\r\n            z = Math.cos(horizonRoll) * Math.cos(horizonPitch) * Math.sin(pitch) + Math.cos(pitch) * (-Math.cos(yaw) * Math.sin(horizonPitch) + Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.sin(yaw));\r\n        pitch = Math.asin(Math.max(Math.min(z, 1), -1));\r\n        yaw = Math.atan2(y, x);\r\n\r\n        // Calculate roll\r\n        var v = [Math.cos(orig_pitch) * (Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.cos(orig_yaw) - Math.cos(horizonPitch) * Math.sin(orig_yaw)), Math.cos(orig_pitch) * Math.cos(horizonRoll) * Math.cos(orig_yaw), Math.cos(orig_pitch) * (Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.cos(orig_yaw) + Math.sin(orig_yaw) * Math.sin(horizonPitch))],\r\n            w = [-Math.cos(pitch) * Math.sin(yaw), Math.cos(pitch) * Math.cos(yaw)];\r\n        var roll_adj = Math.acos(Math.max(Math.min((v[0] * w[0] + v[1] * w[1]) / (Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) * Math.sqrt(w[0] * w[0] + w[1] * w[1])), 1), -1));\r\n        if (v[2] < 0) {\r\n          roll_adj = 2 * Math.PI - roll_adj;\r\n        }\r\n        roll += roll_adj;\r\n      }\r\n\r\n      // If no WebGL\r\n      if (!gl && (imageType == 'multires' || imageType == 'cubemap')) {\r\n        // Determine face transforms\r\n        s = fallbackImgSize / 2;\r\n\r\n        var transforms = {\r\n          f: 'translate3d(-' + (s + 2) + 'px, -' + (s + 2) + 'px, -' + s + 'px)',\r\n          b: 'translate3d(' + (s + 2) + 'px, -' + (s + 2) + 'px, ' + s + 'px) rotateX(180deg) rotateZ(180deg)',\r\n          u: 'translate3d(-' + (s + 2) + 'px, -' + s + 'px, ' + (s + 2) + 'px) rotateX(270deg)',\r\n          d: 'translate3d(-' + (s + 2) + 'px, ' + s + 'px, -' + (s + 2) + 'px) rotateX(90deg)',\r\n          l: 'translate3d(-' + s + 'px, -' + (s + 2) + 'px, ' + (s + 2) + 'px) rotateX(180deg) rotateY(90deg) rotateZ(180deg)',\r\n          r: 'translate3d(' + s + 'px, -' + (s + 2) + 'px, -' + (s + 2) + 'px) rotateY(270deg)'\r\n        };\r\n        focal = 1 / Math.tan(hfov / 2);\r\n        var zoom = focal * canvas.clientWidth / 2 + 'px';\r\n        var transform = 'perspective(' + zoom + ') translateZ(' + zoom + ') rotateX(' + pitch + 'rad) rotateY(' + yaw + 'rad) ';\r\n\r\n        // Apply face transforms\r\n        var faces = Object.keys(transforms);\r\n        for (i = 0; i < 6; i++) {\r\n          var face = world.querySelector('.pnlm-' + faces[i] + 'face');\r\n          if (!face) {\r\n            continue;\r\n          } // ignore missing face to support partial cubemap/fallback image\r\n          face.style.webkitTransform = transform + transforms[faces[i]];\r\n          face.style.transform = transform + transforms[faces[i]];\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (imageType != 'multires') {\r\n        // Calculate focal length from vertical field of view\r\n        var vfov = 2 * Math.atan(Math.tan(hfov * 0.5) / (gl.drawingBufferWidth / gl.drawingBufferHeight));\r\n        focal = 1 / Math.tan(vfov * 0.5);\r\n\r\n        // Pass psi, theta, roll, and focal length\r\n        gl.uniform1f(program.psi, yaw);\r\n        gl.uniform1f(program.theta, pitch);\r\n        gl.uniform1f(program.rot, roll);\r\n        gl.uniform1f(program.f, focal);\r\n\r\n        if (dynamic === true) {\r\n          // Update texture if dynamic\r\n          if (imageType == 'equirectangular') {\r\n            gl.bindTexture(gl.TEXTURE_2D, program.texture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\r\n          }\r\n        }\r\n\r\n        // Draw using current buffer\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n      } else {\r\n        // Create perspective matrix\r\n        var perspMatrix = makePersp(hfov, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 100.0);\r\n\r\n        // Find correct zoom level\r\n        checkZoom(hfov);\r\n\r\n        // Create rotation matrix\r\n        var matrix = identityMatrix3();\r\n        matrix = rotateMatrix(matrix, -roll, 'z');\r\n        matrix = rotateMatrix(matrix, -pitch, 'x');\r\n        matrix = rotateMatrix(matrix, yaw, 'y');\r\n        matrix = makeMatrix4(matrix);\r\n\r\n        // Set matrix uniforms\r\n        gl.uniformMatrix4fv(program.perspUniform, false, new Float32Array(transposeMatrix4(perspMatrix)));\r\n        gl.uniformMatrix4fv(program.cubeUniform, false, new Float32Array(transposeMatrix4(matrix)));\r\n\r\n        // Find current nodes\r\n        var rotPersp = rotatePersp(perspMatrix, matrix);\r\n        program.nodeCache.sort(multiresNodeSort);\r\n        if (program.nodeCache.length > 200 && program.nodeCache.length > program.currentNodes.length + 50) {\r\n          // Remove older nodes from cache\r\n          var removed = program.nodeCache.splice(200, program.nodeCache.length - 200);\r\n          for (var i = 0; i < removed.length; i++) {\r\n            // Explicitly delete textures\r\n            gl.deleteTexture(removed[i].texture);\r\n          }\r\n        }\r\n        program.currentNodes = [];\r\n\r\n        var sides = ['f', 'b', 'u', 'd', 'l', 'r'];\r\n        for (s = 0; s < 6; s++) {\r\n          var ntmp = new MultiresNode(vtmps[s], sides[s], 1, 0, 0, image.fullpath);\r\n          testMultiresNode(rotPersp, ntmp, pitch, yaw, hfov);\r\n        }\r\n\r\n        program.currentNodes.sort(multiresNodeRenderSort);\r\n\r\n        // Unqueue any pending requests for nodes that are no longer visible\r\n        for (i = pendingTextureRequests.length - 1; i >= 0; i--) {\r\n          if (program.currentNodes.indexOf(pendingTextureRequests[i].node) === -1) {\r\n            pendingTextureRequests[i].node.textureLoad = false;\r\n            pendingTextureRequests.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        // Allow one request to be pending, so that we can create a texture buffer for that in advance of loading actually beginning\r\n        if (pendingTextureRequests.length === 0) {\r\n          for (i = 0; i < program.currentNodes.length; i++) {\r\n            var node = program.currentNodes[i];\r\n            if (!node.texture && !node.textureLoad) {\r\n              node.textureLoad = true;\r\n\r\n              setTimeout(processNextTile, 0, node);\r\n\r\n              // Only process one tile per frame to improve responsiveness\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Draw tiles\r\n        multiresDraw();\r\n      }\r\n\r\n      if (params.returnImage !== undefined) {\r\n        return canvas.toDataURL('image/png');\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if images are loading.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {boolean} Whether or not images are loading.\r\n     */\r\n    this.isLoading = function () {\r\n      if (gl && imageType == 'multires') {\r\n        for (var i = 0; i < program.currentNodes.length; i++) {\r\n          if (!program.currentNodes[i].textureLoaded) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Retrieve renderer's canvas.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {HTMLElement} Renderer's canvas.\r\n     */\r\n    this.getCanvas = function () {\r\n      return canvas;\r\n    };\r\n\r\n    /**\r\n     * Sorting method for multires nodes.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Base tiles first, then higher timestamp first.\r\n     */\r\n    function multiresNodeSort(a, b) {\r\n      // Base tiles are always first\r\n      if (a.level == 1 && b.level != 1) {\r\n        return -1;\r\n      }\r\n      if (b.level == 1 && a.level != 1) {\r\n        return 1;\r\n      }\r\n\r\n      // Higher timestamp first\r\n      return b.timestamp - a.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Sorting method for multires node rendering.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Lower zoom levels first, then closest to center first.\r\n     */\r\n    function multiresNodeRenderSort(a, b) {\r\n      // Lower zoom levels first\r\n      if (a.level != b.level) {\r\n        return a.level - b.level;\r\n      }\r\n\r\n      // Lower distance from center first\r\n      return a.diff - b.diff;\r\n    }\r\n\r\n    /**\r\n     * Draws multires nodes.\r\n     * @private\r\n     */\r\n    function multiresDraw() {\r\n      if (!program.drawInProgress) {\r\n        program.drawInProgress = true;\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        for (var i = 0; i < program.currentNodes.length; i++) {\r\n          if (program.currentNodes[i].textureLoaded > 1) {\r\n            //var color = program.currentNodes[i].color;\r\n            //gl.uniform4f(program.colorUniform, color[0], color[1], color[2], 1.0);\r\n\r\n            // Bind vertex buffer and pass vertices to WebGL\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertBuf);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(program.currentNodes[i].vertices), gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(program.vertPosLocation, 3, gl.FLOAT, false, 0, 0);\r\n\r\n            // Prep for texture\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\r\n            gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // Bind texture and draw tile\r\n            gl.bindTexture(gl.TEXTURE_2D, program.currentNodes[i].texture); // Bind program.currentNodes[i].texture to TEXTURE0\r\n            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n          }\r\n        }\r\n        program.drawInProgress = false;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Creates new multires node.\r\n     * @constructor\r\n     * @private\r\n     * @param {number[]} vertices - Node's verticies.\r\n     * @param {string} side - Node's cube face.\r\n     * @param {number} level - Node's zoom level.\r\n     * @param {number} x - Node's x position.\r\n     * @param {number} y - Node's y position.\r\n     * @param {string} path - Node's path.\r\n     */\r\n    function MultiresNode(vertices, side, level, x, y, path) {\r\n      this.vertices = vertices;\r\n      this.side = side;\r\n      this.level = level;\r\n      this.x = x;\r\n      this.y = y;\r\n      this.path = path.replace('%s', side).replace('%l', level).replace('%x', x).replace('%y', y);\r\n    }\r\n\r\n    /**\r\n     * Test if multires node is visible. If it is, add it to current nodes,\r\n     * load its texture, and load appropriate child nodes.\r\n     * @private\r\n     * @param {number[]} rotPersp - Rotated perspective matrix.\r\n     * @param {MultiresNode} node - Multires node to check.\r\n     * @param {number} pitch - Pitch to check at.\r\n     * @param {number} yaw - Yaw to check at.\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\r\n    function testMultiresNode(rotPersp, node, pitch, yaw, hfov) {\r\n      if (checkSquareInView(rotPersp, node.vertices)) {\r\n        // Calculate central angle between center of view and center of tile\r\n        var v = node.vertices;\r\n        var x = v[0] + v[3] + v[6] + v[9];\r\n        var y = v[1] + v[4] + v[7] + v[10];\r\n        var z = v[2] + v[5] + v[8] + v[11];\r\n        var r = Math.sqrt(x * x + y * y + z * z);\r\n        var theta = Math.asin(z / r);\r\n        var phi = Math.atan2(y, x);\r\n        var ydiff = phi - yaw;\r\n        ydiff += ydiff > Math.PI ? -2 * Math.PI : ydiff < -Math.PI ? 2 * Math.PI : 0;\r\n        ydiff = Math.abs(ydiff);\r\n        node.diff = Math.acos(Math.sin(pitch) * Math.sin(theta) + Math.cos(pitch) * Math.cos(theta) * Math.cos(ydiff));\r\n\r\n        // Add node to current nodes and load texture if needed\r\n        var inCurrent = false;\r\n        for (var k = 0; k < program.nodeCache.length; k++) {\r\n          if (program.nodeCache[k].path == node.path) {\r\n            inCurrent = true;\r\n            program.nodeCache[k].timestamp = program.nodeCacheTimestamp++;\r\n            program.nodeCache[k].diff = node.diff;\r\n            program.currentNodes.push(program.nodeCache[k]);\r\n            break;\r\n          }\r\n        }\r\n        if (!inCurrent) {\r\n          //node.color = [Math.random(), Math.random(), Math.random()];\r\n          node.timestamp = program.nodeCacheTimestamp++;\r\n          program.currentNodes.push(node);\r\n          program.nodeCache.push(node);\r\n        }\r\n\r\n        // TODO: Test error\r\n        // Create child nodes\r\n        if (node.level < program.level) {\r\n          var cubeSize = image.cubeResolution * Math.pow(2, node.level - image.maxLevel);\r\n          var numTiles = Math.ceil(cubeSize * image.invTileResolution) - 1;\r\n          var doubleTileSize = cubeSize % image.tileResolution * 2;\r\n          var lastTileSize = cubeSize * 2 % image.tileResolution;\r\n          if (lastTileSize === 0) {\r\n            lastTileSize = image.tileResolution;\r\n          }\r\n          if (doubleTileSize === 0) {\r\n            doubleTileSize = image.tileResolution * 2;\r\n          }\r\n          var f = 0.5;\r\n          if (node.x == numTiles || node.y == numTiles) {\r\n            f = 1.0 - image.tileResolution / (image.tileResolution + lastTileSize);\r\n          }\r\n          var i = 1.0 - f;\r\n          var children = [];\r\n          var vtmp, ntmp;\r\n          var f1 = f,\r\n              f2 = f,\r\n              f3 = f,\r\n              i1 = i,\r\n              i2 = i,\r\n              i3 = i;\r\n          // Handle non-symmetric tiles\r\n          if (lastTileSize < image.tileResolution) {\r\n            if (node.x == numTiles && node.y != numTiles) {\r\n              f2 = 0.5;\r\n              i2 = 0.5;\r\n              if (node.side == 'd' || node.side == 'u') {\r\n                f3 = 0.5;\r\n                i3 = 0.5;\r\n              }\r\n            } else if (node.x != numTiles && node.y == numTiles) {\r\n              f1 = 0.5;\r\n              i1 = 0.5;\r\n              if (node.side == 'l' || node.side == 'r') {\r\n                f3 = 0.5;\r\n                i3 = 0.5;\r\n              }\r\n            }\r\n          }\r\n          // Handle small tiles that have fewer than four children\r\n          if (doubleTileSize <= image.tileResolution) {\r\n            if (node.x == numTiles) {\r\n              f1 = 0;\r\n              i1 = 1;\r\n              if (node.side == 'l' || node.side == 'r') {\r\n                f3 = 0;\r\n                i3 = 1;\r\n              }\r\n            }\r\n            if (node.y == numTiles) {\r\n              f2 = 0;\r\n              i2 = 1;\r\n              if (node.side == 'd' || node.side == 'u') {\r\n                f3 = 0;\r\n                i3 = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          vtmp = [v[0], v[1], v[2], v[0] * f1 + v[3] * i1, v[1] * f + v[4] * i, v[2] * f3 + v[5] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[0] * f + v[9] * i, v[1] * f2 + v[10] * i2, v[2] * f3 + v[11] * i3];\r\n          ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2, node.y * 2, image.fullpath);\r\n          children.push(ntmp);\r\n          if (!(node.x == numTiles && doubleTileSize <= image.tileResolution)) {\r\n            vtmp = [v[0] * f1 + v[3] * i1, v[1] * f + v[4] * i, v[2] * f3 + v[5] * i3, v[3], v[4], v[5], v[3] * f + v[6] * i, v[4] * f2 + v[7] * i2, v[5] * f3 + v[8] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3];\r\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2 + 1, node.y * 2, image.fullpath);\r\n            children.push(ntmp);\r\n          }\r\n          if (!(node.x == numTiles && doubleTileSize <= image.tileResolution) && !(node.y == numTiles && doubleTileSize <= image.tileResolution)) {\r\n            vtmp = [v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[3] * f + v[6] * i, v[4] * f2 + v[7] * i2, v[5] * f3 + v[8] * i3, v[6], v[7], v[8], v[9] * f1 + v[6] * i1, v[10] * f + v[7] * i, v[11] * f3 + v[8] * i3];\r\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2 + 1, node.y * 2 + 1, image.fullpath);\r\n            children.push(ntmp);\r\n          }\r\n          if (!(node.y == numTiles && doubleTileSize <= image.tileResolution)) {\r\n            vtmp = [v[0] * f + v[9] * i, v[1] * f2 + v[10] * i2, v[2] * f3 + v[11] * i3, v[0] * f1 + v[6] * i1, v[1] * f2 + v[7] * i2, v[2] * f3 + v[8] * i3, v[9] * f1 + v[6] * i1, v[10] * f + v[7] * i, v[11] * f3 + v[8] * i3, v[9], v[10], v[11]];\r\n            ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x * 2, node.y * 2 + 1, image.fullpath);\r\n            children.push(ntmp);\r\n          }\r\n          for (var j = 0; j < children.length; j++) {\r\n            testMultiresNode(rotPersp, children[j], pitch, yaw, hfov);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Creates cube vertex array.\r\n     * @private\r\n     * @returns {number[]} Cube vertex array.\r\n     */\r\n    function createCube() {\r\n      return [-1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, // Front face\r\n      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // Back face\r\n      -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, // Up face\r\n      -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Down face\r\n      -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // Left face\r\n      1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1 // Right face\r\n      ];\r\n    }\r\n\r\n    /**\r\n     * Creates 3x3 identity matrix.\r\n     * @private\r\n     * @returns {number[]} Identity matrix.\r\n     */\r\n    function identityMatrix3() {\r\n      return [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    /**\r\n     * Rotates a 3x3 matrix.\r\n     * @private\r\n     * @param {number[]} m - Matrix to rotate.\r\n     * @param {number[]} angle - Angle to rotate by in radians.\r\n     * @param {string} axis - Axis to rotate about (`x`, `y`, or `z`).\r\n     * @returns {number[]} Rotated matrix.\r\n     */\r\n    function rotateMatrix(m, angle, axis) {\r\n      var s = Math.sin(angle);\r\n      var c = Math.cos(angle);\r\n      if (axis == 'x') {\r\n        return [m[0], c * m[1] + s * m[2], c * m[2] - s * m[1], m[3], c * m[4] + s * m[5], c * m[5] - s * m[4], m[6], c * m[7] + s * m[8], c * m[8] - s * m[7]];\r\n      }\r\n      if (axis == 'y') {\r\n        return [c * m[0] - s * m[2], m[1], c * m[2] + s * m[0], c * m[3] - s * m[5], m[4], c * m[5] + s * m[3], c * m[6] - s * m[8], m[7], c * m[8] + s * m[6]];\r\n      }\r\n      if (axis == 'z') {\r\n        return [c * m[0] + s * m[1], c * m[1] - s * m[0], m[2], c * m[3] + s * m[4], c * m[4] - s * m[3], m[5], c * m[6] + s * m[7], c * m[7] - s * m[6], m[8]];\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Turns a 3x3 matrix into a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Expanded matrix.\r\n     */\r\n    function makeMatrix4(m) {\r\n      return [m[0], m[1], m[2], 0, m[3], m[4], m[5], 0, m[6], m[7], m[8], 0, 0, 0, 0, 1];\r\n    }\r\n\r\n    /**\r\n     * Transposes a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Transposed matrix.\r\n     */\r\n    function transposeMatrix4(m) {\r\n      return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];\r\n    }\r\n\r\n    /**\r\n     * Creates a perspective matrix.\r\n     * @private\r\n     * @param {number} hfov - Desired horizontal field of view.\r\n     * @param {number} aspect - Desired aspect ratio.\r\n     * @param {number} znear - Near distance.\r\n     * @param {number} zfar - Far distance.\r\n     * @returns {number[]} Generated perspective matrix.\r\n     */\r\n    function makePersp(hfov, aspect, znear, zfar) {\r\n      var fovy = 2 * Math.atan(Math.tan(hfov / 2) * gl.drawingBufferHeight / gl.drawingBufferWidth);\r\n      var f = 1 / Math.tan(fovy / 2);\r\n      return [f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zfar + znear) / (znear - zfar), 2 * zfar * znear / (znear - zfar), 0, 0, -1, 0];\r\n    }\r\n\r\n    /**\r\n     * Processes a loaded texture image into a WebGL texture.\r\n     * @private\r\n     * @param {Image} img - Input image.\r\n     * @param {WebGLTexture} tex - Texture to bind image to.\r\n     */\r\n    function processLoadedTexture(img, tex) {\r\n      gl.bindTexture(gl.TEXTURE_2D, tex);\r\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.bindTexture(gl.TEXTURE_2D, null);\r\n    }\r\n\r\n    var pendingTextureRequests = [];\r\n\r\n    // Based on http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html\r\n    var loadTexture = function () {\r\n      var cacheTop = 4; // Maximum number of concurrents loads\r\n      var textureImageCache = {};\r\n      var crossOrigin;\r\n\r\n      function TextureImageLoader() {\r\n        var self = this;\r\n        this.texture = this.callback = null;\r\n        this.image = new Image();\r\n        this.image.crossOrigin = crossOrigin ? crossOrigin : 'anonymous';\r\n        var loadFn = function loadFn() {\r\n          if (self.image.width > 0 && self.image.height > 0) {\r\n            // ignore missing tile to supporting partial image\r\n            processLoadedTexture(self.image, self.texture);\r\n            self.callback(self.texture, true);\r\n          } else {\r\n            self.callback(self.texture, false);\r\n          }\r\n          releaseTextureImageLoader(self);\r\n        };\r\n        this.image.addEventListener('load', loadFn);\r\n        this.image.addEventListener('error', loadFn); // ignore missing tile file to support partial image, otherwise retry loop causes high CPU load\r\n      };\r\n\r\n      TextureImageLoader.prototype.loadTexture = function (src, texture, callback) {\r\n        this.texture = texture;\r\n        this.callback = callback;\r\n        this.image.src = src;\r\n      };\r\n\r\n      function PendingTextureRequest(node, src, texture, callback) {\r\n        this.node = node;\r\n        this.src = src;\r\n        this.texture = texture;\r\n        this.callback = callback;\r\n      };\r\n\r\n      function releaseTextureImageLoader(til) {\r\n        if (pendingTextureRequests.length) {\r\n          var req = pendingTextureRequests.shift();\r\n          til.loadTexture(req.src, req.texture, req.callback);\r\n        } else {\r\n          textureImageCache[cacheTop++] = til;\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < cacheTop; i++) {\r\n        textureImageCache[i] = new TextureImageLoader();\r\n      }\r\n\r\n      return function (node, src, callback, _crossOrigin) {\r\n        crossOrigin = _crossOrigin;\r\n        var texture = gl.createTexture();\r\n        if (cacheTop) {\r\n          textureImageCache[--cacheTop].loadTexture(src, texture, callback);\r\n        } else {\r\n          pendingTextureRequests.push(new PendingTextureRequest(node, src, texture, callback));\r\n        }\r\n        return texture;\r\n      };\r\n    }();\r\n\r\n    /**\r\n     * Loads image and creates texture for a multires node / tile.\r\n     * @private\r\n     * @param {MultiresNode} node - Input node.\r\n     */\r\n    function processNextTile(node) {\r\n      loadTexture(node, encodeURI(node.path + '.' + image.extension), function (texture, loaded) {\r\n        node.texture = texture;\r\n        node.textureLoaded = loaded ? 2 : 1;\r\n      }, globalParams.crossOrigin);\r\n    }\r\n\r\n    /**\r\n     * Finds and applies optimal multires zoom level.\r\n     * @private\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\r\n    function checkZoom(hfov) {\r\n      // Find optimal level\r\n      var newLevel = 1;\r\n      while (newLevel < image.maxLevel && gl.drawingBufferWidth > image.tileResolution * Math.pow(2, newLevel - 1) * Math.tan(hfov / 2) * 0.707) {\r\n        newLevel++;\r\n      }\r\n\r\n      // Apply change\r\n      program.level = newLevel;\r\n    }\r\n\r\n    /**\r\n     * Rotates perspective matrix.\r\n     * @private\r\n     * @param {number[]} p - Perspective matrix.\r\n     * @param {number[]} r - Rotation matrix.\r\n     * @returns {number[]} Rotated matrix.\r\n     */\r\n    function rotatePersp(p, r) {\r\n      return [p[0] * r[0], p[0] * r[1], p[0] * r[2], 0, p[5] * r[4], p[5] * r[5], p[5] * r[6], 0, p[10] * r[8], p[10] * r[9], p[10] * r[10], p[11], -r[8], -r[9], -r[10], 0];\r\n    }\r\n\r\n    /**\r\n     * Applies rotated perspective matrix to a 3-vector\r\n     * (last element is inverted).\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input 3-vector.\r\n     * @returns {number[]} Resulting 4-vector.\r\n     */\r\n    function applyRotPerspToVec(m, v) {\r\n      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[4] * v[0] + m[5] * v[1] + m[6] * v[2], m[11] + m[8] * v[0] + m[9] * v[1] + m[10] * v[2], 1 / (m[12] * v[0] + m[13] * v[1] + m[14] * v[2])];\r\n    }\r\n\r\n    /**\r\n     * Checks if a vertex is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input vertex.\r\n     * @returns {number} 1 or -1 if the vertex is or is not visible,\r\n     *      respectively.\r\n     */\r\n    function checkInView(m, v) {\r\n      var vpp = applyRotPerspToVec(m, v);\r\n      var winX = vpp[0] * vpp[3];\r\n      var winY = vpp[1] * vpp[3];\r\n      var winZ = vpp[2] * vpp[3];\r\n      var ret = [0, 0, 0];\r\n\r\n      if (winX < -1) {\r\n        ret[0] = -1;\r\n      }\r\n      if (winX > 1) {\r\n        ret[0] = 1;\r\n      }\r\n      if (winY < -1) {\r\n        ret[1] = -1;\r\n      }\r\n      if (winY > 1) {\r\n        ret[1] = 1;\r\n      }\r\n      if (winZ < -1 || winZ > 1) {\r\n        ret[2] = 1;\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * Checks if a square (tile) is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Square's vertex array.\r\n     * @returns {boolean} Whether or not the square is visible.\r\n     */\r\n    function checkSquareInView(m, v) {\r\n      var check1 = checkInView(m, v.slice(0, 3));\r\n      var check2 = checkInView(m, v.slice(3, 6));\r\n      var check3 = checkInView(m, v.slice(6, 9));\r\n      var check4 = checkInView(m, v.slice(9, 12));\r\n      var testX = check1[0] + check2[0] + check3[0] + check4[0];\r\n      if (testX == -4 || testX == 4) {\r\n        return false;\r\n      }\r\n      var testY = check1[1] + check2[1] + check3[1] + check4[1];\r\n      if (testY == -4 || testY == 4) {\r\n        return false;\r\n      }\r\n      var testZ = check1[2] + check2[2] + check3[2] + check4[2];\r\n      return testZ != 4;\r\n    }\r\n\r\n    /**\r\n     * On iOS (iPhone 5c, iOS 10.3), this WebGL error occurs when the canvas is\r\n     * too big. Unfortuately, there's no way to test for this beforehand, so we\r\n     * reduce the canvas size if this error is thrown.\r\n     * @private\r\n     */\r\n    function handleWebGLError1286() {\r\n      console.log('Reducing canvas size due to error 1286!');\r\n      canvas.width = Math.round(canvas.width / 2);\r\n      canvas.height = Math.round(canvas.height / 2);\r\n    }\r\n  }\r\n\r\n  // Vertex shader for equirectangular and cube\r\n  var v = ['attribute vec2 a_texCoord;', 'varying vec2 v_texCoord;', 'void main() {',\r\n  // Set position\r\n  'gl_Position = vec4(a_texCoord, 0.0, 1.0);',\r\n\r\n  // Pass the coordinates to the fragment shader\r\n  'v_texCoord = a_texCoord;', '}'].join('');\r\n\r\n  // Vertex shader for multires\r\n  var vMulti = ['attribute vec3 a_vertCoord;', 'attribute vec2 a_texCoord;', 'uniform mat4 u_cubeMatrix;', 'uniform mat4 u_perspMatrix;', 'varying mediump vec2 v_texCoord;', 'void main(void) {',\r\n  // Set position\r\n  'gl_Position = u_perspMatrix * u_cubeMatrix * vec4(a_vertCoord, 1.0);',\r\n\r\n  // Pass the coordinates to the fragment shader\r\n  'v_texCoord = a_texCoord;', '}'].join('');\r\n\r\n  // Fragment shader\r\n  var fragEquiCubeBase = ['precision mediump float;', 'uniform float u_aspectRatio;', 'uniform float u_psi;', 'uniform float u_theta;', 'uniform float u_f;', 'uniform float u_h;', 'uniform float u_v;', 'uniform float u_vo;', 'uniform float u_rot;', 'const float PI = 3.14159265358979323846264;',\r\n\r\n  // Texture\r\n  'uniform sampler2D u_image;', 'uniform samplerCube u_imageCube;',\r\n\r\n  // Coordinates passed in from vertex shader\r\n  'varying vec2 v_texCoord;',\r\n\r\n  // Background color (display for partial panoramas)\r\n  'uniform vec4 u_backgroundColor;', 'void main() {',\r\n  // Map canvas/camera to sphere\r\n  'float x = v_texCoord.x * u_aspectRatio;', 'float y = v_texCoord.y;', 'float sinrot = sin(u_rot);', 'float cosrot = cos(u_rot);', 'float rot_x = x * cosrot - y * sinrot;', 'float rot_y = x * sinrot + y * cosrot;', 'float sintheta = sin(u_theta);', 'float costheta = cos(u_theta);', 'float a = u_f * costheta - rot_y * sintheta;', 'float root = sqrt(rot_x * rot_x + a * a);', 'float lambda = atan(rot_x / root, a / root) + u_psi;', 'float phi = atan((rot_y * costheta + u_f * sintheta) / root);'].join('\\n');\r\n\r\n  // Fragment shader\r\n  var fragCube = fragEquiCubeBase + [\r\n  // Look up color from texture\r\n  'float cosphi = cos(phi);', 'gl_FragColor = textureCube(u_imageCube, vec3(cosphi*sin(lambda), sin(phi), cosphi*cos(lambda)));', '}'].join('\\n');\r\n\r\n  // Fragment shader\r\n  var fragEquirectangular = fragEquiCubeBase + [\r\n  // Wrap image\r\n  'lambda = mod(lambda + PI, PI * 2.0) - PI;',\r\n\r\n  // Map texture to sphere\r\n  'vec2 coord = vec2(lambda / PI, phi / (PI / 2.0));',\r\n\r\n  // Look up color from texture\r\n  // Map from [-1,1] to [0,1] and flip y-axis\r\n  'if(coord.x < -u_h || coord.x > u_h || coord.y < -u_v + u_vo || coord.y > u_v + u_vo)', 'gl_FragColor = u_backgroundColor;', 'else', 'gl_FragColor = texture2D(u_image, vec2((coord.x + u_h) / (u_h * 2.0), (-coord.y + u_v + u_vo) / (u_v * 2.0)));', '}'].join('\\n');\r\n\r\n  // Fragment shader\r\n  var fragMulti = ['varying mediump vec2 v_texCoord;', 'uniform sampler2D u_sampler;',\r\n  //'uniform mediump vec4 u_color;',\r\n\r\n  'void main(void) {',\r\n  // Look up color from texture\r\n  'gl_FragColor = texture2D(u_sampler, v_texCoord);',\r\n  //    'gl_FragColor = u_color;',\r\n  '}'].join('');\r\n\r\n  return {\r\n    renderer: function renderer(container, image, imagetype, dynamic) {\r\n      return new Renderer(container, image, imagetype, dynamic);\r\n    }\r\n  };\r\n}(window, document);"]},"metadata":{},"sourceType":"script"}